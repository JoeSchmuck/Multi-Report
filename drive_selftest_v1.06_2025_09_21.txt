#!/bin/bash

LANG="en_US.UTF-8"
if [[ $TERM == "dumb" ]]; then          # Set a terminal as the script may generate an error message if using 'dumb'.
    export TERM=unknown
fi
##### Version 1.06

Program_Name="drive_selftest.sh"
Version="1.06"                            # Current version of the script
Version_Date="(30 Aug 2025)"

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

### FILE NAME SHOULD BE 'drive_selftest.sh' TO INTEGRATE WITH MULTI-REPORT
###
### MULTIPLE DRIVE SMART SELF-TEST SCRIPT (TO EASE YOUR CONFIGURATION NEEDS)
###    
### WHAT DOES THIS SCRIPT DO?
###
### THIS SCRIPT WAS ORIGINALLY DESIGNED FOR PEOPLE WHO HAVE A LOT OF DRIVES AND
### DO NOT WANT TO SCHEDULE EACH DRIVE INDIVIDUALLY FOR SMART TESTING.
### ADDITIONALLY THIS CAN BE USED WITH MULTI-REPORT 3.1 OR LATER TO RUN SMART TESTS
### AND UTILIZE THE MULTI-REPORT CONFIGURATION FILE IF DESIRED.
###        
### THIS SCRIPT WILL SPREAD OUT THE SMART SHORT AND LONG/EXTENDED TESTING IN THREE
### POSSIBLE WAYS, INCLUDING THE OPTION TO NOT TEST AT ALL:
###  1. SPREAD ACROSS A WEEK (ON SPECIFIED DAYS OF THE WEEK)
###  2. SPREAD ACROSS A MONTH (ON SPECIFIED DAYS OF THE WEEK)
###  3. ALL DRIVES (ON SPECIFIED DAYS OF THE WEEK)
###  4. OR NO DRIVES AT ALL
### SPECIFIED DAYS OF THE WEEK ARE: 1=MON, 2=TUE, 3=WED, 4=THU, 5=FRI, 6=SAT, 7=SUN.
###
### THESE ARE BROKEN DOWN INTO SHORT TESTS AND LONG TESTS.
### THE DRIVES CAN BE TESTED IN DRIVE NAME (ID) ORDER (ADA0, ADA1, OR SDA, SDB) OR
### SORTED BY SERIAL NUMBER (A POOR MANS CRAPPY METHOD TO SIMULATE RANDOMIZATION OF DRIVES TO REDUCE DRIVES
### BEING TESTED IN THE SAME DRIVE CAGE TO REDUCE POWER DRAW AND HEAT, AND IT MAY NOT REALLY WORK THAT WAY)
###
### THE DEFAULT SETTINGS ARE:
###    1. DAILY SHORT TESTS ON EACH DRIVE (TEST MODE 2)
###       -SORTED BY DRIVE NAME/ID, ALL DRIVES TESTED EVERY DAY, RUNS 7 DAYS A WEEK
###    2. MONTHLY LONG TESTS ON EACH DRIVE (TEST MODE 1, MONTHLY)
###       -SORTED BY SERIAL NUMBER, ONE DRIVE A DAY, ONE TEST PER MONTH, RUNS 7 DAYS A WEEK
###    3. LOGGING ENABLED
###    4. SCRUB/RESILVER TIME REMAINING OVER 3 HOURS WILL RUN A SHORT TEST VICE LONG TEST.
###
### READ THE USER GUIDE AND CONFIGURATION SECTION BELOW, MAKE CHANGES AS DESIRED.
###
### A LOG FILE BY DEFAULT IS CREATED IN THE SCRIPT DIRECTORY, ONE FOR EACH DAY
### OF THE MONTH.  IT WILL OVERWRITE ONCE A NEW MONTH STARTS.
###
### IF YOU ALREADY HAVE SMART TESTING FOR A DAILY SMART SHORT TEST THEN YOU CAN SET
### TEST MODE 3 FOR SHORT TESTS TO MITIGATE DUPLICATE TESTING.
###
### IF YOU HAVE ALL YOUR DRIVES SETUP IN TRUENAS EXCEPT NVME, THERE IS AN OPTION TO RUN NVME ONLY.
###
### USE [-help] FOR ADDITIONAL INFORMATION

# Change Log

# Version 1.06 (30 Aug 2025)
#
# - Updated Silent to be more effective when enabled.
# - Changed RESILVER and SCRUB to limit SMART tests to only the pools affected.
# - Changed RESILVER and SCRUB to have a 'disable' option and let SMART tests run regardless of RESIVLER or SCRUB in progress.
# - Added drive testing tracking in CSV file.  This will ensure all drives are SMART LONG tested promptly if the script is not run everyday and a drive is missed.
# - Added a "Maximum_Catchup_Drive_Count" variable to limit how many additional drives can be LONG tested if they were missed.
#


#
# Version 1.05 (07 June 2025)
#
# - Updated the smartctl interface connection to roll through several more variations if the default fails to work.
#   ---- This did impact a few people but it has been fixed now. This also "should" open up options for USB connected devices.
# - Added '--scan' output to a file for data collection.
# - Updated Debugging Data for Troubleshooting and analysis.
# - Updated '-help' information.
# - Fixed potential drive not being Long tested if it had a similar name to a Short test drive (da1 and da11 was the noted problem).
# - Updated Debug to be enabled during a Multi-report -dump switch.
# - Added RESILVER/SCRUB Override for SMART Long tests (by request).
# - Converted options from 'true/false' to 'enable/disable' to make more sense.
# - Fixed reading the multi_report_config.txt file earlier in the script execution.
#
#  Thanks go out to @SD for helping with the script.  It is good to have a different set of eyes looking at things.
#

# Version 1.04 (22 February 2025)
#
# - Added checking for SCRUB and RESILVER and run SMART LONG/SHORT tests appropriately. Default = No SMART Long Testing during SCRUB/RESILVER operations.
# - Updated the 'Silent' function to ONLY display really important information only, such as a failure or an update is available.
# - Improved the Update/Automatic Update feature.
# - Removed erroneous 'Month' messages
# - Improved 'demo' Mode

# Version 1.03 (26 January 2025)
#
# - Added Test NVMe Drives Only option (by request).
# - Improved the Update feature.
# - Streamlined the CRON JOB output a bit.
#

# Version 1.02 (16 January 2025)
#
# 27 December - Addressed invalid drives for SMART testing.
# 10 January  - Finished no sleep if no tests.
#
# Initial Release Version 1.0 (10 January 2025)
#


######################## USER SETTINGS ########################

###### NEW SCRIPT TO TEST LOTS OF DRIVES ######
###                                         ###
###          THESE ARE FUNCTIONAL           ###
###         MAKE YOUR CHANGES HERE          ###
###          THESE ARE OVERRIDDEN           ###
###      BY MULTI_REPORT_CONFIG.TXT         ###
###                                         ###
###############################################

### EXTERNAL CONFIGURATION FILE
Config_File_Name=$SCRIPT_DIR"/multi_report_config.txt"
Use_multi_report_config_values="enable"     #  An "enable" value here will use the $Config_File_Name file values to override the values defined below, if it exists.
                                            #  This allows the values to be retained between versions.  A "disable" will not allow the external config file to be
                                            #  used regardless of any other settings and therefore would utilize the values below. Default="enable"

###### SCRIPT UPDATES
Check_For_Updates="enable"                  # This will check to see if an update is available. Default="enable"

Automatic_Selftest_Update="disable"         # WARNING !!!  This option will automatically update the Drive_Selftest script if a newer version exists on GitHub
                                            # with no user interaction. Default = "disable"
                                            
##### SMARTCTL_Interface_Options            # This variable is used to attempt to account for drives not easily accessible and the interface must be changed.
                                            # You can add to this list if you find a setting that works for you, you must maintain the format.
SMARTCTL_Interface_Options="auto,sat,atacam,scsi,nvme"

###### HDD/SSD/NVMe SMART Testing
Test_ONLY_NVMe_Drives="disable"             # This option when set to "enable" will only test NVMe drives, HDD/SSD will not be tested. Default = "disable"

Track_Drive_Testing_Dates="enable"			# This will allow you to not skip a SMART Long test due to your system not running the script every day as proposed.

SCRUB_Minutes_Remaining=60                  # This option when set between 1 and 9999 (in minutes) will not run a SMART LONG test  on a pool if a SCRUB has longer
                                            # than xx minutes remaining, and a SMART SHORT test will be run instead to provide minimal impact to the SCRUB operation.
                                            #  A value of 0 (zero) will disable all SMART test(s) on the affected pool during a SCRUB operation.  Default=60
                                            #  NOTE: A RESILVER operation on a pool automatically cancels SMART Long testing for that pool to put priority on rebuilding the pool.
                                            #  -- Long Tests are allowed for pools in which a SCRUB is not active on.

SCRUB_RESILVER_OVERRIDE="disable"           # This option will allow all SCRUB actions to occur regardless of the SCRUB_Minutes_Remaining variable
                                            # meaning that if a SCRUB or a RESILVER is in progress, any given SMART testing will be performed.
                                            # I do not advise enabling this option but someone will ask for it, here it is.

Maximum_Catchup_Drive_Count=1				# This value defines the maximum number of drive to add to the Long test list if some drives missed Long testing
											# due to SCRUB, RESILVER, or most likely the script not being run every day as it is designed to be used.
											# Recommended Settings Formula:  Number of Drives / Number of Authorized Days = X.  Round X up to the nearest whole number.
											#  NOTE: Number of Authorized Days is the count of days listed in the "Long_Drives_Tested_Days_of_the_Week".
											#    Example:  8 drives / 7 days (weekly) = 1.14 then round up to equal 2.
											#    Example:  12 drives / 5 days (Mon-Fri, Sat & Sun powered off) = 2.4 then round up to equal 3.
											#    Example:  50 drives / 28 days (monthly) = 1.78 then round up to equal 2.
											# With all that said, a value of "1" (default) is likely the best setting.
											# A value of "0" (zero) disables this catchup feature.

### SHORT SETTINGS - INSTRUCTIONS ### ------------------------------------------------------
# IF Short_Test_Mode is = 1, The settings in Group 1 and Group 2 are used.
# IF Short_Test_Mode is = 2, The settings in Group 1 are used, Group 2 are ignored.
# IF Short_Test_Mode is = 3, The settings in Group 1 and Group 2 are ignored, no Short Testing will be performed.

# Set Test Mode - ALWAYS Required
Short_Test_Mode=2                           # 1 = Use Short_Drives_to_Test_Per_Day value, 2 = All Drives Tested (Ignores most other options), 3 = No Drives Tested.

# Group 1 - ONLY Matters if Test Mode is = 1 or 2.
Short_Time_Delay_Between_Drives=1           # Tests will have a XX second delay between the drives starting testing. If drives are always spinning, this can be "0".
Short_Drives_Test_Delay=130                 # How long to delay when running Short tests, before exiting to controlling procedure.  Default is 130 second should allow.
                                            # Short tests to complete before continuing.  If using without Multi-Report, set this value to 1.
# Group 2 - ONLY Matters if Test Mode is = 1.
Short_SMART_Testing_Order="DriveID"         # Test order is for Test Mode 1 ONLY, select "Serial" or "DriveID" for sort order.  Default = "Serial"
Short_Drives_to_Test_Per_Day=1              # For Test_Mode 1) How many drives to run each day minimum?
Short_Drives_Test_Period="Week"             # "Week" (7 days) or "Month" (28 days)
Short_Drives_Tested_Days_of_the_Week="1,2,3,4,5,6,7"    # Days of the week to run, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun.  # This takes over for number of days variable.

### LONG SETTINGS - INSTRUCTIONS ### ------------------------------------------------------
# IF Long_Test_Mode is = 1, The settings in Group 1 and Group 2 are used.
# IF Long_Test_Mode is = 2, The settings in Group 1 are used, Group 2 are ignored.
# IF Long_Test_Mode is = 3, The settings in Group 1 and Group 2 are ignored, no Long Testing will be performed.

# Set Test Mode - ALWAYS Required
Long_Test_Mode=1                            # 1 = Use Long_Drives_to_Test_Per_Day value, 2 = All Drives Tested (Ignores most other options), 3 = No Drives Tested.

# Group 1 - ONLY Matters if Test Mode is = 1 or 2.
Long_Time_Delay_Between_Drives=1            # Tests will have a XX second delay between the drives starting the next test.

# Group 2 - ONLY Matters if Test Mode is = 1.
Long_SMART_Testing_Order="Serial"           # Test order is either "Serial" or "DriveID".  Default = 'Serial'
Long_Drives_to_Test_Per_Day=1               # For Test_Mode 1) How many drives to run each day minimum?
Long_Drives_Test_Period="Week"              # "Week" (7 days) or "Month" (28 days)
Long_Drives_Tested_Days_of_the_Week="1,2,3,4,5,6,7"     # Days of the week to run, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun. # This takes over for number of days variable.
#### END OF TEST MODE SETTINGS #### ------------------------------------------------------

### IGNORE DRIVES LIST
# IF YOU HAVE A DRIVE THAT YOU DO NOT WANT THIS SCRIPT TO TOUCH (RUN ANY TESTS ON), THEN INCLUDE THE DRIVE SERIAL NUMBER
# IN THE LIST.  IF THE SERIAL NUMBER MATCHES THEN THE DRIVE IS REMOVED FROM TESTING. BELOW IS AN EXAMPLE.
# Example:  Ignore_Drives_List="RQTY4D78E,JJ6XTZ,OU812,ZR13JRL"
Ignore_Drives_List=""

### REPORT & Misc
Drive_List_Length=10                        # This is how many drive IDs to list per line.  Default is 10.
Enable_Logging="enable"                     # This will create a text file named "drive_test_xx.txt". Run -clearlog
LOG_DIR=$SCRIPT_DIR"/DS_Logs"               # The default log directory is the script directory.
Silent="disable"                            # When "enable" only error messages will be output to the stdout.
selftest_data_file=$SCRIPT_DIR"/drive_selftest_tracking.txt"		# This is the location and file name for the tracking of the selftest drive dates.


#######################################
#######################################
###                                 ###
###  STOP EDITING THE SCRIPT HERE   ###
###     DO NOT CHANGE ANYTHING      ###
###        BELOW THIS LINE          ###
###                                 ###
#######################################
#######################################

###### DEBUG SECTION ######
# DEBUG is to be used to display extra operational data for troubleshooting the script.
# I do not recommend people play with anything here.

Debug="false"            # Default = "false"
Debug_Steps="false"      # Default = "false"
simulated_drives=0       # Set to '0' to use actual drives, or to any number to use simulated drives (the Serial option will not work)

###### Auto-generated Parameters
softver=$(uname -s)

if [[ $softver != "Linux" ]]; then
  if [[ "$(cat /etc/version | grep "FreeNAS")" ]]; then
    programver="FreeNAS "$(cat /etc/version | cut -d " " -f1 | sed 's/FreeNAS-//')
    programver3="$(cat /etc/version | cut -d " " -f1 | sed 's/FreeNAS-//' | cut -d "." -f1)"
    programver4="$(cat /etc/version | cut -d "." -f2 | cut -c1)"
  else
    programver="TrueNAS Core "$(cat /etc/version | cut -d " " -f1 | sed 's/TrueNAS-//')
    programver3="$(cat /etc/version | cut -d " " -f1 | sed 's/TrueNAS-//' | cut -d "." -f1)"
    programver4="$(cat /etc/version | cut -d "." -f2 | cut -c1)"
  fi
	# Run other BSD commands
	timestamp=$(date +%T)
	expireDate_Day=$(date -v +01d +%Y%m%d)
	expireDate_Week=$(date -v +07d +%Y%m%d)
	expireDate_Month=$(date -v +01m +%Y%m%d)
	DOW=$(date '+%u')                          # Todays Day of the Week, 1=Mon, 7=Sun
    Full_Month_Name=$(date '+%B')              # Full name of current month
  
else
    programver="TrueNAS Scale "$(cat /etc/version)
    programver3="$(cat /etc/version | cut -d "." -f1)"
    programver4=6            # Using symbolic value so script works as written, just for SCALE.
	
	# Run other Linux Commands
	timestamp=$(date +"%T")
	expireDate_Day=$(date -d '+01days' +%Y%m%d)
	expireDate_Week=$(date -d '+07days' +%Y%m%d)
	expireDate_Month=$(date -d '+01months' +%Y%m%d)
	DOW=$(date +%u)                       # Todays Day of the Week, 1=Mon, 7=Sun
    Full_Month_Name=$(date +%B)           # Full name of current month
fi
programver3=$(( programver3 + 0 ))        # Make Base 10
programver4=$(( programver4 + 0 ))
datestamp=$(date +%Y%m%d)
today_day=$(date +%d)


# GLOBAL VARIABLES - MUST BE DEFINED EARLY BEFORE FUNCTION TO BE GLOBAL
Drive_Disk_Query=""
smartdrives=""
selftest_drives=""
drives_name=""
drives_serial=""
drives_subsystem=""
driveConnectionType="auto"
Demo="false"
IFS_RESTORE=$IFS
selftest_drives_short=""
selftest_drives_long=""
Ready_to_Test="false"
start_time_display=""
end_time_display=""
end_tenths=""
NVMe_Override_Enabled=""
Short_Drives_Testing=""
Long_Drives_Testing=""
No_Tests="true"
RESILVER_Pools=""
SCRUB_Pools=""
checking_drives_temp_short=""
checking_drives_temp_long=""
temp_Drive_Counter=0
SCRUB_IN_PROGRESS_OKAY=""
SCRUB_IN_PROGRESS_NOT_OKAY=""

# Get Smartmontools version number 
smart_ver=$(smartctl | grep "7." | cut -d " " -f 2)

# Get all drive(s) interface data
smartctlscan=$(smartctl --scan-open)


##########################
##########################
###                    ###
###  DEFINE FUNCTIONS  ###
###                    ###
##########################
##########################


checkforupdate () {
if [[ $Debug_Steps == "true" ]]; then echo "checkforupdate" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    if [[ $Silent != "enable" ]]; then
		echo " "
		echo "Checking for Drive-Selftest Updates"
		echo " "
	else
		echo -n "."
	fi
    if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi

    if [[ "$(curl -is https://github.com | head -n 1)" ]]; then
        (
            cd /tmp
            if ! test -e "Multi-Report"; then
                mkdir Multi-Report
            fi
            cd Multi-Report
            curl -LJOs https://raw.githubusercontent.com/JoeSchmuck/Multi-Report/refs/heads/main/drive_selftest.txt            
        )    
        if test -e "/tmp/Multi-Report/drive_selftest.txt"; then
            GitDriveVersion=$(cat "/tmp/Multi-Report/drive_selftest.txt" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)
            GitDriveMajorVersionNumber="$(echo $GitDriveVersion | cut -d '.' -f1)"
            GitDriveMinorVersionNumber="$(echo $GitDriveVersion | cut -d '.' -f2)"
            convert_to_decimal $GitDriveMajorVersionNumber
            GitDriveMajorVersionNumber=$Return_Value
            if test -e $SCRIPT_DIR"/drive_selftest.sh"; then
                LocalDriveFilename="$(cat $SCRIPT_DIR"/drive_selftest.sh" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)"
                LocalMajorDriveVersionFilename="$(echo $LocalDriveFilename | cut -d '.' -f1)"
                LocalMinorDriveVersionFilename="$(echo $LocalDriveFilename | cut -d '.' -f2)"
                convert_to_decimal $LocalMajorDriveVersionFilename
                LocalMajorDriveVersionFilename=$Return_Value
            else
                LocalDriveFilename="Nothing Is Here"
            fi
			if [[ $Silent != "enable" ]] && [[ $GitDriveMajorVersionNumber -gt $LocalMajorDriveVersionFilename ]] && [[ $LocalDriveFilename != "" ]]; then
				echo -n "    Drive_Selftest - Installed: "$LocalDriveFilename", GitHub: "$GitDriveVersion
			fi
            if [[ $GitDriveMajorVersionNumber -gt $LocalMajorDriveVersionFilename ]] && [[ $LocalDriveFilename != "" ]]; then
			if [[ $Silent != "enable" ]]; then
                echo " - Major Update"
			fi
                UpdateDriveAvailable="true"
                rm /tmp/Multi-Report/drive_selftest.txt
            elif [[ $GitDriveMajorVersionNumber -eq $LocalMajorDriveVersionFilename ]] && [[ $GitDriveMinorVersionNumber > $LocalMinorDriveVersionFilename ]]; then
                UpdateDriveAvailable="true"
				if [[ $Silent != "enable" ]]; then
					echo " - Minor Update"
				fi
                rm /tmp/Multi-Report/drive_selftest.txt
            else
				if [[ $Silent != "enable" ]]; then
					echo " - No Update"
				fi
            fi        
            if [[ $Automatic_Selftest_Update == "enable" ]] && [[ $UpdateDriveAvailable == "true" ]]; then
                echo "     Automatic Update Enabled"
                update_Drive_script
            fi                    
        else
            echo "No GitHub Version File Available"
        fi
    fi

    if [[ $UpdateDriveAvailable == "true" ]]; then
		if [[ $Silent != "enable" ]]; then
			echo "################################################################################"
		else
			echo "###############################################################################"
		fi
        echo "#   An Update is Available -- Use the '-update' switch to update the script.   #"
		echo "#                Current Version: $LocalDriveFilename -- Update Version: $GitDriveVersion                  #"
        echo "################################################################################"
		echo " "
    fi

    }

    update_Drive_script () {
    if [[ $Debug_Steps == "true" ]]; then echo "update_Drive_script" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    echo "Update Script Routine"
    echo "Removing Old Local Script if it exists"
    if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi
    echo "Downloading new script files"
    if [[ "$(curl -is https://github.com | head -n 1)" ]]; then
        # Go git the file
        ( mkdir /tmp/Multi-Report
        cd /tmp/Multi-Report
        curl -LJOs https://raw.githubusercontent.com/JoeSchmuck/Multi-Report/refs/heads/main/drive_selftest.txt
        curl -LJOs https://raw.githubusercontent.com/JoeSchmuck/Multi-Report/refs/heads/main/Multi_Report_User_Guide.pdf
        )
        GitDriveVersion=$(cat "/tmp/Multi-Report/drive_selftest.txt" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)
        LocalDriveFilename=$(cat $SCRIPT_DIR"/drive_selftest.sh" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)
        echo " "
        echo "      - Drive_Selftest current version is: "$LocalDriveFilename
        echo "      - The Github version is: "$GitDriveVersion
        echo " "

        if [[ $Automatic_Selftest_Update != "enable" ]]; then
            echo "Enter 'y' to commit or any other key to abort."
            read Keyboard_yn
        else
            echo "Automatic Update is Enabled..."
            Keyboard_yn="y"
        fi
        if [[ $Keyboard_yn == "y" ]] || [[ $Keyboard_yn == "Y" ]]; then
            echo "Updating Script..."

            # Copy the new multi_report.sh file and set permissions
            cp /tmp/Multi-Report/drive_selftest.txt $SCRIPT_DIR"/drive_selftest.sh"
            chmod 755 $SCRIPT_DIR"/drive_selftest.sh" > /dev/null 2<&1

            # Copy the User Guide
            cp "/tmp/Multi-Report/Multi_Report_User_Guide.pdf" $SCRIPT_DIR"/."
            echo " "
            echo "Your script has been updated and a copy of the User Guide is current."
            UpdateDriveAvailable="false"        # Remove this after the update has completed.
        else
            echo "Aborted"
            exit 1
        fi
        # Cleanup Leftover Files
        if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi
    else
        echo "GitHub is Not Available"
    fi
    if [[ $Automatic_Selftest_Update != "enable" ]]; then 
        echo "Exiting..."
        exit 0
    fi

    }

convert_to_decimal () {
    if [[ $Debug_Steps == "true" ]]; then echo "convert_to_decimal: $1" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    if [[ "$1" == "" ]]; then return; fi
    Converting_Value=${1#0}
    Converting_Value="${Converting_Value//,}"
    Return_Value=$Converting_Value
    if [[ $1 == "0" ]]; then Return_Value=0; fi

    }

update_csv_file () {
	if [[ $Debug_Steps == "true" ]]; then echo "update_csv_file" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# Called from `run_smart_test` routine, two places, ONLY after return code of '0'.
#
# This will update the Comma Separated Values file containing the drive serial numbers, the last date/time a test command was accepted, and when the next expected
# due date is.
# Variables I need are: $drive,$datestamp,$timestamp, $1=Short | Long

	if [[ $Silent == "enable" ]]; then
		echo -n "."
	fi

# Delete any leftover old files, if they are around.
	if test -e "/tmp/tmp_file.txt"; then rm -f "/tmp/tmp_file.txt"; fi
	if test -e "/tmp/selftest_data_file.txt"; then rm -f "/tmp/selftest_data_file.txt"; fi
	
# Check for existence of the selftest tracking file.
	if ! test -e "$selftest_data_file"; then		# If the file does not exist, create it.
		printf "Date,Time,Serial Number,Drive ID,POH Last Completed Test,Next Short Test Date,Next Long Test Date\n" > "$selftest_data_file"
		echo "Created the selftest tracking data file."
		sleep .2
	fi
	drive_count=$(echo $drives_count | xargs)
	csv_lines=$(< "$selftest_data_file" wc -l | xargs)
	cat $selftest_data_file > /tmp/selftest_data_file.txt
    sleep .2
csv_drive_serial=$(smartctl -i /dev/${drive} | grep -i "Serial Number" | rev | cut -d " " -f1 | rev)
	IFS=" "
	for checking_drives in $smartdrives ; do
		# First, convert drive ID into a serial number to compare
		csv_serial=$(smartctl -i /dev/${checking_drives} | grep -i "Serial Number" | rev | cut -d " " -f1 | rev)

		if [[ $csv_serial == $csv_drive_serial ]]; then		# Why use drive_check_update? Because I don't want to change anything but the drive in play.  We could introduce false data otherwise.
			# GRAB CURRENT POWER ON HOURS VALUE FROM DRIVE
			if [[ $checking_drives == *"nvm"* ]]; then
				POH=$(smartctl -a /dev/${checking_drives} | grep -i "Power On Hours" | rev | cut -d " " -f1 | rev | tr -d ',')
			else
				POH=$(smartctl -a /dev/${checking_drives} | grep -i "Power_On_Hours" | rev | cut -d " " -f1 | rev)
			fi

			checking_drives_temp_long=$(cat "/tmp/selftest_data_file.txt" | grep -iw "$csv_drive_serial" | cut -d ',' -f7 | xargs)
			checking_drives_temp_short=$(cat "/tmp/selftest_data_file.txt" | grep -iw "$csv_drive_serial" | cut -d ',' -f6 | xargs)

			Next_Short_Test_Date=$checking_drives_temp_short
			Next_Long_Test_Date=$checking_drives_temp_long
			
# MODE 1 CALCS			
			if [[ "$Short_Test_Mode" == "1" ]] && [[ "$1" == "Short" ]]; then
				if [[ "$Short_Drives_Test_Period" == "Month" ]]; then		# Monthly
					Next_Short_Test_Date=$expireDate_Month				# Add 30 days
				elif [[ "$Short_Drives_Test_Period" == "Week" ]]; then
					Next_Short_Test_Date=$expireDate_Week				# Add 07 days
				else
					Next_Short_Test_Date=$expireDate_Day				# Add 01 day
				fi								
			elif [[ "$Long_Test_Mode" == "1" ]] && [[ $1 == "Long" ]]; then	
				if [[ "$Long_Drives_Test_Period" == "Month" ]]; then		# Monthly
					Next_Long_Test_Date=$expireDate_Month				# Add 30 days
				elif [[ "$Long_Drives_Test_Period" == "Week" ]]; then
					Next_Long_Test_Date=$expireDate_Week				# Add 07 days
				else
					Next_Long_Test_Date=$expireDate_Day					# Add 01 day
				fi
				
# MODE 2 CALCS				
			elif [[ "$Short_Test_Mode" == "2" ]] && [[ "$1" == "Short" ]]; then		# Assume Daily
				Next_Short_Test_Date=$expireDate_Day
			elif [[ "$Long_Test_Mode" == "2" ]] && [[ "$1" == "Long" ]]; then	
				Next_Long_Test_Date=$expireDate_Day
			fi
			
			if [[ "$Next_Short_Test_Date" == "" ]]; then Next_Short_Test_Date="NotTested"; fi
			if [[ "$Next_Long_Test_Date" == "" ]]; then Next_Long_Test_Date="NotTested"; fi			

			found=0
		
			while IFS= read -r line; do
				IFS=',' read -r Date Time SN Drive poh next_Short_Test_Date next_Long_Test_Date <<< "$line"
				if [[ "$SN" = "$csv_serial" ]]; then
					printf "$datestamp,$timestamp,$csv_serial,$POH,$checking_drives,$Next_Short_Test_Date,$Next_Long_Test_Date\n" >> /tmp/tmp_file.txt
					found=1
				else
					printf "$line\n" >> /tmp/tmp_file.txt
				fi
				sleep .2
			done < "/tmp/selftest_data_file.txt"
			
			if [[ $found -eq 0 ]]; then		# Append new entry and use expireDate_Month
				printf "$datestamp,$timestamp,$csv_serial,$checking_drives,$POH,$Next_Short_Test_Date,$Next_Long_Test_Date\n" >> /tmp/tmp_file.txt
			fi
			sleep .2
			cp "/tmp/tmp_file.txt" "$selftest_data_file"
			sleep .2
			rm -f "/tmp/tmp_file.txt"
			rm -f "/tmp/selftest_data_file.txt"
		fi
	done

	}


check_expired_drive_tests () {
if [[ $Debug_Steps == "true" ]]; then echo "check_expired_drive_tests" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# Global Variables: selftest_drives_short, selftest_drives_long, smartdrives

# This needs to be placed before scrub check or punted from there.

# Read to see who is expired.

if [[ $Track_Drive_Testing_Dates != "enable" ]]; then return; fi		# Return of we are not looking at the CSV file for test runs.
	for checking_drives in $smartdrives; do
		csv_drive_serial=$(smartctl -i /dev/${checking_drives} | grep -i "Serial Number" | rev | cut -d " " -f1 | rev)
		if test -e "$selftest_data_file"; then
			checking_drives_temp_long=$(cat "$selftest_data_file" | grep -iw "$csv_drive_serial" | cut -d ',' -f7)
			checking_drives_temp_short=$(cat "$selftest_data_file" | grep -iw "$csv_drive_serial" | cut -d ',' -f6)
		fi
		if [[ $checking_drives_temp_long == "" ]]; then checking_drives_temp_long=$expireDate_Month; fi		    # Set a null value (new file) to the maximum date, Monthly value.
		if [[ $checking_drives_temp_short == "" ]]; then checking_drives_temp_long=$expireDate_Month; fi		# Set a null value (new file) to the maximum date, Monthly value.
		if [[ $checking_drives_temp_long < $datestamp ]]; then
			if ! echo $selftest_drives_long | grep -qw $checking_drives; then		# If the checking_drives value is not in the log selftest list, then
				(( temp_Drive_Counter ++ ))											# Increment our counter
				if [[ $temp_Drive_Counter > $Maximum_Catchup_Drive_Count ]]; then	# If we exceed out allowable catchup value
					echo "Drive(s) "$checking_drives" are overdue for Long testing, however were not added for testing due to too many"
					echo "drives being tested this time.'"
					echo "Increase the maximum catchup drive count (currently = $Maximum_Catchup_Drive_Count) to test more drives at once."
					if ! echo $selftest_drives_long | grep -qw "$csv_drive_serial"; then
						overdue_drives_skipped=$overdue_drives_skipped" "$checking_drives
					fi
				else
					selftest_drives_long=$selftest_drives_long" "$checking_drives
				echo $checking_drives" - Overdue Drive(s) added to Long Tests"
				overdue_drives=$overdue_drives" "$checking_drives
				fi
			fi
		fi
	done

	}


check_scrub () {
    if [[ $Debug_Steps == "true" ]]; then echo "check_scrub" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    # Check if a SCRUB or RESILVER is in progress and the output is a list of drives, see end of function.
    # If greater than $SCRUB_Minutes_Remaining then we will not run a SMART Long test, we substitute it with a Short test.

# TEST CODE - CHANGE BACK TO 100 POOLS
    for i in {0..100}; do            # ARE WE REALLY GOING TO SEE 100 POOLS, well just in case?  THIS IS NOT THE ID NUMBER
        Function_Pool_Name=$(midclt call pool.query | jq -r '.['$i'].name')
        Function_Scan=$(midclt call pool.query | jq -r '.['$i'].scan.function')
        Function_Time_Left=$(midclt call pool.query | jq -r '.['$i'].scan.total_secs_left')
   
		if [[ $Function_Pool_Name == "null" ]]; then
			break										# End of the pools, we can exit this FOR loop.
		fi

        if [[ $Function_Time_Left == "null" ]]; then	# Nothing in progress
# Can we check what the values are immediately after starting a scrub, before the scrub knows how long remains?
            Function_Time_L=0
			continue
        else
            convert_to_decimal $Function_Time_Left		# Something is in progress.
            Function_Time_L=$Return_Value
        fi

        if [[ $Function_Pool_Name == "null" ]]; then break; fi        # Exit here if no more pools to process.
    
        if [[ $Function_Scan == "RESILVER" ]]; then
			RESILVER_Pools=$RESILVER_Pools" "$Function_Pool_Name				# If RESILVER_Pools != "" then a pool name is listed.
			RESILVER_List_of_Drives=$RESILVER_List_of_Drives" "$(midclt call pool.query | jq '.['$i']' | grep '"disk":' | cut -d ':' -f2 | tr -d '"' | tr -d ',')
			Function_Time_L_RESILVER=$Function_Time_L
			if [[ "$Function_Time_L_RESILVER" -ne 0 ]]; then         # We should have a number, lets convert it to hours.
                Function_Time_Left_RESILVER_Min=$((Function_Time_L_RESILVER / 60 ))   # Seconds to Minutes
                Function_Time_Left_RESILVER_Hour=$((Function_Time_Left_RESILVER_Min * 10 ))   # *10 due to rounding the hours, need to /10 after.
                Function_Time_Left_RESILVER_Whole0=$((Function_Time_Left_RESILVER_Hour / 60))
                Function_Time_Left_RESILVER_Whole1=$((Function_Time_Left_RESILVER_Whole0 / 10))		# Here is the /10.
                Function_Time_Left_RESILVER_Fraction=$((Function_Time_Left_RESILVER_Whole0 - $((Function_Time_Left_RESILVER_Whole1 * 10 ))))

                if [[ $RESILVER_Minutes_Remaining -gt 0 ]]; then        # Zero = No Long Test for the select drives in a pool.

					if [[ "$Function_Time_Left_RESILVER_Min" -gt "$RESILVER_Minutes_Remaining" ]]; then        # RESILVER remaining time is Too Long, no long tests.

                        echo "  Pool: "$Function_Pool_Name | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        if [[ "$Function_Time_Left_RESILVER_Min" -gt 59 ]]; then    # This prints the text but also formats the time from minutes to hours.fraction of hour.
                            # OVER 1 HOUR
                            echo "  "$Function_Scan" In Progress: ~"$Function_Time_Left_RESILVER_Whole1"."$Function_Time_Left_RESILVER_Fraction" hours remain. " | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        else
                            # LESS THAN 1 HOUR
                            echo $Function_Scan" In Progress: "$Function_Time_Left_RESILVER" minutes remain." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        fi
					fi
			
				fi
			fi
			
		fi
        if [[ $Function_Scan == "SCRUB" ]]; then
			Function_Time_L_SCRUB=$Function_Time_L
            if [[ "$Function_Time_L_SCRUB" -ne 0 ]]; then         # We should have a number, lets convert it to hours.
                Function_Time_Left_SCRUB_Min=$((Function_Time_L_SCRUB / 60 ))   # Sec to Min
                Function_Time_Left_SCRUB_Hour=$((Function_Time_Left_SCRUB_Min * 10 ))   # *10 due to rounding the hours, need to /10 after.
                Function_Time_Left_SCRUB_Whole0=$((Function_Time_Left_SCRUB_Hour / 60))
                Function_Time_Left_SCRUB_Whole1=$((Function_Time_Left_SCRUB_Whole0 / 10))		# Here is the /10.
                Function_Time_Left_SCRUB_Fraction=$((Function_Time_Left_SCRUB_Whole0 - $((Function_Time_Left_SCRUB_Whole1 * 10 ))))
                if [[ $SCRUB_Minutes_Remaining -gt 0 ]]; then        # Zero = No Long Test for the select drives in a pool.
					if [[ "$Function_Time_Left_SCRUB_Min" -gt "$SCRUB_Minutes_Remaining" ]]; then        # SCRUB remaining time is Too Long, no long tests.
                        echo "  Pool: "$Function_Pool_Name | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        if [[ "$Function_Time_Left_SCRUB_Min" -gt 59 ]]; then    # This prints the text but also formats the time from minutes to hours.fraction of hour.
                            # OVER 1 HOUR
                            echo "  "$Function_Scan" In Progress: ~"$Function_Time_Left_SCRUB_Whole1"."$Function_Time_Left_SCRUB_Fraction" hours remain. " | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        else
                            # LESS THAN 1 HOUR  -- THIS iS ONLY FOR TIME FORMATTING
                            echo $Function_Scan" In Progress: "$Function_Time_Left_SCRUB_Min" minutes remain." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        fi
                        echo "  The time remaining for the "$Function_Scan" exceeds "$SCRUB_Minutes_Remaining" minutes (SCRUB_Minutes_Remaining setting)."
						echo -n "  Running SMART SHORT test(s) vice pending LONG test(s), on drive(s):" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        if [[ $SCRUB_Pools == "" ]]; then
                            SCRUB_Pools=$Function_Pool_Name        # If first pool listed...
                            SCRUB_List_of_Drives=$(midclt call pool.query | jq '.['$i']' | grep '"disk":' | cut -d ':' -f2 | tr -d '"' | tr -d ',')
                        else        # IF SUBSEQUENT POOLS ARE TO BE ADDED.
							if $(echo $SCRUB_Pools | grep -qw $Function_Pool_Name); then
								:
							else
								SCRUB_Pools=$SCRUB_Pools" "$Function_Pool_Name
								SCRUB_List_of_Drives=$SCRUB_List_of_Drives" "$(midclt call pool.query | jq '.['$i']' | grep '"disk":' | cut -d ':' -f2 | tr -d '"' | tr -d ',')
							fi
                        fi
							echo " "$SCRUB_List_of_Drives
                    else
#********

if [[ $SCRUB_Pools == "" ]]; then
                            SCRUB_Pools=$Function_Pool_Name        # If first pool listed...
                            SCRUB_List_of_Drives=$(midclt call pool.query | jq '.['$i']' | grep '"disk":' | cut -d ':' -f2 | tr -d '"' | tr -d ',')
                        else        # IF SUBSEQUENT POOLS ARE TO BE ADDED.
							if $(echo $SCRUB_Pools | grep -qw $Function_Pool_Name); then
								:
							else
								SCRUB_Pools=$SCRUB_Pools" "$Function_Pool_Name
								SCRUB_List_of_Drives=$SCRUB_List_of_Drives" "$(midclt call pool.query | jq '.['$i']' | grep '"disk":' | cut -d ':' -f2 | tr -d '"' | tr -d ',')
							fi
                        fi
						
						
						# LESS THAN MAX TIME - WE CAN RUN A LONG TEST
                        echo "  The "$Function_Scan" on pool '"$Function_Pool_Name"' remaining time is ~"$Function_Time_Left_SCRUB_Whole1"."$Function_Time_Left_SCRUB_Fraction" hours, running SMART Long and Short tests as planned." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                else
                    # SCRUB/RESILVER IN PROGRESS - NO SMART TESTING AT ALL
                    echo "  "$Function_Scan" In Progress: ~"$Function_Time_Left_SCRUB_Whole1"."$Function_Time_Left_SCRUB_Fraction" hours remain for pool: "$Function_Pool_Name"." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    echo "  SMART testing disabled for drives in pool(s) '"$Function_Pool_Name"' during "$Function_Scan"." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
            fi
        fi
    done

# WE ARE PASSING THE DRIVES ALONG AS THE VALUES TO NOT PERFORM A SMART LONG TEST AND USE SHORT (SCRUB) OR NO TESTS AT ALL (RESILVER)
RESILVER_Pools=$(echo $RESILVER_Pools | sed -e 's/^[[:space:]]*//')			# Trim the leading white space.
SCRUB_Pools=$(echo $SCRUB_Pools | sed -e 's/^[[:space:]]*//')				# Trim the leading white space.
RESILVER_List_of_Drives=$(echo $RESILVER_List_of_Drives | sed -e 's/^[[:space:]]*//')
SCRUB_List_of_Drives=$(echo $SCRUB_List_of_Drives | sed -e 's/^[[:space:]]*//')
RESILVER_List_of_Drives=$(echo "$RESILVER_List_of_Drives" | xargs |  sed 's/nvd/nvme/g' | sed 's/n1//g')
#SCRUB_List_of_Drives=$(echo "$SCRUB_List_of_Drives" | xargs |  sed 's/nvd/nvme/g' )
SCRUB_List_of_Drives=$(echo "$SCRUB_List_of_Drives" | xargs | sed 's/nvd/nvme/g' | sed 's/n1//g')
    }

remove_duplicate_tests () {
	if [[ $Debug_Steps == "true" ]]; then echo "remove_duplicate_tests" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# THIS WILL COMPARE BOTH SHORT AND LONG TESTS AND REMOVE DUPLICATE SHORT TESTS FROM THE TESTING LIST.
# NEXT TIME LETS FIGURE OUT THE LONG TESTS FIRST, THEN FIGURE OUT THE SHORT TESTS AND IF ONE IS LISTED IN THE LONG TESTS LIST, REMOVE IT.

# Global Variables: selftest_drives_short, selftest_drives_long
# Local Variables: s_drives, short_modified_drives

    (echo "            "$start_time_display":  START remove_duplicate_tests"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
# First lets punt to check the CSV file to see if we should be adding any extra drives into the mix.
	check_expired_drive_tests
    for s_drives in $selftest_drives_short ; do                     # Loop through all the Long drives to test
		if $(echo $RESILVER_List_of_Drives | grep -qw "$s_drives"); then continue; fi		# Skip RESILVERing Drives.
		test=0
        # Lets remove any matches to the short drive list.
		for l_drives in $selftest_drives_long ; do
			if [[ "$l_drives" == "$s_drives" ]]; then test=1; fi
		done
		if [[ $test == 1 ]]; then     # This drive should be removed from teh SHORT test list.
			if [[ $reduced_drives_display == "" ]]; then            # We are creating a list of drives being removed for display only purposes.
				reduced_drives_display=$s_drives                            # We are formatting the display to look nice in this IF statement.
			else
				reduced_drives_display=$reduced_drives_display" "$s_drives
			fi

		else                                                        # ELSE we create a new list of Short drives to test, if any.
			if [[ $short_modified_drives == "" ]]; then short_modified_drives=$s_drives; else short_modified_drives=$short_modified_drives" "$s_drives; fi
		fi
    done

    selftest_drives_short=$short_modified_drives
    selftest_drives=$selftest_drives_short
	remove_scrub_resilver_drives			# Lets remove any drives in pools affected by a SCRUB or RESILVER operation.

    if [[ $s_drives != "" ]] && [[ $SCRUB_List_of_Drives == "" ]]; then
        if [[ $(wc -c <<< "$reduced_drives_display" | xargs) -gt 2 ]]; then
            if [[ $Silent != "enable" ]]; then
                (echo '    Drive(s): "'$reduced_drives_display'" is/are scheduled for LONG testing, removed duplicate Short test(s).'
                echo " " ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
        fi
    fi

    if ! [[ $selftest_drives_short == "" ]]; then
        if [[ $Silent != "enable" ]]; then
            if [[ $SCRUB_List_of_Drives != "" ]]; then
                echo "RUNNING SHORT TEST: "$selftest_drives_short", drive(s) moved from LONG test to SHORT test." | tee -a /tmp/drive_selftest/drive_test_temp.txt
            else
                echo "RUNNING SHORT TEST: "$selftest_drives_short | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
        fi

		selftest_drives=$selftest_drives_short
        run_smart_test Short
        Short_Drives_Testing=$selftest_drives_short
    else
        if [[ $Silent != "enable" ]]; then
            (echo " "
            echo "NO SHORT TESTS TO RUN"$selftest_drives_short ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
    fi
	
    selftest_drives=$selftest_drives_long
	if [[ $Silent != "enable" ]]; then
		echo " "
	fi
    if [[ $(wc -c <<< "$selftest_drives_long" | xargs) -gt 2 ]]; then
        if [[ $Silent != "enable" ]]; then
            echo "RUNNING LONG TEST: $selftest_drives_long" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        echo "            RUNNING LONG TEST: $selftest_drives_long" >> /tmp/drive_selftest/drive_test_timer_temp.txt
		selftest_drives=$selftest_drives_long
        run_smart_test Long
        Long_Drives_Testing=$selftest_drives_long
    else
        if [[ $Silent != "enable" ]]; then
            echo "NO LONG TESTS TO RUN" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        (echo "            NO LONG TESTS TO RUN"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    fi

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT remove_duplicate_tests"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
    if [[ $end_tenths != "" ]]; then
        echo ".$end_tenths seconds elapsed."
    else
        echo " seconds elapsed."
    fi
    echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }


# CALLED FROM ONE LOCATION
run_smart_test () {
    if [[ $Debug_Steps == "true" ]]; then echo "run_smart_test" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# This will check if a SMART test is currently running and if yes, display the progress.
# If no SMART test is running then attempt to execute the test.
#
# Required variables: $1=Test Type (Short/Long)
# Global Variables: Drive_Disk_Query, smart_ver, selftest_drives, Demo, Time_Delay_Between_Drives, Debug, drive, smartctlscan
#
# Local Variables: drive, API_BUS, smart_test_ok, test_it, driveConnectionType, drive_connection_types, api_s
#
# Calls nvm_selftest

    (echo "                "$start_time_display":  START run_smart_test"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    test_running=0
    if ! test -e "/tmp/drive_selftest/smartctl_scan_results.txt"; then
        smartctl --scan > /tmp/drive_selftest/smartctl_scan_results.txt
    fi
    for drive in $selftest_drives; do
        api_s=0
        in_test=0
        until [[ "$(echo $Drive_Disk_Query | jq -r '.['$api_s'].name')" == "null" ]] || [[ "$(echo $Drive_Disk_Query | jq -r '.['$api_s'].name')" == *"$drive"* ]]; do (( api_s ++)); done
        API_BUS=$(echo $Drive_Disk_Query | jq -r '.['$api_s'].subsystem')
        API_SERIAL=$(echo $Drive_Disk_Query | jq -r '.['$api_s'].serial')
        drive_connection_types="none$(echo "$smartctlscan" | grep -i "$drive" | awk '{printf ","; printf $3}'),$SMARTCTL_Interface_Options"
        driveConnectionType=$(echo "$smartctlscan" | grep -i "$drive" | awk '{printf $3}')
        if [[ $Debug == "true" ]]; then echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
        if [[ $Debug == "true" ]]; then echo "    Debug - 'Drive ID=$drive', 'Drive S/N=${API_SERIAL}', 'SMARTCTL Interface Type=$driveConnectionType', 'API BUS=$API_BUS'" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi

        if [[ $programver3 -lt 24 ]] && [[ $programver4 -lt 3 ]] && [[ $drive == *"nvm"* ]]; then     # If less than TrueNAS 24 and nvme drive, use low level nvme commands.
            nvm_selftest $1 $drive
            No_Tests="false"
        else                                        # If smartmontool is 7.4 or greater, Time to try and run a SMART test using smartmontools for nvme.
            IFS_RESTORE=$IFS
            IFS=","
            for dr in $drive_connection_types; do
                if [[ $dr == "none" ]]; then
                    driveConnectionType=$dr
                    # No interface parameter passed
                    if [[ $1 == "Short" ]]; then
                        smart_test_ok="$(smartctl -t short /dev/$drive)"
                    else
                        smart_test_ok="$(smartctl -t long /dev/$drive)"
                    fi
                    smartresult=$?
                    if [[ $smartresult -eq 0 ]]; then   # Exit code of 0 is good, command accepted.
						update_csv_file $1		# Update the CSV file with todays date and the next due date.
                        if [[ $Silent != "enable" ]]; then
                            echo "SMART command for drive:"$drive" was received okay, return exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        fi
                        in_test=1
                        break 1   # Return to the FOR loop
                    elif [[ $smartresult -eq 4 ]]; then        # Exit code of 4 could mean the command was accepted but the drive was busy or the command was not accepted.
                        # Check to see if test is running before assuming exit code 4 is a bust.
                        if echo $smart_test_ok | grep -i -e "remaining" -e "completed" > /dev/null 2<&1; then
                            in_test=1
                            break 1        # Jump out of the FOR loop
                        fi
                    else
                        echo "SMART command for drive:"$drive" was not good, returned exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        echo "Lets try a different interface type..." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                else        # It looks like we need an interface modifier
                    driveConnectionType=$dr
                    if [[ $1 == "Short" ]]; then
                        smart_test_ok="$(smartctl -d "${driveConnectionType}" -t short /dev/$drive)"
                    else
                        smart_test_ok="$(smartctl -d "${driveConnectionType}" -t long /dev/$drive)"
                    fi
                    smartresult=$?
                        
                    if [[ $smartresult -eq 0 ]]; then   # Exit code of 0 is good, command accepted.
                        update_csv_file	$1	# Update the CSV file with todays date and the next due date.
						if [[ $Silent != "enable" ]]; then
                            echo "SMART command -d "$driveConnectionType" for drive:"$drive" was received okay, return exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        fi
                        in_test=1
                        break 1   # Return to the FOR loop
                    elif [[ $smartresult -eq 4 ]]; then        # Exit code of 4 could mean the command was accepted but the drive was busy or the command was not accepted.
                        # If the drive is in-test, consider the command received. 
                        # Check to see if test is running before assuming exit code 4 is a bust.
                        if echo $smart_test_ok | grep -i -e "remaining" -e "completed" > /dev/null 2<&1; then
                            in_test=1
                            break 1        # Jump out of the FOR loop
                        fi                        
                    else
                        if [[ $Silent != "enable" ]]; then
                            echo "SMART command -d "$driveConnectionType" for drive:"$drive" was not good, returned exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt
                            echo "Lets try a different interface type..." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        fi
                    fi
                fi
            done
            
            if [[ $in_test == 0 ]]; then echo "SMART commands exhausted for drive:"$drive", returned exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
            IFS=$IFS_RESTORE
 
            if echo $smart_test_ok | grep -i "has begun" > /dev/null 2<&1; then
                if [[ $Silent != "enable" ]]; then
                    echo "    Drive: $drive in $1 Test" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
                if [[ $timer_flag -eq 1 ]]; then echo "                    Drive: $drive in $1 Test"; fi >> /tmp/drive_selftest/drive_test_timer_temp.txt
                test_running=1    # Looks like the testing is in progress.
                No_Tests="false"
            else
                if [[ $timer_flag -eq 1 ]]; then echo "                    An error occurred for Drive: $drive in $1 Test."; fi >> /tmp/drive_selftest/drive_test_timer_temp.txt
                if echo $smart_test_ok | grep -i -e "remaining" -e "completed" > /dev/null 2<&1; then
                (   echo -n "    Drive $drive is still running a test: "
                    echo $smart_test_ok | grep -o -e '(..% remaining)' -e '(..% completed)') | tee -a /tmp/drive_selftest/drive_test_temp.txt
                else
                (   echo " - Drive did not accept the smartctl command."
                    echo " "
                    echo "    SMARTCTL Return Value = "$smartresult
                    echo " "
                    echo "    Here is the return message:"
                    echo $smart_test_ok
                    echo " ") | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
            fi
            test_it=1
        fi

        if [[ $Demo != "true" ]]; then
            sleep $Time_Delay_Between_Drives        # Wait DELAY seconds before running another drive.
        fi
    done

    if [[ $test_it -eq 1 ]]; then
        if [[ $1 == "Long" ]]; then
            if [[ $selftest_drives != "" ]]; then
                if [[ $Silent != "enable" ]]; then
                    (echo " "
                    echo "ALL TESTS COMPLETED OR RUNNING IN BACKGROUND") | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
            fi
        fi
    fi

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "                "$end_time_display":  EXIT run_smart_test"
    echo -n "                Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }


# CALLED FROM TWO LOCATIONS
robot_routine () {
    if [[ $Debug_Steps == "true" ]]; then echo "robot_routine $1" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    # THIS WILL DIRECT COLLECTING THE DRIVE DATA BASED ON $1 (Short|Long) value.  And it will determine the drives to test each day.

    # Uses smartmontools to run the tests.

    # Global Variables: $1="Short/Long", Demo, smartdrives_sorted, RESILVER_Pools, SCRUB_Pools, RESILVER_List_of_Drives, SCRUB_List_of_Drives
    # Short_Test_Mode, Short_SMART_Testing_Order, Short_Drives_to_Test_Per_Day, Short_Drives_Test_Period, Short_Drives_Tested_Days_of_the_Week, Short_Time_Delay_Between_Drives
    # Long_Test_Mode, Long_SMART_Testing_Order, Long_Drives_to_Test_Per_Day, Long_Drives_Test_Period, Long_Drives_Tested_Days_of_the_Week, Long_Time_Delay_Between_Drives    

    # Local Variables: counter_simulated_drives, day_of_week, DOW_days, drives_to_test

    (echo "        "$start_time_display":  START robot_routine '$1'"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    api_drive_serial_number=""
    if [[ $Demo == "true" ]]; then
        counter_simulated_drives=0
        smartdrives_sorted=""
        if [[ $simulated_drives -gt 0 ]]; then
            while [ $counter_simulated_drives -lt $simulated_drives ]; do
                smartdrives_sorted=$smartdrives_sorted" ada"$counter_simulated_drives
                (( counter_simulated_drives ++ ))
            done
            smartdrives=$smartdrives_sorted
        fi
    fi

    if [[ $1 == "" ]]; then echo "No SMART Test is defined, Error."; break ; fi        # Exit if no test is selected.

    if [[ $1 == "Short" ]]; then                                # Use Short variables
        Test_Mode=$Short_Test_Mode
        SMART_Testing_Order=$Short_SMART_Testing_Order
        Drives_to_Test_Per_Day=$Short_Drives_to_Test_Per_Day
        Drives_Test_Period=$Short_Drives_Test_Period
        Drives_Tested_Days_of_the_Week=$Short_Drives_Tested_Days_of_the_Week
        Time_Delay_Between_Drives=$Short_Time_Delay_Between_Drives
    else                                                        # Else use Long variables
        Test_Mode=$Long_Test_Mode
        SMART_Testing_Order=$Long_SMART_Testing_Order
        Drives_to_Test_Per_Day=$Long_Drives_to_Test_Per_Day
        Drives_Test_Period=$Long_Drives_Test_Period
        Drives_Tested_Days_of_the_Week=$Long_Drives_Tested_Days_of_the_Week
        Time_Delay_Between_Drives=$Long_Time_Delay_Between_Drives
    fi

    case $Test_Mode in                                          # Lets give us a title for the report.
        1)    Test_Mode_Title="${1} SMART Test on ${Drives_to_Test_Per_Day} Drive(s) Per Day"    ;;
        2)    Test_Mode_Title="${1} SMART Test All Drives"                ;;
        3)    Test_Mode_Title="No SMART Testing Selected"                ;;
    esac
    DOW_days=""
    IFS=","
    for day_of_week_test in $Drives_Tested_Days_of_the_Week; do
        case $day_of_week_test in                               # Lets give us days of the week.
            1)    day_of_week="Mon"    ;;
            2)    day_of_week="Tue"    ;;
            3)    day_of_week="Wed"    ;;
            4)    day_of_week="Thu"    ;;
            5)    day_of_week="Fri"    ;;
            6)    day_of_week="Sat"    ;;
            7)    day_of_week="Sun"    ;;
        esac
        if [[ $DOW_days == "" ]]; then                          # The first match by itself.
            DOW_days=$day_of_week
        else
            DOW_days=$DOW_days", "$day_of_week                  # As successive matches joined together by a comma.
        fi
    done

    case $DOW in                                                # Lets give us days of the week.
        1)    day_of_week="Mon"    ;;
        2)    day_of_week="Tue"    ;;
        3)    day_of_week="Wed"    ;;
        4)    day_of_week="Thu"    ;;
        5)    day_of_week="Fri"    ;;
        6)    day_of_week="Sat"    ;;
        7)    day_of_week="Sun"    ;;
    esac

    IFS=$IFS_RESTORE
    if [[ $Silent != "enable" ]]; then
        echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
    if [[ $Demo == "true" ]] && [[ $1 == "Short" ]]; then
        echo "SHORT TEST SIMULATION" | tee -a /tmp/drive_selftest/drive_test_temp.txt
    elif [[ $Demo == "true" ]] && [[ $1 == "Long" ]]; then
        echo "LONG TEST SIMULATION" | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
    if [[ $Silent != "enable" ]]; then
        echo -n '  '$1' Test Mode:('$Test_Mode') "'$Test_Mode_Title'"' | tee -a /tmp/drive_selftest/drive_test_temp.txt
    
        if [[ $Test_Mode -eq 1 ]]; then
            echo ', Running '$Drives_Test_Period' Option, Sorting by: '$SMART_Testing_Order | tee -a /tmp/drive_selftest/drive_test_temp.txt
        elif [[ $Test_Mode -eq 2 ]]; then
            echo ', Running '$Drives_Test_Period' Option, No Sorting' | tee -a /tmp/drive_selftest/drive_test_temp.txt
        else    
            echo ", $1 Testing will not be executed." | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
    fi

    sort_list=$smartdrives                                      # smartdrives is a full list of all smart drives, Lets sort the drive IDs.
    sort_data
    smartdrives_sorted=$sort_list                               # These are all the drives and sorted.
    Demo_Track=1
    Drive_Count=$(wc -w <<< "$smartdrives_sorted" | xargs)

    if [[ $Test_Mode -eq 1 ]]; then        # Variable Testing
        if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then     # Does DOW match ?, If yes, keep going.
            if [[ $SMART_Testing_Order == "Serial" ]]; then     # Lets sort by Serial number now.
                sort_list=${drives_serial[@]}
                api_drive_serial_number=$sort_list              # The Serial/DriveID are now sorted.
                sort_serial_number                              # Input - api_drive_serial_number, Output - smartdrives_sorted
            fi
			if [[ $Silent != "enable" ]]; then
				echo " "
			fi
            Drive_Count=$(wc -w <<< "$smartdrives_sorted" | xargs)  # Total number of drives.
            if [[ $Silent != "enable" ]]; then
                (echo "    Authorized Test Days: "$DOW_days
                echo "    Total Drives Recognized: "$Drive_Count) | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
        fi        
    fi
    if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then
        drives_to_test=$smartdrives_sorted
    else
        drives_to_test=""
    fi
    
    if [[ $Test_Mode -eq 2 ]]; then        # All Testing
        Demo_loop=0
        loop_counter=0
        Drive_List=""
        while [ $Demo_loop -lt $Drive_Count ]; do
            Drive_List_Temp=$(echo $smartdrives_sorted | cut -d ' ' -f ${Demo_Track} | xargs)
            if [[ $Drive_List != *"${Drive_List_Temp}"* ]]; then
                if [[ $Demo_loop -eq 0 ]]; then
                    Drive_List=$Drive_List_Temp                 # First Pass
                else
                    if [[ $loop_counter -eq $Drive_List_Length ]]; then
                        Drive_List=$Drive_List",\n "$Drive_List_Temp
                        loop_counter=0
                    else
                        (( loop_counter ++ ))
                        Drive_List=$Drive_List", "$Drive_List_Temp     # Successive Passes
                    fi
                fi
            fi
            if [[ $Demo_Track -eq $Drive_Count ]]; then break; fi
            (( Demo_Track ++ ))
            (( Demo_loop ++ ))
        done
        if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then
            drives_to_test=$smartdrives_sorted
        else
            drives_to_test=""
        fi
    fi    
   
    if [[ $Test_Mode -eq 3 ]]; then        # No Testing
        drives_to_test=""
    fi
    
    drives_tested_demo=""            # Needed to clear this variable for the second pass.  CHECK TO INITIALIZE ALL USED VARIABLES AT THE BEGINNING OF THE SCRIPT/FUNCTION CALL
   
    if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then                        # Is today a valid test day?
        if [[ $Test_Mode -eq 1 ]]; then

            Days_Authorized_in_Week=$(echo "$Drives_Tested_Days_of_the_Week" | tr ',' ' ' | wc -w | xargs )     # This holds numbers of the days 1,2,3...
            Days_Authorized_in_Month=$(( 4 * Days_Authorized_in_Week ))  #  4 weeks * 2 days a week = 8 days to test.
 
            # shellcheck disable=SC1073
            # shellcheck disable=SC1072
            # shellcheck disable=SC1009
            if [[ $(( Drives_to_Test_Per_Day * 10 )) -lt $((( Drive_Count * 10 ) / Days_Authorized_in_${Drives_Test_Period} )) ]]; then
                    if [[ $Silent != "enable" ]]; then
                    (   echo " "
                        echo "      You have $Drive_Count drives and "$(( Days_Authorized_in_${Drives_Test_Period} ))" authorized days to test."
                        echo "      Making adjustments to ensure all drives are tested within the given period of time, please wait...."
                    ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi

                Drives_to_Test_Per_Day=$((( Drive_Count * 10 ) / Days_Authorized_in_${Drives_Test_Period} ))   #  28/6 = 5.xxx = 6
                if [[ ${Drives_to_Test_Per_Day: -1} != "0" ]]; then
                    Drives_to_Test_Per_Day=$(((Drive_Count / Days_Authorized_in_${Drives_Test_Period}) + 1))
                else
                    Drives_to_Test_Per_Day=$((Drive_Count / Days_Authorized_in_${Drives_Test_Period}))
                fi
                    if [[ $Silent != "enable" ]]; then
                    (   echo "      Recalculation Complete, the new value is $Drives_to_Test_Per_Day drive(s) spread across"
                        echo "      the "$(( Days_Authorized_in_${Drives_Test_Period} ))" authorized day(s)."
                        echo " "
                    ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
            fi

            ### Setup variables:
            First_DOM=1                  # Set First_DOM to the first day of the month.
            Temp_drives_tested=0         # Initial value, meaning no drives to test.
            DOW_temp=$DOW                # Start with current DOW
            valid_today=0
            test_it=0                    # If set to other than 0, testing is needed.
            drives_already_tested=0      # Total number of drives previously scheduled tested.  The next number is the drive to be tested if test_it != 0.

            if [[ $Drives_Test_Period == "Month" ]]; then            # THIS IS FOR MONTHLY
                list_monthly_output
            else                # THIS IS FOR THE WEEKLY
               list_weekly_output       # Call routine
            fi
        fi
    fi

# TESTING
    if [[ $1 == "Short" ]]; then selftest_drives_short=$drives_to_test; fi
    if [[ $selftest_drives_short == "all" ]]; then
        selftest_drives_short=$smartdrives
        if [[ $Silent != "enable" ]]; then
            echo "ALL DRIVES - SHORT" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
    fi
    if [[ $1 == "Long" ]]; then selftest_drives_long=$drives_to_test; fi
    if [[ $selftest_drives_long == "all" ]]; then
        selftest_drives_long=$smartdrives
        if [[ $Silent != "enable" ]]; then
            echo "ALL DRIVES - LONG" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
    fi
    # Call SMART Test routine.  Pass $1=Short/Long
    if [[ $Demo != "true" ]] && [[ $Ready_to_Test == "true" ]]; then    # Ready_to_Test means the Short and Long drive schedules are complete and actual testing may start.

# We need to not start the smart testing until after we process both Short and Long drive lists to test.
        if [[ $Short_Drives_Tested_Days_of_the_Week == *"$DOW"*    ]] || [[ $Long_Drives_Tested_Days_of_the_Week == *"$DOW"*    ]]; then        # If Long tests are not authorized for this day, do not run remove_duplicate_tests.
			check_expired_drive_tests
            remove_duplicate_tests
        fi
    else
        # We have not processed the Long tests yet.
        Ready_to_Test="true"        # This is good for the second pass now.
    fi

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "        "$end_time_display":  EXIT robot_routine"
    echo -n "        Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }
	
remove_scrub_resilver_drives () {
    if [[ $Debug_Steps == "true" ]]; then echo "remove_scrub_resilver_drives" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# This will remove or move drives based on RESILVER or SCRUB status.
# Inputs: SCRUB_List_of_Drives, RESILVER_List_of_Drives, selftest_drives_long, selftest_drives_short
# Outputs: Modified selftest_drives_long, selftest_drives_short

# Remove all drives in the RESILVER list
	if [[ $RESILVER_List_of_Drives != "" ]]; then
		# First the Long Tests
		for word in $RESILVER_List_of_Drives; do
			# First the Long tests are removed
			selftest_drives_long="${selftest_drives_long// $word/}"
			selftest_drives_long="${selftest_drives_long//$word /}"
			selftest_drives_long="${selftest_drives_long//$word/}"
		done
		for word in $RESILVER_List_of_Drives; do
			# Second the Short tests are removed
			selftest_drives_short="${selftest_drives_short// $word/}"
			selftest_drives_short="${selftest_drives_short//$word /}"
			selftest_drives_short="${selftest_drives_short//$word/}"
		done
	fi

# Move any matching LONG tests to SCRUB list to SHORT tests.
	if [[ $SCRUB_List_of_Drives != "" ]]; then
		for word in $SCRUB_List_of_Drives; do		#Remove all drives from the Long test
			# Remove from Long List
			selftest_drives_long="${selftest_drives_long// $word/}"
			selftest_drives_long="${selftest_drives_long//$word /}"
			selftest_drives_long="${selftest_drives_long//$word/}"
				
			# Add to Short List
			if ! $(echo $selftest_drives_short | grep -qw $word); then
				selftest_drives_short=${selftest_drives_short}" "${word}
			fi
		done
	fi

	# Cleanup variables
	selftest_drives_short=$(echo "$selftest_drives_short" | tr -s ' ' | sed 's/^ *//;s/ *$//')
	selftest_drives_long=$(echo "$selftest_drives_long" | tr -s ' ' | sed 's/^ *//;s/ *$//')

	}

# CALLED FROM ONE LOCATION
list_monthly_output () {
    if [[ $Debug_Steps == "true" ]]; then echo "list_monthly_output" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi

# This will generate the MONTHLY screen output for the drives tested.
#
# Global Variables: Demo, DOW, softver, Drive_List_Length, Drive_Count, drives_to_test
# Local Variables: drives_to_list, total_drives_tested_per_day, sum_drives_test, DOW_temp, day_of_month, loop_counter, array_location, valid_today, first_DOW, test_it
# Local Variables: today_weekday, debian_day_of_month, pretext, gap_characters, pretext_length, drive_list_length_counter, drives_to_list_x, drives_already_tested
#

    (echo "            "$start_time_display":  START list_monthly_output") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    DOW_temp=$DOW                                    # Use a temporary variable to add/subtract with.
    drives_to_list=""                                # Listing a grouping of drive ids.
    total_drives_tested_per_day=0                    # Might be able to use a fixed number vice a variable.
    sum_drives_test=0                                # Total of drives tested?
    day_of_month=1                                   # Set the first of the month.
    loop_counter=0                                   # Just a counter.
    array_location=1                                 # Presetting the variable 
    drives_tested_demo=""
    echo " "
    while [ $(( 10#$day_of_month )) -le 28 ]; do                                  # 1. Start a loop from 1 to 28 to represent the 28 days of any given month.
        valid_today=0                                                   # Reset for current day check.
        if [[ $softver != "Linux" ]]; then                              # FreeBSD or Debian?
            first_DOW=$(date -v${day_of_month#0}d +%u)                    # What is the day of the week for the set date?
            today_weekday=$(date -v${day_of_month#0}d +%A)                # What is the 
        else
            debian_day_of_month="$(printf "%02d" ${day_of_month#0})"
            first_DOW=$(date -d "$(date +%Y%m${debian_day_of_month})" +%u)
            today_weekday=$(date -d "$(date +%Y%m${debian_day_of_month})" +%A)
        fi
        pretext=$today_weekday" "$(printf "%02d" ${day_of_month#0})" "$Full_Month_Name"\nDrive IDs: "
        gap_characters="----------"
        if [[ $Drives_Tested_Days_of_the_Week == *"$first_DOW"* ]]; then                                # 2. Check if today is an authorized day.
            valid_today=1                                                                               #    Mark this a authorized.
            total_drives_tested_per_day=$(( total_drives_tested_per_day + Drives_to_Test_Per_Day ))                            
            sum_drives_test=0
            loop_counter=0                         # Set the start count of the loop to define how many drives per line
            drive_list_length_counter=0            # Set the first or successive lines count
            drives_to_list=""
            previous_drives_tested_count=0         # Keep a running count of all the drives tested.
                        
            while [ $sum_drives_test -lt $Drives_to_Test_Per_Day ]; do
                drives_to_list_x=$(echo $smartdrives_sorted | cut -d' ' -f${array_location} | xargs)            # Grab next array variable (drive ID)
                if [[ $drives_to_list_x == "" ]]; then break; fi                                                # Jump out of while loop if no more drives to list
                    if [[ $drive_list_length_counter -lt $Drive_List_Length ]]; then                            # grab the first ten
                    if [[ $drives_to_list == "" ]]; then
                        drives_to_list=$drives_to_list_x
                    else
                        (( drive_list_length_counter ++ ))                            # Increment the loop counter
                        if [[ $Demo == "true" ]]; then                                # For display only
                            drives_to_list=$drives_to_list", "$drives_to_list_x
                        else
                            drives_to_list=$drives_to_list" "$drives_to_list_x
                        fi
                    fi
                else
                    drive_list_length_counter=0                                                  # Reset loop counter2 to 0 that count how many drives are in a line
                    drives_to_list=$drives_to_list"\n"$gap_characters" "$drives_to_list_x        # Now we add a new line, the gap spacing, and new drive ID
                fi
            (( sum_drives_test ++ ))
            (( array_location ++ ))
            (( previous_drives_tested_count ++ ))
            done
            if [[ $Demo == "true" ]]; then        # WHY IS THIS ONLY FOR DEMO? IT WILL LIST ALL THE DAYS OF THE DRIVES IF DISABLED.  LEAVE IN PLACE !
                if [[ $drives_to_list == "" ]]; then drives_to_list=" Nothing To Test This Day"; fi
                echo -e $pretext$drives_to_list | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi

            if [[ $(( 10#$day_of_month )) -lt $(( 10#$today_day )) ]]; then
                drives_tested_demo=$drives_tested_demo" "$drives_to_list
            fi

            if [[ $Demo != "true" ]] && [[ $(( 10#$day_of_month )) -eq $(( 10#$today_day )) ]]; then break; fi        # THIS SHOULD EXIT WHEN WE HIT TODAY
        fi
        (( day_of_month ++ ))
    done

    if [[ $Demo == "true" ]]; then return; fi
    if [[ ! $drives_already_tested -ge $Drive_Count ]]; then                                      # We match and have to test
        test_it=1
        if [[ $Silent != "enable" ]]; then
            echo "    Drive(s) previously scheduled to be tested: "$drives_tested_demo | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo -e "    "$(wc -w <<< "$drives_to_list" | xargs)" Drive(s) testing today: "$drives_to_list | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        drives_to_test=$drives_to_list
    else
        if [[ $Silent != "enable" ]]; then
            if [[ $valid_today -eq 1 ]]; then echo "    All Scheduled Drives Complete" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
        fi
    fi
    echo " "

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT list_monthly_output"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }

# CALLED FROM ONE LOCATION
list_weekly_output () {
    if [[ $Debug_Steps == "true" ]]; then echo "list_weekly_output" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# This will generate the WEEKLY screen output for the drives tested.
#
# Global Variables: Demo, Drive_Count, Drives_Tested_Days_of_the_Week, smartdrives_sorted, 
# Local Variables: First_DOM, drives_already_tested, valid_today, drives_already_tested, test_it, drives, DOW_temp, drives_to_test, drives_tested_demo?
#

    (echo "            "$start_time_display":  START list_weekly_output") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    ### Setup variables:
    First_DOM=1        # Set First_DOM to the first day of the month.
    Temp_drives_tested=0    # Initial value, meaning no drives to test.
    DOW_temp=$DOW    # Start with current DOW
    valid_today=0
    test_it=0                # If set to other than 0, testing is needed.
    drives_already_tested=0            # Total number of drives previously scheduled tested.  The next number is the drive to be tested if test_it != 0.
    if [[ $Debug == "true" ]]; then
        echo "Debug - Drive Names="$Drives_name | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drive Count="$Drive_Count | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drives Already Tested="$drives_already_tested | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drives To Test="$drives_to_test | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi

    while [ $First_DOM -le 7 ]; do
        valid_today=0
        if [[ $First_DOM -lt $DOW ]]; then                        # Is it less than today, then allow evaluation for previous matches.
            if [[  $Drives_Tested_Days_of_the_Week == *"$First_DOM"* ]]; then
                valid_today=1
                if [[ $drives_already_tested -lt $Drive_Count ]]; then
                    drives_already_tested=$(( drives_already_tested + Drives_to_Test_Per_Day ))                      # Increment sum_drives_test+per_day
                    if [[ $drives_already_tested -gt $Drive_Count ]]; then drives_already_tested=$Drive_Count; fi    # This adjusts to the remainder at the end of the drive list
                fi
            fi
        fi
        First_DOM=$(( First_DOM + 1 ))    # Increment to next day of the week
    done
    First_DOM=$(( First_DOM - 1 ))    # Decrement day of week evaluation to offset above addition before exit.
    if [[  $Drives_Tested_Days_of_the_Week == *"$First_DOM"* ]]; then valid_today=1; fi

    if [[ ! $drives_already_tested -ge $Drive_Count ]]; then                        # We match and have to test
        test_it=1
    else
        if [[ $Silent != "enable" ]]; then
            if [[ $valid_today -eq 1 ]]; then echo "All Scheduled Drives Complete" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
        fi
    fi 
    Temp_drives_tested=$drives_already_tested
    drives_to_test=""
    drives_tested_demo=""

    if [[ $test_it -eq 1 ]]; then
        DOW_temp=0
        if [[ $Temp_drives_tested -lt $Drive_Count ]]; then                         # $Temp_drives_tested=$x1  Temp_drives_tested=Drive Count
            for drives in $smartdrives_sorted; do                                   # Lets peel off the tested drives.
                # Loop $DOW_temp times
                DOW_temp=$(( DOW_temp + 1 ))                                        # Add 1 to the drive count: represents ?
                if [[ $DOW_temp -gt $Temp_drives_tested ]] && [[ $DOW_temp -lt $(( Temp_drives_tested + Drives_to_Test_Per_Day + 1 )) ]]; then   # DOW_temp -gt Drive Count && DOW_temp -lt (( Drive Count + Drives Per Day + 1))
                    drives_to_test=$drives_to_test" "$drives
                else
                    if ! [[ $DOW_temp -gt $Temp_drives_tested ]]; then
                        if [[ $drives_tested_demo == "" ]]; then
                            drives_tested_demo=$drives
                        else
                            drives_tested_demo=$drives_tested_demo", "$drives
                        fi
                    fi
                fi
            done
        fi
    fi

    if [[ $drives_to_test != "" ]]; then
        drives_to_test=$(echo "$drives_to_test" | xargs)
    fi

    if [[ $Test_Mode -eq 2 ]]; then
        if [[ $Silent != "enable" ]]; then
            (echo "All $(wc -w <<< "$smartdrives" | xargs) drives will be tested each time the script it run."
            echo " ") | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        return
    fi

    Drive_List=""
    Demo_Track=1            # Keeping track on where we are in the drive day list (Mon, Tue)
    IFS=","

    for Demo_Authorized_Days in $Drives_Tested_Days_of_the_Week; do             # Loop through the authorized days

        case $Demo_Authorized_Days in                                           # Lets give us authorized days of the week.
            1)    day_of_week="Monday"    ;;
            2)    day_of_week="Tuesday"    ;;
            3)    day_of_week="Wednesday"    ;;
            4)    day_of_week="Thursday"    ;;
            5)    day_of_week="Friday"    ;;
            6)    day_of_week="Saturday"    ;;
            7)    day_of_week="Sunday"    ;;
        esac
        IFS=$IFS_RESTORE
        if [[ $Demo == "true" ]]; then
            (echo " "; echo $day_of_week":"
            ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi

        # FOR WEEKLY RESULTS
        Demo_loop=0
        while [ $Demo_loop -lt $Drives_to_Test_Per_Day ]; do        # We are on more than 3 drives per day
            Drive_List_Temp=$(echo $smartdrives_sorted | cut -d ' ' -f ${Demo_Track} | xargs)
            if [[ $Drive_List != *"${Drive_List_Temp}"* ]]; then
                if [[ $Demo_loop -eq 0 ]]; then
                    Drive_List=$Drive_List_Temp                                 # First Pass
                else
                    if [[ $loop_counter -eq $Drive_List_Length ]]; then
                        Drive_List=$Drive_List",\n "$Drive_List_Temp
                        loop_counter=0
                    else
                        (( loop_counter ++ ))
                        Drive_List=$Drive_List", "$Drive_List_Temp              # Successive Passes
                    fi
                fi
            fi
            if [[ $Demo_Track -gt $Drive_Count ]]; then    break; fi            # Drive_List=""; fi
            (( Demo_Track ++ ))
            (( Demo_loop ++ ))
        done
        if [[ $Demo == "true" ]]; then
            if [[ $Drive_List == "" ]]; then Drive_List="No Remaining Drives"; fi
            echo -e " "$Drive_List | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        Drive_List=""
    done
	if [[ $Silent != "enable" ]]; then
		echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
	fi
    IFS=$IFS_RESTORE
    if [[ $Demo != "true" ]]; then
    (    if [[ $drives_tested_demo == "" ]]; then
            if [[ $Silent != "enable" ]]; then
                echo "    Drive(s) previously scheduled to be tested: None"
            fi
        else
            if [[ $Silent != "enable" ]]; then
                echo "    Drive(s) previously scheduled to be tested: "$drives_tested_demo
            fi
        fi
        if [[ $drives_to_test == "" ]]; then
            if [[ $Silent != "enable" ]]; then
                echo "    Drives scheduled for testing today: None"
            fi
        else
            if [[ $Silent != "enable" ]]; then
                echo "    Drive(s) scheduled for testing today: "$drives_to_test
            fi
        fi
		if [[ $Silent != "enable" ]]; then
			echo " "
		fi
		) | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
        
    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT list_weekly_output"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }


##### GET DRIVE SERIAL NUMBERS VIA SMARTCTL TO SEE IF THIS IS FASTER OR NOT.  ALSO KEEP IS AS A BACKUP ROUTINE.
# STILL NEED TO BE CHANGED FROM API TO SMARTCTL.

# CALLED FROM ONE LOCATION
sort_serial_number () {
    if [[ $Debug_Steps == "true" ]]; then echo "sort_serial_number" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# This routine performs three things:
#  1. Sorts the drive serial numbers.
#  2. Places the drive ids ($smartdrives_sorted) in the same order as the sorted serial numbers.
#  3. NVMe drive names are properly formatted.
#
# Global Variables: api_drive_serial_number, smartdrives_sorted
# Local Variables: api_x, api_y, api_drive_name, api_drive_name_test, api_drive_serial_order, Serial_Length, 
#
# Input - api_drive_serial_number, Output - smartdrives_sorted

    (echo "            "$start_time_display":  START sort_serial_number") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    
    api_x=0
    api_y=0
    api_drive_name=""
    if [[ $Silent != "enable" ]]; then
        (echo " "
        echo -n "    Sorting Drive Test Order ") | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
    for api_drive_serial_order in $api_drive_serial_number; do
        while [[ "$(echo $Drive_Disk_Query  | jq -r '.['$api_y'].name')" != "null" ]]; do    # Loop through all of the drives comparing S/N Order to drive
            api_drive_serial_test=$(echo $Drive_Disk_Query  | jq -r '.['$api_y'].serial')
            if [[ $Silent != "enable" ]]; then
                echo -n "." | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
            Serial_Length=$(wc -c <<< "$api_drive_serial_test")                              # Too short of a S/N (3 characters or less) = Not Valid Drive
            if [[ $Serial_Length -gt 3 ]]; then
                if [[ $api_drive_serial_order == "$api_drive_serial_test" ]]; then
                    api_drive_name_test=$(echo $Drive_Disk_Query  | jq -r '.['$api_y'].name')
                    if [[ $softver != "Linux" ]]; then
                        api_drive_name=$api_drive_name" "$api_drive_name_test" "
                    else
                        if [[ $api_drive_name_test == *"nvme"* ]]; then
                            api_drive_name=$api_drive_name" "$(echo "nvme"$(echo $api_drive_name_test | sed -r 's#^nvme##' | cut -d 'n' -f 1)" ")
                        else
                            api_drive_name="$api_drive_name $api_drive_name_test "
                        fi
                    fi
                    break
                fi
            fi
            ((api_y ++))
        done
        api_y=0
        ((api_x ++))
    done
    if [[ $Silent != "enable" ]]; then
        echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
    smartdrives_sorted=$(echo "$api_drive_name" | xargs |  sed 's/nvd/nvme/g' | sed 's/n1//g')

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT sort_serial_number"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    
    }


########## RUN NVMe SELFTEST ##########
# CALLED FROM ONE LOCATION
nvm_selftest () {
    if [[ $Debug_Steps == "true" ]]; then echo "nvm_selftest" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# $1 is Long or Short
#
# Global Variables: $1, softver, Wait_For_SMART_Short_Test, Wait_For_SMART_Long_Test, drive
# Local Variables: check_nvme_selftest, smart_selftest
#

    (echo "                    "$start_time_display":  START nvm_selftest") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    # This check should not be required as this function is only called if nvme commands are required.
    # I may need to change this to only check smartmontools if it is version 7.4, regardless of if it is not completely compatible until version 7.5.
    if ! [[ $programver3 -lt 24 ]] || [[ $programver3 -eq 13 && $programver4 -eq 3 ]]; then            # Check if we are using TrueNAS which supports nvme testing, after version 24.04 ?
        # Use smartctl
        echo "Version 13.3 (CORE) or 24 (SCALE) or greater."
        if [[ $1 == "Long" ]]; then
            smartctl -t long /dev/$drive
        else
            smartctl -t short /dev/$drive
        fi
    else
        NVMe_Override_Enabled="true"
        echo "Using direct nvme commands to test nvme drives." | tee -a /tmp/drive_selftest/drive_test_temp.txt
        # FIRST KICK OFF EACH TEST
        if [ $softver != "Linux" ]; then
            # FreeBSD Commands
            check_nvme_selftest=$(nvmecontrol identify "$drive" | grep -i "self-test")
            shopt -s nocasematch  # Make test not case sensitive
            if [[ $check_nvme_selftest != *"Not"* ]]; then
                if [[ $Silent != "enable" ]]; then
                    if [[ $1 == "Long" ]]; then
                        echo "Running $1 Self-test for $drive" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    else
                        echo "Running $1 Self-test for $drive" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                fi
                if [[ "$1" != "Long" ]]; then    #Default run Short self-test.
                    smart_selftest="1"
                else
                    smart_selftest="2"
                fi
                nvmecontrol selftest -c $smart_selftest "$drive"
            else
                echo "$drive does not support Self-test" | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
            shopt -u nocasematch
        else
            # Debian Commands
            check_nvme_selftest=$(nvme id-ctrl /dev/"$drive" -H | grep -i "self-test")
            if [[ $check_nvme_selftest != *"Not"* ]]; then
                if [[ $Silent != "enable" ]]; then
                    if [[ $1 == "Long" ]]; then
                        echo "Running $1 Self-test for $drive in background " | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    else
                        echo "Running $1 Self-test for $drive" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                fi
                if [[ "$1" != "Long" ]]; then
                    smart_selftest="1"
                else
                    smart_selftest="2"
                fi
                nvme device-self-test /dev/"$drive" -s $smart_selftest
            else
                echo "$drive does not support Self-test" | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
        fi
    fi
    
    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "                    "$end_time_display":  EXIT nvm_selftest"
    echo -n "                    Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt    

    }


########## GET DRIVE LISTINGS
# CALLED FROM ONE LOCATION
get_API_Drives () {
    if [[ $Debug_Steps == "true" ]]; then echo "get_API_Drives" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# Replaces all the drive listing procedures.
# Input = Nothing
# Output = List of each drive TrueNAS recognizes along with (within an array; Drive Name, Model, Serial Number, Interface Type) and the full Drive Query output.
#
# Global Variables: Debug, Drive_Disk_Query, smartdrives, drives_name[@], drives_serial[@], drives_subsystem[@], drives_model[@]
# Local Variables: index, increment
#

    (echo "    "$start_time_display":  START get_API_Drives") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    # Setup local variables
    index=0            # INDEX IS THE REPORTED BACK DRIVES
    increment=0        # INCREMENT IS THE ACCESS TO THE FULL ARRAY, INCLUDING VIRTUAL AND CD DRIVES
    skip_drives_count=0

    if [[ $Debug == "true" ]]; then    echo "Debug - Function 'get_API_Drives'" | tee -a /tmp/drive_selftest/drive_test_temp.txt; echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
        if [[ $Test_ONLY_NVMe_Drives == "enable" ]]; then
            echo "Testing ONLY NVMe Drives" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
    Drive_Disk_Query=$(midclt call disk.query)

    # 1. Get all API data in a variable, one call. -- Can we find API that says SMART Self-test is supported or not?  May need to use smartctl for one thing.
    #    `supports_smart:null`, maybe check if null and if so or `no`, use smartctl.
    # 2. Get Drive data into an array

    drives_name=$(echo $Drive_Disk_Query | jq '.[].name' | tr -d '"')            # get all the drive names
 
    for i in $drives_name; do
        drives_model[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.model')
        drives_name[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.name')
        drives_serial[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.serial' | tr -d ' ')        # "td -d ' '" removes any white space from the serial number

        for p in {0..100}; do            # ARE WE REALLY GOING TO SEE 100 POOLS, well just in case?  THIS IS NOT THE ID NUMBER
            Function_Pool_Name=$(midclt call pool.query | jq -r '.['$p'].name')
            Function_Scan=$(midclt call pool.query | jq -r '.['$p'].scan.function')
            drive_compare_value=$(midclt call pool.query | jq '.['$p']' | grep '"disk":' | cut -d ':' -f2 | tr -d '"' | tr -d ',')
            if echo $drive_compare_value | grep -qw ${drives_name[$index]}; then
                drives_pool[index]=$Function_Pool_Name
                break
            fi
            if [[ $Function_Scan == "null" ]]; then    # null = not more pools left to scan.
                break
            fi
        done
    	if [[ $Silent == "enable" ]]; then
			echo -n "."
		fi
        
    # WE NEED TO WEED OUT ALL BUT NVD/NVME DRIVES IF NVME TEST ONLY OPTION SET
        if [[ $Test_ONLY_NVMe_Drives == "enable" ]]; then
            # WE NEED TO LET PASS ONLY NVD/NVME HERE
            if [[ ${drives_name[$index]} == "nvme"* ]] || [[ ${drives_name[$index]} == "nvd"* ]]; then
                if [[ $Debug == "true" ]]; then
                    echo "continue "$i | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
            else
                if [[ $Debug == "true" ]]; then
                    echo "Virtual "$i | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
                drives_model[$index]="Virtual"            # Change all non NVD/NVME drives to Virtual, Crappy Hack But it Works?
            fi
        fi

    # WE NEED TO WEED OUT VIRTUAL AND CD DRIVES AND IGNORE LIST DRIVES
        if [[ ${drives_model[$index]} == *"Virtual"* ]] || [[ ${drives_name[$index]} == "cd"* ]] || [[ $Ignore_Drives_List =~ ${drives_serial[$index]} ]]; then
            (( skip_drives_count ++ ))
            if [[ $Debug == "true" ]] || [[ $Demo == "true" ]] || [[ $timer_flag -eq 1 ]] ; then
                if [[ $Ignore_Drives_List =~ ${drives_serial[$index]} ]]; then
                    if [[ $Silent != "enable" ]]; then
                        echo "Skip Ignored Drive(s): "${drives_name[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                    skip_drives_ignore=$skip_drives_ignore", "${drives_name[$index]}"("${drives_serial[$index]}")"
                else
                    if [[ $Silent != "enable" ]]; then
                        echo "Skip Virtual Drive(s): "${drives_name[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                    skip_drives_virtual=", "${drives_name[$index]}
                fi
            fi
            (( increment ++ ))
            continue
        fi

        if echo ${drives_name[$index]} | grep -q -i "nvd"; then
            drives_name[index]="$(echo ${drives_name[index]} | sed 's/nvd/nvme/g' | sed 's/n1//g')"
        elif echo ${drives_name[$index]} | grep -q -i "nvme"; then
            drives_name[index]="$(echo "nvme"$(echo ${drives_name[$index]} | sed -r 's#^nvme##' | cut -d 'n' -f 1))"
        fi

        drives_subsystem[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.subsystem')
        (( index ++ ))
        (( increment ++ ))
    done

    # If the last drive at the end jumps out and is a virtual or cd drive, remove it.
    if [[ ${drives_model[$index]} == *"Virtual"* ]] || [[ ${drives_name[$index]} == "cd"* ]] || [[ $Ignore_Drives_List =~ ${drives_serial[$index]} ]]; then drives_name[index]=""; drives_serial[index]=""; fi

    drives_count=$(echo ${drives_name[@]} | wc -w)

    smartdrives=${drives_name[@]}
    if [[ $Debug == "true" ]]; then
        index=0
        for i in ${drives_name[@]}; do
            echo -n "Debug - Drive ID="${drives_name[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo -n ", Drive S/N="${drives_serial[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo -n ", Drive Model="${drives_model[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo -n ", Drive Subsystem="${drives_subsystem[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo ", Drive belongs to Pool:"${drives_pool[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
            (( index ++ ))
        done
        echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Total Drives="$drives_count | tee -a /tmp/drive_selftest/drive_test_temp.txt
		echo "Debug - Data is listed in an array of"$drives_count":"
        echo "Debug - Drive Names="${drives_name[@]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drive Serial Numbers="${drives_serial[@]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drive Pools="${drives_pool[@]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Leaving function 'get_API_Drives'" | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi

    skip_drives_ignore="Ignored: "${skip_drives_ignore:1}
    skip_drives_virtual="Virtual: "${skip_drives_virtual:1}
    
    (echo "    Good Drive Count: "$drives_count
    if [[ $skip_drives_ignore != "" || $skip_drives_virtual != "" ]]; then echo "    Drives Removed: "$skip_drives_count" : "$skip_drives_virtual", "$skip_drives_ignore; fi

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    echo "    "$end_time_display":  EXIT get_API_Drives"
    echo -n "    Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
        
    }

########## SORT ROUTINE ##########

sort_data () {
    if [[ $Debug_Steps == "true" ]]; then echo "sort_data" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# Global Variables: sort_list
# Local Variables: i

	(echo "            "$start_time_display":  START sort_data '$1'") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    if [ $softver != "Linux" ]; then
    sort_list=$(for i in $sort_list; do
        echo "$i"
        done | sort -V)
    else
        sort_list_short=$(for i in $sort_list; do
            echo "$i"
        done | awk 'length<4' | sort -V)
        sort_list_long=$(for i in $sort_list; do
            echo "$i"
        done | awk 'length>3' | sort -V)
        sort_list=$sort_list_short" "$sort_list_long
        sort_list="$(echo "$sort_list" | tr -s " ")"
    fi
    
    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT sort_data"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }


    delete_log_files () {
        if [[ $Debug_Steps == "true" ]]; then echo "delete_log_files" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    # This function will detect and delete all the log file created by this script.
    
    if ls drive_selftest_demo_??.txt 1> /dev/null 2>&1; then echo "Removing Demo Log Files"; rm drive_selftest_demo_??.txt; else echo "No demo log files to remove."; fi
    if ls drive_selftest_??.txt 1> /dev/null 2>&1; then echo "Removing Log Files"; rm drive_selftest_??.txt; else echo "No log files to remove."; fi

    }
    
    
    elapsed_time () {
    # Pass the starting time value.  Only for Linux.
        end_time_display=$(date +"%H:%M:%S.%2N")
        time_diff=$(($(date -d "$end_time_display" '+%s%2N') - $(date -d "$1" '+%s%2N')))
        rev_time=$(echo $time_diff | rev)
        end_tenths=$(echo ${rev_time:0:2} | rev)
        end_time=$(echo ${rev_time:2} | rev)
        SECONDS=$end_time
    }


# CALLED FROM TWO LOCATIONS    
help_text () {
    if [[ $Debug_Steps == "true" ]]; then echo "help_text" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    clear
    echo "SMART Drive Self-test Script: "$Version" "$Version_Date
    echo "Standalone or Companion to Multi-Report 3.1 and later."
    echo " "
    echo "For Standalone Operation (not using multi_report_config.txt file),"
    echo "edit lines (around line 110) '######### USER SETTINGS #########' as desired."
    echo " "
    echo "There are six significant groups of variables: Automatic Update, Short tests, Long tests,"
    echo "SCRUB/RESILVER, Ignore Drives, and Reports."
	echo " "
	echo "Open this file up in a simple text editor to view the configuration notes, starts on line 110'ish."
	echo "NOTE: If you edit this file and it states the file cannot be run, ensure your text editor"
	echo "did not end each line with 'CRLF'.  All lines should end with 'LF'."
    echo " "
    echo "Automatic Updates will allow the drive_selftest.sh file to be updated should it be out of date."
    echo " "
    echo "This script can use the multi_report_config.txt file when combined with Multi-Report."
    echo "You must configure these settings in Multi-Report, otherwise the values at the beginning"
    echo "of this script will be used."
    echo " "
    echo "Short and Long tests are configured as follows:"
    echo " "
    echo "  Test_Mode: 1 = Use Short(or Long) Drives_to_Test_Per_Day value"
    echo "             2 = All Drives Tested (Ignores other options except when active)"
    echo "             3 = No Drives Tested"
    echo " "
    echo "  Time_Delay_Between_Drives: Tests will have a XX second delay between the"
    echo "  drives starting testing."
    echo " "
    echo "  Short_Drives_Test_Delay: Time period in seconds to wait for SHORT tests to complete."
    echo "  Default is 130 seconds for use with Multi-Report, if not then set to 1 second."
    echo " "
    echo "BELOW OPTIONS ARE USED ONLY WITH Test Mode 1"
    echo "--------------------------------------------"
    echo " "
    echo '  SMART_Testing_Order: Select "DriveID" or "Serial" sorting order.'
    echo " "
    echo "  Drives_to_Test_Per_Day: How many drives to run each day minimum."
    echo "  The script will auto-correct if you choose too small of a value."
    echo " "
    echo '  Drives_Test_Period: Options are "Week" (Mon-Sun) or "Month" (days 1 - 28)'
    echo " "
    echo "  Drives_Tested_Days_of_the_Week: Days of the week allowed to run:"
    echo '  1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun  Default = "1,2,3,4,5,6,7"'
    echo " "
    echo "Press Any Key to Continue"
    read -s -n 1 key_input
    echo "--------------------------------------------------------------------------"
    echo " "
	echo "Missed Drive Catchup Feature"
	echo "----------------------------"
	echo " "
	echo " This feature was added to enable catching up on any S.M.A.R.T. Long tests for"
	echo " drives that were missed because the script was not being run every day."
	echo " The default setting is to make up one extra drive per day."
	echo " You may change this setting to 0 (zero) to disable this feature,"
	echo "or increase the value as desired."
	echo " "
	echo " "
	echo "NORMAL OPERATION DOES NOT REQUIRE ANY COMMAND LINE SWITCHES"
    echo "-----------------------------------------------------------"
	echo " "
    echo "Command Line Switches:"
    echo "NOTE! The demo mode uses the 'Drives_Tested_Days_of_the_Week' value to"
    echo "calculate how many drives are to be run on which days of the week."
    echo "If the demo results are not the desired effect, adjust the values."
    echo " "
	echo "    '-update' --- Will download the current published version of this script."
	echo " "
    echo "    '-timer' --- Generates a file which tracks how many seconds are utilized"
    echo "                 for each routine within the script.  Used for development."
    echo " "
    echo "    '-demo' '[short|long]' '[1|2|3]' '[week|month]' '[driveid|serial]'"
    echo "        Lists full drive testing schedule."
    echo "        Use short or long options to focus on one list."
    echo "        Override Settings will not use the script set values."
    echo "            Test Mode using '1','2', or '3'."
    echo "            Testing Period 'week' or 'month'."
    echo " "
    echo "    '-clearlog' --- Delete all the drive_selftest log files."
    echo " "
    echo "    '-debug'    --- Runs the script in Debug Mode"
    echo " "
    echo "Example: drive_selftest -demo short 1 week serial"
    echo " Means: Simulate Short SMART Test, Test Mode 1 to spread across a Week"
    echo " and using the days of the week set in the script setup."
    echo " "
    echo "Example: drive_selftest -demo short"
    echo " Means: Simulate a Short SMART Test using the current configured settings"
    echo " "
    echo "This will provide a listing of how your drives would be tested for"
    echo "a short test in Test Mode 1, providing you the dates they would be tested."
    echo " "
    echo "To read the Troubleshooting Help pages, Press 'Y'"
    echo "Press any other key to exit"
    read -s -n 1 key_input
    if [[ $key_input == "y" ]] || [[ $key_input == "Y" ]]; then troubleshooting_help; fi
    exit 0
    
    }

# CALLED FROM ONE LOCATION    
troubleshooting_help () {
    if [[ $Debug_Steps == "true" ]]; then echo "troubleshooting_help" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    clear
    echo "TROUBLESHOOTING HELP                           Script Version: "$Version" "$Version_Date
    echo "You are running on "$programver
    echo " "
    echo "This section will attempt to help you define and solve any error messages"
    echo "in which you may encounter."
    echo " "
    echo "First: What is a problem message?"
    echo " 1. If you see an error message about exit code that is other than zero (0)."
    echo " 2. If you notice drives are being tested in an improper sequence."
    echo " 3. Any script failure messages."
    echo " "
    echo "Second: What is not a problem message?"
    echo " 1. Any message by the ROBOT.  These are informational letting you know"
    echo "    that you entered an unsustainable variable and ROBOT made an"
    echo "    adjustment to ensure all drives are testing in the configured time frame."
    echo " 2. 'Skipping drive' means the drive was already in test."
    echo " 3. Days being skipped in '-demo' mode.  First check your Authorized Days"
    echo "    to run the test, odds are you are missing the week days not included."
    echo " "
    echo " "
    echo "Press Any Key to Continue"
    read -s -n 1 key_input
    echo "--------------------------------------------------------------------------"
    echo " "
    echo "If you are virtualizing a drive, this script removes virtual drives."
    echo "You will need to pass through the controller or run bare metal."
    echo "Even real drives passed through as RDM (ESXi) will be seen as Virtual."
    echo " "
    echo "If you feel the script is taking too long, then use the '-timer' switch"
    echo "to generate a file with timing information, located in the log directory"
    echo "with all the other logs.  Joe needs that if you think there is a problem."
    echo " "
    echo "For any other failures, contact Joe at joeschmuck2023@hotmail.com with"
    echo "the following details: A copy of the log data file(s).  If you feel a few"
    echo "earlier log data files would help, send those as well, and any other"
    echo "information you feel is relevant.  While there is a such thing as too much"
    echo "data, I'd rather have more than less."
    echo " "
    echo "--- Be patient as I will answer as soon as I see the email, I am not glued"
    echo "to my computer and have a life.  I may ask you to perform a few commands"
    echo "to help troubleshoot the issue."
    echo " "
    echo "Five Waka Waka Jokes: https://www.youtube.com/watch?v=rDpUAqQPnzM"
    echo "If you are bored"
        
    }


######################### PROGRAM STARTS HERE ##########################
#

### Use multi_report_config.txt or not?
# If the file does not exist, script values will be used and no error message will be generated.
# Either setting the Use_multi_report_config_values="enable" (at top of script), or switch will use the Multi-Report file, if it exists.
# First line finds out if this script was called by Multi-Report.

### DELETE ANY LEFTOVER TEMPORARY FILES IF THEY EXIST, THEY SHOULDN'T.
if test -e "/tmp/drive_selftest"; then rm -R "/tmp/drive_selftest"; fi
sleep .2
mkdir "/tmp/drive_selftest"        # Create temporary directory for this iteration of the script.

echo "Joe's SMART Drive Self-test Script - Run: "$today_day" "$Full_Month_Name" "$(date +%r) | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
echo "Script Version: "$Version" "$Version_Date", "$programver | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt

if test -e "$Config_File_Name" || [[ $1 == "-use_external_file" ]]; then
    if [[ $Use_multi_report_config_values == "enable" ]]; then
        if test -e "$Config_File_Name"; then
            . "$Config_File_Name"
            echo 'Using "'$Config_File_Name'" values..."' | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
        else
            echo 'Using "script" values...' | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
        fi
    fi
fi
if [[ $1 == "" ]] || [[ $1 == "-update" ]] || [[ $1 == "-demo" ]] || [[ $1 == "-help" ]] || [[ $1 == "-timer" ]] || [[ $1 == "-clearlog" ]] || [[ $1 == "-debug" ]] || [[ $1 == "-dump" ]] || [[ $1 == "-use_external_file" ]] ; then
	:
else
	help_text
	exit 1
fi

if [[ $1 == "-dump" ]] || [[ $2 == "-dump" ]] || [[ $1 == "-debug" ]] || [[ $2 == "-debug" ]] || [[ $3 == "-debug" ]] || [[ $4 == "-debug" ]]; then Silent="disable"; Debug="true"; fi    # This is duplicated before and after the config file is read to ensure we remain in "debug" mode.

if [[ $Enable_Logging == "enable" ]]; then
    if ! test -e "$LOG_DIR"; then
        echo "'"$LOG_DIR"' does not exist, attempting to create it..." | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
        mkdir $LOG_DIR
        if test -e "$LOG_DIR"; then
            echo "Success" | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
        else
            echo "Failed to create '"$LOG_DIR"', using script default directory of "$SCRIPT_DIR | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
            LOG_DIR=$SCRIPT_DIR
        fi
    fi
    if [[ $Silent != "enable" ]]; then
        echo " "
        echo "Logging Enabled" | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
    fi
fi

if [[ $Silent == "enable" ]]; then
    (echo " "
    echo "----> Silent Enabled - Minimal Data and any Errors will be reported <----"
    echo "----> You may experience prolonged silence, be patient <----"
    echo " ") | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
fi

if [[ $Check_For_Updates == "enable" ]]; then
    checkforupdate
fi

if [[ $Automatic_Selftest_Update == "enable" ]] && [[ $UpdateDriveAvailable == "true" ]]; then checkforupdate; fi

if [[ $1 == "-update" ]]; then
    update_Drive_script
    sleep 1
    exit 0
fi

SECONDS=0            # Lets start the timer
if [[ $softver != "Linux" ]]; then start_time_display=$(date '+%H:%M:%S'); else start_time_display=$(date +"%H:%M:%S.%2N"); fi

(echo "This log file is used to track the execution time for each routine and identify any location to optimize if possible."; echo " "
echo $start_time_display":  Program Start"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

#### SETUP SCRIPT TO ACKNOWLEDGE ANY ORDER OF SWITCHES.

#  OPTIONS ARE '-demo' 'short' 'long' week' 'month' '1' '2' '3' BUT NOT TWO OF THE SAME GROUP - CASE INSENSITIVE ###
counter_loop=0
short_cli=0
long_cli=0
week_cli=0
month_cli=0
x1_cli=0
x2_cli=0
x3_cli=0
x_cli=0
timer_flag=0
drive_selftest_dump="false"

shopt -s nocasematch            # Make it case-insensitive

    if [[ $1 == "-use_external_file" ]]; then
		if [[ $Silent == "disable" ]]; then
			echo "Using External Configuration File"
		fi
        if [[ $2 == "-dump" ]]; then
            drive_selftest_dump="true"
            echo "Saving Dump Data"
        fi
    elif [[ $1 == "-dump" ]]; then
        drive_selftest_dump="true"
        echo "Saving Dump Data"
    elif [[ $1 == "-demo" ]]; then
        Demo="true"
    elif [[ $1 == "-clearlog" ]]; then
        delete_log_files
        exit 0
    elif [[ $1 == "-help" ]]; then
        help_text
        echo " "
        exit 0
    elif [[ $1 == "-timer" ]] || [[ $2 == "-timer" ]]; then
        timer_flag=1
    elif [[ $1 == "-debug" ]] || [[ $2 == "-debug" ]] || [[ $3 == "-debug" ]] || [[ $4 == "-debug" ]] ; then
        Debug="true"
		Silent="disable"
    elif [[ $1 != "" ]]; then
        echo "Command Line Options is invalid."
        echo "You may use '-help' for further information"
        echo " "
        exit 1
    fi

if [[ $Demo == "true" ]]; then
    counter_loop=0
    while [ $counter_loop -lt 20 ]; do                # Check for any order of the CLI switches ONLY if -demo is present.
        if [[ $1 == "short" ]]; then short_cli=1; fi    
        if [[ $1 == "long" ]]; then long_cli=1; fi    
        if [[ $1 == "week" ]]; then week_cli=1; fi
        if [[ $1 == "month" ]]; then month_cli=1; fi
        if [[ $1 == "DriveID" ]]; then DriveID_cli=1; fi
        if [[ $1 == "Serial" ]]; then Serial_cli=1; fi
        if [[ $1 == "1" ]]; then x1_cli=1; fi
        if [[ $1 == "2" ]]; then x2_cli=1; fi
        if [[ $1 == "3" ]]; then x3_cli=1; fi
        shift 1        # rotate $1 value
        (( counter_loop ++ ))
    done

    # Not two of the opposite values
    if [[ $week_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Long_Drives_Test_Period="Week"; fi    
    if [[ $week_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Drives_Test_Period="Week"; fi    
    if [[ $month_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Drives_Test_Period="Month"; fi
    if [[ $month_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Drives_Test_Period="Month"; fi
    if [[ $DriveID_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_SMART_Testing_Order="DriveID"; fi
    if [[ $DriveID_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_SMART_Testing_Order="DriveID"; fi
    if [[ $Serial_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_SMART_Testing_Order="Serial"; fi
    if [[ $Serial_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_SMART_Testing_Order="Serial"; fi

    if [[ $short_cli -eq 1 ]]; then Short_Test_Mode=1; Long_Test_Mode=3; fi
    if [[ $long_cli -eq 1 ]]; then Short_Test_Mode=3; Long_Test_Mode=1; fi

    if [[ $x1_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Test_Mode=1; Long_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x2_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Test_Mode=2; Long_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x3_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Test_Mode=3; Long_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x1_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Test_Mode=1; Short_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x2_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Test_Mode=2; Short_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x3_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Test_Mode=3; Short_Test_Mode=3; (( x_cli ++ )); fi

# Error Messages
    if [[ $short_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then echo "You cannot specify both 'short' and 'long' at the same time."; exit 1; fi
    if [[ $week_cli -eq 1 ]] && [[ $month_cli -eq 1 ]]; then echo "You cannot specify both 'week' and 'month' at the same time."; exit 1; fi
    if [[ $(( x1_cli + x2_cli + x3_cli )) -gt 1 ]]; then echo "You cannot specify more than one test mode (1, 2, or 3) on the CLI."; exit 1; fi
    if [[ $DriveID_cli -eq 1 ]] && [[ $Serial_cli -eq 1 ]]; then echo "You cannot specify both 'DriveID; and 'Serial' at the same time."; exit 1; fi
    if [[ $(( mon_cli + tue_cli + wed_cli + thu_cli + fri_cli + sat_cli + sun_cli )) -gt 1 ]]; then echo "You cannot specify multiple days of the week (Mon - Sun)"; exit 1; fi
fi

if [[ $1 == "-demo" ]]; then
    Demo="true"
    echo "Demo Mode: Below is the simulated testing schedule based on current settings."
    echo " "
    (echo "Demo Mode: Below is the simulated testing schedule based on current settings."
    echo " ") >> /tmp/drive_selftest/drive_test_temp.txt
fi

if ! [[ $timer_flag -eq 1 ]]; then 
    if [[ $1 != "" ]] && [[ $1 != "-demo" ]] && [[ $1 != "-debug" ]] && [[ $1 != "-use_external_file" ]] && [[ $1 != "-dump" ]]; then help_text; fi
    if [[ $2 != "short" ]] && [[ $2 != "long" ]] && [[ $2 != "" ]] && [[ $2 != "-dump" ]]; then help_text; fi
fi
shopt -u nocasematch

(( Drive_List_Length -- ))            # Adjust for offset
get_API_Drives                        # Grab all the drive data at one single time

check_scrub                           # Is a SCRUB going on?  This function will set the test mode to "0" if no tests are to be run.

if [[ $Long_Test_Mode -ne 0 ]]; then
    robot_routine Short           # Run Short HDD/SSD SMART Tests
fi

if [[ $Short_Test_Mode -ne 0 ]]; then
    smartdrives_sorted=""             # Reset the variable
    robot_routine Long            # Run Long HDD/SSD SMART Tests
fi

# Convert Authorized Days to Text String just so we can add it to the Multi-Report output.
Short_DOW_days=""
IFS=","
for day_of_week_test in $Short_Drives_Tested_Days_of_the_Week; do
    case $day_of_week_test in                               # Lets give us days of the week.
        1)    day_of_week="Mon"    ;;
        2)    day_of_week="Tue"    ;;
        3)    day_of_week="Wed"    ;;
        4)    day_of_week="Thu"    ;;
        5)    day_of_week="Fri"    ;;
        6)    day_of_week="Sat"    ;;
        7)    day_of_week="Sun"    ;;
    esac
    if [[ $Short_DOW_days == "" ]]; then                          # The first match by itself.
        Short_DOW_days=$day_of_week
    else
        Short_DOW_days=$Short_DOW_days", "$day_of_week                  # Ass successive matches joined together by a comma.
    fi
done

Long_DOW_days=""
for day_of_week_test in $Long_Drives_Tested_Days_of_the_Week; do
    case $day_of_week_test in                               # Lets give us days of the week.
        1)    day_of_week="Mon"    ;;
        2)    day_of_week="Tue"    ;;
        3)    day_of_week="Wed"    ;;
        4)    day_of_week="Thu"    ;;
        5)    day_of_week="Fri"    ;;
        6)    day_of_week="Sat"    ;;
        7)    day_of_week="Sun"    ;;
    esac
    if [[ $Long_DOW_days == "" ]]; then                          # The first match by itself.
        Long_DOW_days=$day_of_week
    else
        Long_DOW_days=$Long_DOW_days", "$day_of_week                  # Ass successive matches joined together by a comma.
    fi
done
    
# These two lines should never result in None
if [[ $Short_DOW_days == "" ]]; then Short_DOW_days="None"; fi
if [[ $Long_DOW_days == "" ]]; then Long_DOW_days="None"; fi
    
IFS=$IFS_RESTORE

if [[ $Short_Drives_Testing == "" ]]; then Short_Drives_Testing="none today"; fi
if [[ $Long_Drives_Testing == "" ]]; then Long_Drives_Testing="none today"; fi

(echo "   a) Short Test Authorized Test Days ("$Short_DOW_days") (~$Drives_to_Test_Per_Day Drive(s) per day)"
 echo "      Drives Testing: ("$Short_Drives_Testing") - Test Mode "$Short_Test_Mode
 echo "   b) Long Test Authorized Test Days ("$Long_DOW_days") (~$Drives_to_Test_Per_Day Drive(s) per day)"
 echo "      Drive(s) Testing: ("$Long_Drives_Testing") - Test Mode "$Long_Test_Mode
 if [[ $overdue_drives != "" ]]; then
 echo "      - Overdue Drive(s) '"$(echo $overdue_drives | xargs)"' were added to Long Tests."
 fi
 if [[ $overdue_drives_skipped != "" ]]; then
	echo "      - Overdue Drive(s) '"$(echo $overdue_drives_skipped | xargs)"' Skipped due to exceeding Maximum_Catchup_Drive_Count="$Maximum_Catchup_Drive_Count"."
 fi

if [[ $NVMe_Override_Enabled == "true" ]]; then
	echo "   c) NVMe S.M.A.R.T. Testing using 'nvme' commands vice 'smartctl'"
else
	echo "   c) 'NVMe' S.M.A.R.T. Testing commands Not Required."
fi

if [[ $SCRUB_List_of_Drives != "" ]]; then			# A SCRUB is going on, check if okay or not.
#******
		echo "   d) A SCRUB is in progress on '"$SCRUB_List_of_Drives"' with "$Function_Time_Left_SCRUB_Whole1"."$Function_Time_Left_SCRUB_Fraction" Hours remaining."
		echo "<i>      A S.M.A.R.T. SHORT test will be conducted on '"$SCRUB_List_of_Drives"' if pool completion time exceeds '"$SCRUB_Minutes_Remaining"' minutes.</i>"
else
	echo "   d) A SCRUB is NOT in progress."
fi

if [[ $RESILVER_List_of_Drives != "" ]]; then		# Keeping this for when I can actually split the information.
	  echo "   e) A RESILVER is in progress on '"$RESILVER_Pools"' with "$Function_Time_Left_RESILVER_Whole1"."$Function_Time_Left_RESILVER_Fraction" Hours remaining."
	  echo "<i>      Drives in this pool will not be tested while the RESILVER is in progress.</i>"
else
	echo "   e) A RESILVER is NOT in progress."
fi

echo " ") > /tmp/smartdrive_selftest_text.txt

#cat /tmp/smartdrive_selftest_text.txt
#exit 3

# CALCULATE THE SCRIPT DURATION
if [[ $softver != "Linux" ]]; then
    end_time_display=$(date '+%H:%M:%S')
else
    elapsed_time $start_time_display
fi

# PRINT THE SCRIPT DURATION
if [[ $Silent != "enable" ]]; then
    (echo " "
    echo $end_time_display":  Drive-Selftest Wrapping things up..."
    echo -n "Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
    if [[ $end_tenths != "" ]]; then
        echo ".$end_tenths seconds elapsed."
    else
        echo " seconds elapsed."
    fi
    echo " ") | tee -a /tmp/drive_selftest/drive_test_temp.txt
else
    (echo " "
    echo $end_time_display":  Drive-Selftest Wrapping things up..."
    echo -n "Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
    if [[ $end_tenths != "" ]]; then
        echo ".$end_tenths seconds elapsed."
    else
        echo " seconds elapsed."
    fi
    echo " ") >> /tmp/drive_selftest/drive_test_temp.txt
fi

# TIME TO TELL EVERYONE THE DURATION OF THE WAIT
if [[ $Silent != "enable" ]]; then
    (
    if [[ $No_Tests == "false" ]]; then
        if [[ $Short_Drives_Test_Delay -lt 6 ]]; then
            echo "Short $Short_Drives_Test_Delay Second Pause..."
        else
            echo "Waiting $Short_Drives_Test_Delay Second Delay so the drives can finish S.M.A.R.T. Short test, Please Standby..."
        fi
    fi
    ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
else
    (
    if [[ $No_Tests == "false" ]]; then
        if [[ $Short_Drives_Test_Delay -lt 6 ]]; then
            echo "Your $Short_Drives_Test_Delay Second Delay..."
        else
            echo "Your $Short_Drives_Test_Delay Second Delay, Please Standby..."
        fi
    fi
    ) >> /tmp/drive_selftest/drive_test_temp.txt
fi

# IF LOGGING ENABLED, WRITE THE THREE FILES
if [[ $Enable_Logging == "enable" ]]; then
    if [[ $Demo == "true" ]]; then
        echo " "
        echo "Saving Log (file name: $LOG_DIR/drive_selftest_demo_${today_day#0}.txt)" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        cat /tmp/drive_selftest/drive_test_temp.txt > $LOG_DIR/drive_selftest_demo_${today_day#0}.txt
    else
        if [[ $Silent != "enable" ]]; then
            echo "Saving Log (file name: $LOG_DIR/drive_selftest_${today_day}.txt)" | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo "Exiting Joe's SMART Drive Self-test Script" >> /tmp/drive_selftest/drive_test_temp.txt
            cat /tmp/drive_selftest/drive_test_temp.txt > $LOG_DIR/drive_selftest_${today_day#0}.txt
        else
            echo "Saving Log (file name: $LOG_DIR/drive_test_${today_day}.txt)" >> /tmp/drive_selftest/drive_test_temp.txt
            echo "Exiting Joe's SMART Drive Self-test Script" >> /tmp/drive_selftest/drive_test_temp.txt
            cat /tmp/drive_selftest/drive_test_temp.txt > $LOG_DIR/drive_selftest_${today_day#0}.txt
        fi
    fi
    if [[ $timer_flag -eq 1 ]]; then
        echo "Exiting Joe's SMART Drive Self-test Script" >> /tmp/drive_selftest/drive_test_timer_temp.txt
        cat /tmp/drive_selftest/drive_test_timer_temp.txt > $LOG_DIR/drive_selftest_timer_${today_day#0}.txt
    fi
fi

# Leave "/tmp/smartdrive_selftest_text.txt" for Multi-Report
# Delete everything else
if test -e "/tmp/drive_selftest"; then rm -R "/tmp/drive_selftest"; fi
if test -e "/tmp/Multi-Report/drive_selftest.txt"; then rm /tmp/Multi-Report/drive_selftest.txt; fi

if [[ $No_Tests == "true" ]]; then
    if [[ $Demo == "true" ]]; then
        echo "SIMULATION: "$Short_Drives_Test_Delay" second timer skipped."
    fi
else
	echo "Zzzz..."
    sleep $Short_Drives_Test_Delay            # Sleep XXX seconds to wait for Short tests to complete before returning to controlling procedure.
fi
if [[ $Silent == "enable" ]]; then
	echo " "
fi
	echo "Exiting Joe's SMART Drive Self-test Script"

exit 0