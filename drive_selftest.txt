#!/bin/bash

LANG="en_US.UTF-8"
if [[ $TERM == "dumb" ]]; then          # Set a terminal as the script may generate an error message if using 'dumb'.
    export TERM=unknown
fi
##### Version 1.06

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

### FILE NAME SHOULD BE 'drive_selftest.sh' TO INTEGRATE WITH MULTI-REPORT
###
### MULTIPLE DRIVE SMART SELF-TEST SCRIPT (TO EASE YOUR CONFIGURATION NEEDS)
###    
### WHAT DOES THIS SCRIPT DO?
###
### THIS SCRIPT WAS ORIGINALLY DESIGNED FOR PEOPLE WHO HAVE A LOT OF DRIVES AND
### DO NOT WANT TO SCHEDULE EACH DRIVE INDIVIDUALLY FOR SMART TESTING.
### ADDITIONALLY THIS CAN BE USED WITH MULTI-REPORT 3.1 OR LATER TO RUN SMART TESTS
### AND UTILIZE THE MULTI-REPORT CONFIGURATION FILE IF DESIRED.
###        
### THIS SCRIPT WILL SPREAD OUT THE SMART SHORT AND LONG/EXTENDED TESTING IN THREE
### POSSIBLE WAYS, INCLUDING THE OPTION TO NOT TEST AT ALL:
###  1. SPREAD ACROSS A WEEK (ON SPECIFIED DAYS OF THE WEEK)
###  2. SPREAD ACROSS A MONTH (ON SPECIFIED DAYS OF THE WEEK)
###  3. ALL DRIVES (ON SPECIFIED DAYS OF THE WEEK)
###  4. OR NO DRIVES AT ALL
### SPECIFIED DAYS OF THE WEEK ARE: 1=MON, 2=TUE, 3=WED, 4=THU, 5=FRI, 6=SAT, 7=SUN.
###
### THESE ARE BROKEN DOWN INTO SHORT TESTS AND LONG TESTS.
### THE DRIVES CAN BE TESTED IN DRIVE NAME (ID) ORDER (ADA0, ADA1, OR SDA, SDB) OR
### SORTED BY SERIAL NUMBER (A POOR MANS CRAPPY METHOD TO SIMULATE RANDOMIZATION OF DRIVES TO REDUCE DRIVES
### BEING TESTED IN THE SAME DRIVE CAGE TO REDUCE POWER DRAW AND HEAT, AND IT MAY NOT REALLY WORK THAT WAY)
###
### THE DEFAULT SETTINGS ARE:
###    1. DAILY SHORT TESTS ON EACH DRIVE (TEST MODE 2)
###       -SORTED BY DRIVE NAME/ID, ALL DRIVES TESTED EVERY DAY, RUNS 7 DAYS A WEEK
###    2. MONTHLY LONG TESTS ON EACH DRIVE (TEST MODE 1, MONTHLY)
###       -SORTED BY SERIAL NUMBER, ONE DRIVE A DAY, ONE TEST PER MONTH, RUNS 7 DAYS A WEEK
###    3. LOGGING ENABLED
###    4. SCRUB/RESILVER TIME REMAINING OVER 3 HOURS WILL RUN A SHORT TEST VICE LONG TEST.
###
### READ THE USER GUIDE AND CONFIGURATION SECTION BELOW, MAKE CHANGES AS DESIRED.
###
### A LOG FILE BY DEFAULT IS CREATED IN THE SCRIPT DIRECTORY, ONE FOR EACH DAY
### OF THE MONTH.  IT WILL OVERWRITE ONCE A NEW MONTH STARTS.
###
### IF YOU ALREADY HAVE SMART TESTING FOR A DAILY SMART SHORT TEST THEN YOU CAN SET
### TEST MODE 3 FOR SHORT TESTS TO MITIGATE DUPLICATE TESTING.
###
### IF YOU HAVE ALL YOUR DRIVES SETUP IN TRUENAS EXCEPT NVME, THERE IS AN OPTION TO RUN NVME ONLY.
###
### USE [-help] FOR ADDITIONAL INFORMATION

# Change Log
#
# Version 1.06 (18 September 2025)
#
# - Basic Ubuntu support - can potentially support other Linux based OS' as well, needs testing
#
# Version 1.05 (07 June 2025)
#
# - Updated the smartctl interface connection to roll through several more variations if the default fails to work.
#   ---- This did impact a few people but it has been fixed now. This also "should" open up options for USB connected devices.
# - Added '--scan' output to a file for data collection.
# - Updated Debugging Data for Troubleshooting and analysis.
# - Updated '-help' information.
# - Fixed potential drive not being Long tested if it had a similar name to a Short test drive (da1 and da11 was the noted problem).
# - Updated Debug to be enabled during a Multi-report -dump switch.
# - Added RESILVER/SCRUB Override for SMART Long tests (by request).
# - Converted options from 'true/false' to 'enable/disable' to make more sense.
# - Fixed reading the multi_report_config.txt file earlier in the script execution.
#
#  Thanks go out to @SD for helping with the script.  It is good to have a different set of eyes looking at things.
#

# Version 1.04 (22 February 2025)
#
# - Added checking for SCRUB and RESILVER and run SMART LONG/SHORT tests appropriately. Default = No SMART Long Testing during SCRUB/RESILVER operations.
# - Updated the 'Silent' function to ONLY display really important information only, such as a failure or an update is available.
# - Improved the Update/Automatic Update feature.
# - Removed erroneous 'Month' messages
# - Improved 'demo' Mode

# Version 1.03 (26 January 2025)
#
# - Added Test NVMe Drives Only option (by request).
# - Improved the Update feature.
# - Streamlined the CRON JOB output a bit.
#

# Version 1.02 (16 January 2025)
#
# 27 December - Addressed invalid drives for SMART testing.
# 10 January  - Finished no sleep if no tests.
#
# Initial Release Version 1.0 (10 January 2025)
#


######################## USER SETTINGS ########################

###### NEW SCRIPT TO TEST LOTS OF DRIVES ######
###                                         ###
###          THESE ARE FUNCTIONAL           ###
###         MAKE YOUR CHANGES HERE          ###
###          THESE ARE OVERRIDDEN           ###
###      BY MULTI_REPORT_CONFIG.TXT         ###
###                                         ###
###############################################

### EXTERNAL CONFIGURATION FILE
Config_File_Name=$SCRIPT_DIR"/multi_report_config.txt"
Use_multi_report_config_values="enable"       # A "enable" value here will use the $Config_File_Name file values to override the values defined below, if it exists.
                                            #  This allows the values to be retained between versions.  A "disable" will not allow the external config file to be
                                            #  used regardless of any other settings and therefore would utilize the values below. Default="true"

###### SCRIPT UPDATES
Check_For_Updates="enable"                  # This will check to see if an update is available. Default="enable"
Automatic_Selftest_Update="disable"         # WARNING !!!  This option will automatically update the Drive_Selftest script if a newer version exists on GitHub
                                            #  with no user interaction. Default = "disable"
											
##### SMARTCTL_Interface_Options			# This variable is used to attempt to account for drives not easily accessable.
SMARTCTL_Interface_Options="auto,sat,atacam,scsi,nvme"

###### HDD/SSD/NVMe SMART Testing
Test_ONLY_NVMe_Drives="disable"             # This option when set to "enable" will only test NVMe drives, HDD/SSD will not be tested. Default = "disable"
SCRUB_Minutes_Remaining=0                   # This option when set between 1 and 9999 (in minutes) will not run a SMART LONG test if a SCRUB has longer than xx minutes
                                            #  remaining, and a SMART SHORT test will be run instead to provide minimal impact to the SCRUB operation.
                                            #  A value of 0 (zero) will disable all SMART test(s) during a SCRUB operation.  Default=0 (Disabled).
                                            #  NOTE: Any RESILVER operation automatically cancels SMART testing to put priority on rebuilding the pool.

SCRUB_RESILVER_OVERRIDE="disable"			# This option will allow all SCRUB actions to occur regardless of the SCRUB_Minutes_Remaining variable
# NEED TO MAKE WORK!!!!						# meaning that if a SCRUB or a RESILVER is in progress, any given SMART testing will be performed.
											# I personally do not advise enabling this option but someone asked for it, here it is.
											
### SHORT SETTINGS
Short_Test_Mode=2                           # 1 = Use Short_Drives_to_Test_Per_Day value, 2 = All Drives Tested (Ignores other options), 3 = No Drives Tested.
Short_Time_Delay_Between_Drives=1           # Tests will have a XX second delay between the drives starting testing. If drives are always spinning, this can be "0".
Short_SMART_Testing_Order="DriveID"         # Test order is for Test Mode 1 ONLY, select "Serial" or "DriveID" for sort order.  Default = "Serial"
Short_Drives_to_Test_Per_Day=1              # For Test_Mode 1) How many drives to run each day minimum?
Short_Drives_Test_Period="Week"             # "Week" (7 days) or "Month" (28 days)
Short_Drives_Tested_Days_of_the_Week="1,2,3,4,5,6,7"    # Days of the week to run, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun.  # This takes over for number of days variable.
Short_Drives_Test_Delay=30                  # How long to delay when running Short tests, before exiting to controlling procedure.  Default is 130 second should allow.
                                            # Short tests to complete before continuing.  If using without Multi-Report, set this value to 1.

### LONG SETTINGS
Long_Test_Mode=1                            # 1 = Use Long_Drives_to_Test_Per_Day value, 2 = All Drives Tested (Ignores other options), 3 = No Drives Tested.
Long_Time_Delay_Between_Drives=1            # Tests will have a XX second delay between the drives starting the next test.
Long_SMART_Testing_Order="Serial"           # Test order is either "Serial" or "DriveID".  Default = 'Serial'
Long_Drives_to_Test_Per_Day=1               # For Test_Mode 1) How many drives to run each day minimum?
Long_Drives_Test_Period="Week"             # "Week" (7 days) or "Month" (28 days)
Long_Drives_Tested_Days_of_the_Week="1,2,3,4,5,6,7"     # Days of the week to run, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun. # This takes over for number of days variable.


### IGNORE DRIVES LIST
# IF YOU HAVE A DRIVE THAT YOU DO NOT WANT THIS SCRIPT TO TOUCH (RUN ANY TESTS ON), THEN INCLUDE THE DRIVE SERIAL NUMBER
# IN THE LIST.  IF THE SERIAL NUMBER MATCHES THEN THE DRIVE IS REMOVED FROM TESTING. BELOW IS AN EXAMPLE.
# Example:  Ignore_Drives_List="RQTY4D78E,JJ6XTZ,OU812,ZR13JRL"
Ignore_Drives_List=""

### REPORT
Drive_List_Length=10                        # This is how many drive IDs to list per line.  Default is 10.
Enable_Logging="enable"                       # This will create a text file named "drive_test_xx.txt". Run -clearlog
LOG_DIR=$SCRIPT_DIR"/DS_Logs"               # The default log directory is the script directory.
Silent="disable"                               # When "enable" only error messages will be output to the stdout.

#######################################
#######################################
###                                 ###
###  STOP EDITING THE SCRIPT HERE   ###
###     DO NOT CHANGE ANYTHING      ###
###        BELOW THIS LINE          ###
###                                 ###
#######################################
#######################################

###### DEBUG SECTION ######
# DEBUG is to be used to display extra operational data for troubleshooting the script.
# I do not recommend people play with anything here.

Debug="false"            # Default = "false"
Debug_Steps="false"		# Default = "false"
simulated_drives=0      # Set to '0' to use actual drives, or to any number to use simulated drives (the Serial option will not work)

###### Auto-generated Parameters
softver=$(uname -s)

# Check if the OS is FreeBSD (TrueNAS Core or FreeNAS)
if [[ "$softver" == "FreeBSD" ]]; then
  if [[ "$(cat /etc/version | grep "FreeNAS")" ]]; then
    programver="FreeNAS "$(cat /etc/version | cut -d " " -f1 | sed 's/FreeNAS-//')
    programver3="$(cat /etc/version | cut -d " " -f1 | sed 's/FreeNAS-//' | cut -d "." -f1)"
    programver4="$(cat /etc/version | cut -d "." -f2 | cut -c1)"
  else
    programver="TrueNAS Core "$(cat /etc/version | cut -d " " -f1 | sed 's/TrueNAS-//')
    programver3="$(cat /etc/version | cut -d " " -f1 | sed 's/TrueNAS-//' | cut -d "." -f1)"
    programver4="$(cat /etc/version | cut -d "." -f2 | cut -c1)"
  fi
# Check if the OS is Linux (TrueNAS Scale or Ubuntu)
elif [[ "$softver" == "Linux" ]]; then
  if [[ -f "/etc/os-release" ]]; then
    . /etc/os-release
    # Check specifically for TrueNAS Scale
    if [[ "$ID" == "truenas" ]]; then
      programver="TrueNAS Scale "$(cat /etc/version)
      programver3="$(cat /etc/version | cut -d "." -f1)"
      programver4=6            # Using symbolic value so script works as written, just for SCALE.
    # Check for a generic Ubuntu system
    elif [[ "$ID" == "ubuntu" ]]; then
      programver="$NAME $VERSION_ID"
      major_version=$(echo "$VERSION_ID" | cut -d'.' -f1)
      minor_version=$(echo "$VERSION_ID" | cut -d'.' -f2)
      programver3=$((major_version + 0))
      programver4=$((minor_version + 0))
    else
      echo "This script is not designed to run on this specific Linux distribution."
      exit 1
    fi
  else
    echo "Could not find /etc/os-release. This script may not run correctly on this system."
    exit 1
  fi
else
  echo "This script is not designed to run on a non-FreeBSD or non-Linux distribution."
  exit 1
fi

programver3=$(( programver3 + 0 ))        # Make Base 10
programver4=$(( programver4 + 0 ))

# Ensure OS / version is correct
echo "Detected OS: $programver"
echo "Major Version: $programver3"
echo "Minor Version: $programver4"

Program_Name="drive_selftest.sh"
Version="1.05"                            # Current version of the script
Version_Date="(07 June 2025)"

# GLOBAL VARIABLES - MUST BE DEFINED EARLY BEFORE FUNCTION TO BE GLOBAL
Drive_Disk_Query=""
smartdrives=""
selftest_drives=""
drives_name=""
drives_serial=""
drives_subsystem=""
driveConnectionType="auto"
Demo="false"
IFS_RESTORE=$IFS
selftest_drives_short=""
selftest_drives_long=""
Ready_to_Test="false"
start_time_display=""
end_time_display=""
end_tenths=""
NVMe_Override_Enabled=""
Short_Drives_Testing=""
Long_Drives_Testing=""
No_Tests="true"
SCRUB_In_Progress="false"


if [[ $softver != "Linux" ]]; then
    DOW=$(date '+%u')                          # Todays Day of the Week, 1=Mon, 7=Sun
    Full_Month_Name=$(date '+%B')              # Full name of current month
else
    DOW=$(date +%u)                            # Todays Day of the Week, 1=Mon, 7=Sun
    Full_Month_Name=$(date +%B)                # Full name of current month
fi
today_day=$(date +%d)

# Get Smartmontools version number 
smart_ver=$(smartctl | grep "7." | cut -d " " -f 2)

# Get all drive(s) interface data
smartctlscan=$(smartctl --scan-open)


##########################
##########################
###                    ###
###  DEFINE FUNCTIONS  ###
###                    ###
##########################
##########################

checkforupdate () {
if [[ $Debug_Steps == "true" ]]; then echo "checkforupdate" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    echo " "
    echo "Checking for Updates"
    if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi

    if [[ "$(curl -is https://github.com | head -n 1)" ]]; then
        (
            cd /tmp
            if ! test -e "Multi-Report"; then
                mkdir Multi-Report
            fi
            cd Multi-Report
            curl -LJOs https://raw.githubusercontent.com/JoeSchmuck/Multi-Report/refs/heads/main/drive_selftest.txt            
        )    
        if test -e "/tmp/Multi-Report/drive_selftest.txt"; then
            GitDriveVersion=$(cat "/tmp/Multi-Report/drive_selftest.txt" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)
            GitDriveMajorVersionNumber="$(echo $GitDriveVersion | cut -d '.' -f1)"
            GitDriveMinorVersionNumber="$(echo $GitDriveVersion | cut -d '.' -f2)"
            convert_to_decimal $GitDriveMajorVersionNumber
            GitDriveMajorVersionNumber=$Return_Value
            convert_to_decimal $GitDriveMinorVersionNumber
            GitDriveMinorVersionNumber=$Return_Value
            if test -e $SCRIPT_DIR"/drive_selftest.sh"; then
                LocalDriveFilename="$(cat $SCRIPT_DIR"/drive_selftest.sh" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)"
                LocalMajorDriveVersionFilename="$(echo $LocalDriveFilename | cut -d '.' -f1)"
                LocalMinorDriveVersionFilename="$(echo $LocalDriveFilename | cut -d '.' -f2)"
                convert_to_decimal $LocalMajorDriveVersionFilename
                LocalMajorDriveVersionFilename=$Return_Value
                convert_to_decimal $LocalMinorDriveVersionFilename
                LocalMinorDriveVersionFilename=$Return_Value
            else
                LocalDriveFilename="Nothing Is Here"
            fi
            Drive_Updated="AVAILABLE: V"$LocalDriveFilename
            echo -n "    Drive_Selftest - Installed: "$LocalDriveFilename", GitHub: "$GitDriveVersion
            if [[ $GitDriveMajorVersionNumber -gt $LocalMajorDriveVersionFilename ]] && [[ $LocalDriveFilename != "" ]]; then
                echo " - Major Update"
                UpdateDriveAvailable="true"
                rm /tmp/Multi-Report/drive_selftest.txt
            elif [[ $GitDriveMajorVersionNumber -eq $LocalMajorDriveVersionFilename ]] && [[ $GitDriveMinorVersionNumber -gt $LocalMinorDriveVersionFilename ]]; then
                UpdateDriveAvailable="true"
                echo " - Minor Update"
                rm /tmp/Multi-Report/drive_selftest.txt
            else
                echo " - No Update"
            fi        
            if [[ $Automatic_Selftest_Update == "enable" ]] && [[ $UpdateDriveAvailable == "true" ]]; then
                echo "     Automatic Update Enabled"
                update_Drive_script
            fi                    
        else
            echo "No GitHub Version File Available"
        fi
    fi

    if [[ $UpdateDriveAvailable == "true" ]]; then
        echo " "
        echo "################################################################################"
        echo "#   An Update is Available -- Use the '-update' switch to update the script.   #"
        echo "################################################################################"        
    fi
    echo " "

    }

    update_Drive_script () {
	if [[ $Debug_Steps == "true" ]]; then echo "update_Drive_script" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    echo "Update Script Routine"
    echo "Removing Old Local Script if it exists"
    if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi
    echo "Downloading new script files"
    if [[ "$(curl -is https://github.com | head -n 1)" ]]; then
        # Go git the file
        ( mkdir /tmp/Multi-Report
        cd /tmp/Multi-Report
        curl -LJOs https://raw.githubusercontent.com/JoeSchmuck/Multi-Report/refs/heads/main/drive_selftest.txt
        curl -LJOs https://raw.githubusercontent.com/JoeSchmuck/Multi-Report/refs/heads/main/Drive_Selftest_User_Guide.pdf
        )
        GitDriveVersion=$(cat "/tmp/Multi-Report/drive_selftest.txt" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)
        LocalDriveFilename=$(cat $SCRIPT_DIR"/drive_selftest.sh" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)
        echo " "
        echo "      - Drive_Selftest current version is: "$LocalDriveFilename
        echo "      - The Github version is: "$GitDriveVersion
        echo " "

        if [[ $Automatic_Selftest_Update != "enable" ]]; then
            echo "Enter 'y' to commit or any other key to abort."
            read Keyboard_yn
        else
            echo "Automatic Update is Enabled..."
            Keyboard_yn="y"
        fi
        if [[ $Keyboard_yn == "y" ]] || [[ $Keyboard_yn == "Y" ]]; then
            echo "Updating Script..."

            # Copy the new multi_report.sh file and set permissions
            cp /tmp/Multi-Report/drive_selftest.txt $SCRIPT_DIR"/drive_selftest.sh"
            chmod 755 $SCRIPT_DIR"/drive_selftest.sh" > /dev/null 2<&1

            # Copy the User Guide
            cp "/tmp/Multi-Report/Drive_Selftest_User_Guide.pdf" $SCRIPT_DIR"/."
            echo " "
            echo "Your script has been updated and a copy of the User Guide and changelog is in your directory."
            UpdateDriveAvailable="false"        # Remove this after the update has completed.
        else
            echo "Aborted"
            exit 1
        fi
        # Cleanup Leftover Files
        if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi
    else
        echo "GitHub is Not Available"
    fi
    if [[ $Automatic_Selftest_Update != "enable" ]]; then 
        echo "Exiting..."
        exit 0
    fi

    }

convert_to_decimal () {
	if [[ $Debug_Steps == "true" ]]; then echo "convert_to_decimal: $1" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    if [[ "$1" == "" ]]; then return; fi
    Converting_Value=${1#0}
    Converting_Value="${Converting_Value//,}"
    Return_Value=$Converting_Value
    if [[ $1 == "0" ]]; then Return_Value=0; fi

    }

check_scrub () {
	if [[ $Debug_Steps == "true" ]]; then echo "check_scrub" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    # Check if a SCRUB or RESILVER is in progress and if if so, how much time remains.
    # If greater than $SCRUB_Minutes_Remaining then we will not run a SMART Long test, we substitute it with a Short test.
	if [[ "$softver" == "Linux" ]] && [[ "$ID" == "ubuntu" ]]; then
        # Ubuntu specific code using zpool commands
        zpool_list=$(zpool list -H | cut -f1)

		while IFS= read -r pool; do
            # Get pool status and scrub info
            pool_status=$(zpool status "$pool")
			if [[ $Debug == "true" ]]; then
				echo "Debug: Pool Status for $pool"
			fi
            
            # Check for RESILVER
            if echo "$pool_status" | grep -q "resilver in progress"; then
                SCRUB_Minutes_Remaining=0
                SCRUB_In_Progress="true"
                Function="RESILVER"
                Function_Time_Left=$(echo "$pool_status" | grep "scan:" | grep -o '[0-9]\+:[0-9]\+:[0-9]\+' | tail -1)
                # Convert HH:MM:SS to minutes
                IFS=: read -r hours minutes seconds <<< "$Function_Time_Left"
                Function_Time_Left=$((hours * 3600 + minutes * 60 + seconds))
            # Check for SCRUB
            elif echo "$pool_status" | grep -q "scrub in progress"; then
                SCRUB_In_Progress="true"
                Function="SCRUB"
                Function_Time_Left=$(echo "$pool_status" | grep "scan:" | grep -o '[0-9]\+:[0-9]\+:[0-9]\+' | tail -1)
                # Convert HH:MM:SS to minutes
                IFS=: read -r hours minutes seconds <<< "$Function_Time_Left"
                Function_Time_Left=$((hours * 3600 + minutes * 60 + seconds))
            fi

            if [[ $SCRUB_In_Progress == "true" ]]; then
                Function_Time_Left_Min=$((Function_Time_Left / 60))    # Seconds to Minutes
                Function_Time_Left_Hour=$((Function_Time_Left_Min * 10))   # *10 due to rounding the hours
                Function_Time_Left_Whole0=$((Function_Time_Left_Hour / 60))
                Function_Time_Left_Whole1=$((Function_Time_Left_Whole0 / 10))
                Function_Time_Left_Fraction=$((Function_Time_Left_Whole0 - $((Function_Time_Left_Whole1 * 10))))

                if [[ $SCRUB_Minutes_Remaining -gt 0 ]]; then
                    if [[ $Function_Time_Left_Min -gt $SCRUB_Minutes_Remaining ]]; then
                        echo "  Pool: $pool" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        if [[ $Function_Time_Left_Min -gt 59 ]]; then
                            echo "  $Function In Progress: ~$Function_Time_Left_Whole1.$Function_Time_Left_Fraction Hours remain. " | tee -a /tmp/drive_selftest/drive_test_temp.txt
                            echo "  The $Function remaining time exceeds $SCRUB_Minutes_Remaining minutes, running SMART SHORT tests vice any pending LONG tests." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        else
                            echo "$Function In Progress: $Function_Time_Left minutes remain." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        fi
                    else
                        echo "  Pool: $pool" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        echo "  $Function In Progress: ~$Function_Time_Left_Whole1.$Function_Time_Left_Fraction Hours remain. " | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        echo "  The $Function remaining time is less than $SCRUB_Minutes_Remaining minutes, running all SMART tests as planned." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                else
                    echo "  Pool: $pool" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    echo "  $Function In Progress: ~$Function_Time_Left_Whole1.$Function_Time_Left_Fraction Hours remain. " | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    echo "  SMART testing disabled during $Function." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    # Lets cancel all testing.
                    Short_Test_Mode=0
                    Long_Test_Mode=0
                fi
            fi
        done <<< "$zpool_list"
	else
		for i in {0..100}; do            # ARE WE REALLY GOING TO SEE 100 POOLS, well just in case?  THIS IS NOT THE ID NUMBER
			Function_Pool_Name=$(midclt call pool.query | jq -r '.['$i'].name')
			Function_temp=$(midclt call pool.query | jq -r '.['$i'].scan.function')
			Function_Time_Left=$(midclt call pool.query | jq -r '.['$i'].scan.total_secs_left')

			if [[ $Function_temp == "null" ]]; then
				break
			else
				Function=$Function_temp
			fi
			
			if [[ $Function == "RESILVER" ]]; then SCRUB_Minutes_Remaining=0; SCRUB_In_Progress="true"; fi
			if [[ $Function == "SCRUB" ]] || [[ $Function == "RESILVER" ]]; then
				if [[ $Function_Time_Left != "null" ]]; then         # We should have a number, lets convert it to hours.
					SCRUB_In_Progress="true"
					Function_Time_Left_Min=$((Function_Time_Left / 60))    # Seconds to Minutes
					Function_Time_Left_Hour=$((Function_Time_Left_Min * 10 ))   # *10 due to rounding the hours
					Function_Time_Left_Whole0=$((Function_Time_Left_Hour / 60))
					Function_Time_Left_Whole1=$((Function_Time_Left_Whole0 / 10))
					Function_Time_Left_Fraction=$((Function_Time_Left_Whole0 - $((Function_Time_Left_Whole1 * 10 ))))
					if [[ $SCRUB_Minutes_Remaining -gt 0 ]]; then
						if [[ $Function_Time_Left_Min -gt $SCRUB_Minutes_Remaining ]]; then        # SCRUB Too Long
							echo "  Pool: "$Function_Pool_Name | tee -a /tmp/drive_selftest/drive_test_temp.txt
							if [[ $Function_Time_Left_Min -gt 59 ]]; then    # JUST TO FORMAT TIME CORRECTLY
								# OVER 1 HOUR
								echo "  "$Function" In Progress: ~"$Function_Time_Left_Whole1"."$Function_Time_Left_Fraction" Hours remain. " | tee -a /tmp/drive_selftest/drive_test_temp.txt
								echo "  The "$Function" remaining time exceeds "$SCRUB_Minutes_Remaining" minutes, running SMART SHORT tests vice any pending LONG tests." | tee -a /tmp/drive_selftest/drive_test_temp.txt
							else
								# LESS THAN 1 HOUR
								echo $Function" In Progress: "$Function_Time_Left" minutes remain." | tee -a /tmp/drive_selftest/drive_test_temp.txt
							fi
						else
							# LESS THAN MAX TIME - WE CAN RUN A LONG TEST
							echo "  Pool: "$Function_Pool_Name | tee -a /tmp/drive_selftest/drive_test_temp.txt
							echo "  "$Function" In Progress: ~"$Function_Time_Left_Whole1"."$Function_Time_Left_Fraction" Hours remain. " | tee -a /tmp/drive_selftest/drive_test_temp.txt
							echo "  The "$Function" remaining time is less than "$SCRUB_Minutes_Remaining" minutes, running all SMART tests as planned." | tee -a /tmp/drive_selftest/drive_test_temp.txt
						fi
					else
						# SCRUB/RESILVER IN PROGRESS - NO SMART TESTING AT ALL
						echo "  Pool: "$Function_Pool_Name | tee -a /tmp/drive_selftest/drive_test_temp.txt
						echo "  "$Function" In Progress: ~"$Function_Time_Left_Whole1"."$Function_Time_Left_Fraction" Hours remain. " | tee -a /tmp/drive_selftest/drive_test_temp.txt
						echo "  SMART testing disabled during "$Function"." | tee -a /tmp/drive_selftest/drive_test_temp.txt
						# Lets cancel all testing.
						Short_Test_Mode=0
						Long_Test_Mode=0
					fi
				fi
			elif [[ $Function == "null" ]]; then    # We exit, no more pools in the list.
				break
			fi
		done
	fi
    }

remove_duplicate_tests () {
	if [[ $Debug_Steps == "true" ]]; then echo "remove_duplicate_tests" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# THIS WILL COMPARE BOTH SHORT AND LONG TESTS AND REMOVE DUPLICATE SHORT TESTS FROM THE TESTING LIST.
# NEXT TIME LETS FIGURE OUT THE LONG TESTS FIRST, THEN FIGURE OUT THE SHORT TESTS AND IF ONE IS LISTED IN THE LONG TESTS LIST, REMOVE IT.

# Global Variables: selftest_drives_short, selftest_drives_long

# Local Variables: s_drives, short_modified_drives
    (echo "            "$start_time_display":  START remove_duplicate_tests"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    for s_drives in $selftest_drives_short ; do                     # Loop through all the Long drives to test
		test=0
        # Lets remove any matches to the short drive list.
		for l_drives in $selftest_drives_long ; do
			if [[ "$l_drives" == "$s_drives" ]]; then test=1; fi
		done
		if [[ $test == 1 ]]; then     # This drive should be removed from teh SHORT test list.
			if [[ $reduced_drives_display == "" ]]; then            # We are creating a list of drives being removed for display only purposes.
				reduced_drives_display=$s_drives                            # We are formatting the display to look nice in this IF statement.
			else
				reduced_drives_display=$reduced_drives_display" "$s_drives
			fi

		else                                                        # ELSE we create a new list of Short drives to test, if any.
			if [[ $short_modified_drives == "" ]]; then short_modified_drives=$s_drives; else short_modified_drives=$short_modified_drives" "$s_drives; fi
		fi
    done
	
    Moved_Long_Scrub=$selftest_drives_long
    # Move from LONG to SHORT During a SCRUB
    if [[ $SCRUB_In_Progress == "true" ]]; then
        for l_drives in $selftest_drives_long ; do                     # Loop through all the Long drives to test
            if [[ $SCRUB_Minutes_Remaining -gt 0 ]]; then
                short_modified_drives=$short_modified_drives" "$l_drives
            fi
        done
            selftest_drives_long=""
    fi

    if [[ $s_drives != "" ]] && [[ $SCRUB_In_Progress != "true" ]]; then
        if [[ $(wc -c <<< "$reduced_drives_display" | xargs) -gt 2 ]]; then
            if [[ $Silent != "enable" ]]; then
                (echo '    Drive(s): "'$reduced_drives_display'" were removed from the Short testing schedule for today.'
                echo '    The drive(s) are already scheduled today for the Long test.'
                echo " " ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
        fi
    fi
    selftest_drives_short=$short_modified_drives
    selftest_drives=$selftest_drives_short

    if ! [[ $selftest_drives == "" ]]; then
        if [[ $Silent != "enable" ]]; then
            if [[ $SCRUB_In_Progress == "true" ]]; then
                echo "RUNNING SHORT TEST: "$selftest_drives", '"$Moved_Long_Scrub"' moved from LONG TEST due to SCRUB." | tee -a /tmp/drive_selftest/drive_test_temp.txt
            else
                echo "RUNNING SHORT TEST: "$selftest_drives | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
        fi
        run_smart_test Short
        Short_Drives_Testing=$selftest_drives
    else
        if [[ $Silent != "enable" ]]; then
            (echo " "
            echo "NO SHORT TESTS TO RUN"$selftest_drives ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
    fi
	
    selftest_drives=$selftest_drives_long
    echo " "
    if [[ $(wc -c <<< "$selftest_drives" | xargs) -gt 2 ]]; then
        if [[ $Silent != "enable" ]]; then
            echo "RUNNING LONG TEST: $selftest_drives" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        echo "            RUNNING LONG TEST: $selftest_drives" >> /tmp/drive_selftest/drive_test_timer_temp.txt
        run_smart_test Long
        Long_Drives_Testing=$selftest_drives
    else
        if [[ $Silent != "enable" ]]; then
            echo "NO LONG TESTS TO RUN" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        (echo "            NO LONG TESTS TO RUN"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    fi

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT remove_duplicate_tests"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
    if [[ $end_tenths != "" ]]; then
        echo ".$end_tenths seconds elapsed."
    else
        echo " seconds elapsed."
    fi
    echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }

# CALLED FROM ONE LOCATION
run_smart_test () {
	if [[ $Debug_Steps == "true" ]]; then echo "run_smart_test" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# This will check if a SMART test is currently running and if yes, display the progress.
# If no SMART test is running then attempt to execute the test.
#
# Required variables: $1=Test Type (Short/Long)
# Global Variables: Drive_Disk_Query, smart_ver, selftest_drives, Demo, Time_Delay_Between_Drives, Debug, drive, smartctlscan
#
# Local Variables: drive, API_BUS, smart_test_ok, test_it, driveConnectionType, drive_connection_types, api_s
#
# Calls nvm_selftest

    (echo "                "$start_time_display":  START run_smart_test"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    test_running=0
    if ! test -e "/tmp/drive_selftest/smartctl_scan_results.txt"; then
        smartctl --scan > /tmp/drive_selftest/smartctl_scan_results.txt
    fi
    for drive in $selftest_drives; do
        api_s=0
		in_test=0
        until [[ "$(echo $Drive_Disk_Query | jq -r '.['$api_s'].name')" == "null" ]] || [[ "$(echo $Drive_Disk_Query | jq -r '.['$api_s'].name')" == *"$drive"* ]]; do (( api_s ++)); done
        API_BUS=$(echo $Drive_Disk_Query | jq -r '.['$api_s'].subsystem')
		API_SERIAL=$(echo $Drive_Disk_Query | jq -r '.['$api_s'].serial')
        drive_connection_types="none$(echo "$smartctlscan" | grep -i "$drive" | awk '{printf ","; printf $3}'),$SMARTCTL_Interface_Options"
		driveConnectionType=$(echo "$smartctlscan" | grep -i "$drive" | awk '{printf $3}')
        if [[ $Debug == "true" ]]; then echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
        if [[ $Debug == "true" ]]; then echo "    Debug - 'Drive ID=$drive', 'Drive S/N=${API_SERIAL}', 'SMARTCTL Interface Type=$driveConnectionType', 'API BUS=$API_BUS'" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi

        if [[ $programver3 -lt 24 ]] && [[ $programver4 -lt 3 ]] && [[ $drive == *"nvm"* ]]; then     # If less than TrueNAS 24 and nvme drive, use low level nvme commands.
            nvm_selftest $1 $drive
            No_Tests="false"
        else                                        # If smartmontool is 7.4 or greater, Time to try and run a SMART test using smartmontools for nvme.
            IFS_RESTORE=$IFS
            IFS=","
            for dr in $drive_connection_types; do
                if [[ $dr == "none" ]]; then
                    driveConnectionType=$dr
                    # No interface parameter passed
                    if [[ $1 == "Short" ]]; then
                        smart_test_ok="$(smartctl -t short /dev/$drive)"
                    else
                        smart_test_ok="$(smartctl -t long /dev/$drive)"
                    fi
                    smartresult=$?
                    if [[ $smartresult -eq 0 ]]; then   # Exit code of 0 is good, command accepted.
                        if [[ $Silent != "enable" ]]; then
                            echo "SMART command for drive:"$drive" was received okay, return exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        fi
						in_test=1
                        break 1   # Return to the FOR loop
					elif [[ $smartresult -eq 4 ]]; then		# Exit code of 4 could mean the command was accepted but the drive was busy or the command was not accepted.
						# Check to see if test is running before assuming exit code 4 is a bust.
						if echo $smart_test_ok | grep -i -e "remaining" -e "completed" > /dev/null 2<&1; then
							in_test=1
							break 1		# Jump out of the FOR loop
						fi
                    else
                        echo "SMART command for drive:"$drive" was not good, returned exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        echo "Lets try a different interface type..." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                else		# It looks like we need an interface modifier
                    driveConnectionType=$dr
                    if [[ $1 == "Short" ]]; then
                        smart_test_ok="$(smartctl -d "${driveConnectionType}" -t short /dev/$drive)"
                    else
                        smart_test_ok="$(smartctl -d "${driveConnectionType}" -t long /dev/$drive)"
                    fi
                    smartresult=$?
						
                    if [[ $smartresult -eq 0 ]]; then   # Exit code of 0 is good, command accepted.
                        if [[ $Silent != "enable" ]]; then
                            echo "SMART command -d "$driveConnectionType" for drive:"$drive" was received okay, return exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        fi
						in_test=1
                        break 1   # Return to the FOR loop
					elif [[ $smartresult -eq 4 ]]; then		# Exit code of 4 could mean the command was accepted but the drive was busy or the command was not accepted.
						# If the drive is in-test, consider the command received. 
						# Check to see if test is running before assuming exit code 4 is a bust.
						if echo $smart_test_ok | grep -i -e "remaining" -e "completed" > /dev/null 2<&1; then
							in_test=1
							break 1		# Jump out of the FOR loop
						fi						
                    else
                        if [[ $Silent != "enable" ]]; then
                            echo "SMART command -d "$driveConnectionType" for drive:"$drive" was not good, returned exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt
                            echo "Lets try a different interface type..." | tee -a /tmp/drive_selftest/drive_test_temp.txt
                        fi
                    fi
                fi
            done
			
            if [[ $in_test == 0 ]]; then echo "SMART commands exhausted for drive:"$drive", returned exit code:"$smartresult | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
            IFS=$IFS_RESTORE
 
            if echo $smart_test_ok | grep -i "has begun" > /dev/null 2<&1; then
                if [[ $Silent != "enable" ]]; then
                    echo "    Drive: $drive in $1 Test" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
                if [[ $timer_flag -eq 1 ]]; then echo "                    Drive: $drive in $1 Test"; fi >> /tmp/drive_selftest/drive_test_timer_temp.txt
                test_running=1    # Looks like the testing is in progress.
                No_Tests="false"
            else
                if [[ $timer_flag -eq 1 ]]; then echo "                    An error occurred for Drive: $drive in $1 Test."; fi >> /tmp/drive_selftest/drive_test_timer_temp.txt
                if echo $smart_test_ok | grep -i -e "remaining" -e "completed" > /dev/null 2<&1; then
                (   echo -n "    Drive $drive is still running a test: "
                    echo $smart_test_ok | grep -o -e '(..% remaining)' -e '(..% completed)') | tee -a /tmp/drive_selftest/drive_test_temp.txt
                else
                (   echo " - Drive did not accept the smartctl command."
                    echo " "
                    echo "    SMARTCTL Return Value = "$smartresult
                    echo " "
                    echo "    Here is the return message:"
                    echo $smart_test_ok
                    echo " ") | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
            fi
            test_it=1
        fi

        if [[ $Demo != "true" ]]; then
            sleep $Time_Delay_Between_Drives        # Wait DELAY seconds before running another drive.
        fi
    done

    if [[ $test_it -eq 1 ]]; then
        if [[ $1 == "Long" ]]; then
   #         sleep 1   # Wait 1 second before executing any Long tests.
            if [[ $selftest_drives != "" ]]; then
                if [[ $Silent != "enable" ]]; then
                    (echo " "
                    echo "ALL TESTS COMPLETED OR RUNNING IN BACKGROUND") | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
            fi
        fi
    fi

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "                "$end_time_display":  EXIT run_smart_test"
    echo -n "                Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }


# CALLED FROM TWO LOCATIONS
smartctl_selftest () {
	if [[ $Debug_Steps == "true" ]]; then echo "smartctl_selftest" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    # THIS WILL DIRECT COLLECTING THE DRIVE DATA BASED ON $1 (Short|Long) value.  And it will determine the drives to test each day.

    # Uses smartmontools to run the tests.

    # Global Variables: $1="Short/Long", Demo, smartdrives_sorted, 
    # Short_Test_Mode, Short_SMART_Testing_Order, Short_Drives_to_Test_Per_Day, Short_Drives_Test_Period, Short_Drives_Tested_Days_of_the_Week, Short_Time_Delay_Between_Drives
    # Long_Test_Mode, Long_SMART_Testing_Order, Long_Drives_to_Test_Per_Day, Long_Drives_Test_Period, Long_Drives_Tested_Days_of_the_Week, Long_Time_Delay_Between_Drives    

    # Local Variables: counter_simulated_drives, day_of_week, DOW_days, drives_to_test

    (echo "        "$start_time_display":  START smartctl_selftest '$1'"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    api_drive_serial_number=""
    if [[ $Demo == "true" ]]; then
        counter_simulated_drives=0
        smartdrives_sorted=""
        if [[ $simulated_drives -gt 0 ]]; then
            while [ $counter_simulated_drives -lt $simulated_drives ]; do
                smartdrives_sorted=$smartdrives_sorted" ada"$counter_simulated_drives
                (( counter_simulated_drives ++ ))
            done
            smartdrives=$smartdrives_sorted
        fi
    fi

    if [[ $1 == "" ]]; then echo "No SMART Test is defined, Error."; break ; fi        # Exit if no test is selected.

    if [[ $1 == "Short" ]]; then                                # Use Short variables
        Test_Mode=$Short_Test_Mode
        SMART_Testing_Order=$Short_SMART_Testing_Order
        Drives_to_Test_Per_Day=$Short_Drives_to_Test_Per_Day
        Drives_Test_Period=$Short_Drives_Test_Period
        Drives_Tested_Days_of_the_Week=$Short_Drives_Tested_Days_of_the_Week
        Time_Delay_Between_Drives=$Short_Time_Delay_Between_Drives
    else                                                        # Else use Long variables
        Test_Mode=$Long_Test_Mode
        SMART_Testing_Order=$Long_SMART_Testing_Order
        Drives_to_Test_Per_Day=$Long_Drives_to_Test_Per_Day
        Drives_Test_Period=$Long_Drives_Test_Period
        Drives_Tested_Days_of_the_Week=$Long_Drives_Tested_Days_of_the_Week
        Time_Delay_Between_Drives=$Long_Time_Delay_Between_Drives
    fi

    case $Test_Mode in                                          # Lets give us a title for the report.
        1)    Test_Mode_Title="${1} SMART Test on ${Drives_to_Test_Per_Day} Drive(s) Per Day"    ;;
        2)    Test_Mode_Title="${1} SMART Test All Drives"                ;;
        3)    Test_Mode_Title="No SMART Testing Selected"                ;;
    esac
    DOW_days=""
    IFS=","
    for day_of_week_test in $Drives_Tested_Days_of_the_Week; do
        case $day_of_week_test in                               # Lets give us days of the week.
            1)    day_of_week="Mon"    ;;
            2)    day_of_week="Tue"    ;;
            3)    day_of_week="Wed"    ;;
            4)    day_of_week="Thu"    ;;
            5)    day_of_week="Fri"    ;;
            6)    day_of_week="Sat"    ;;
            7)    day_of_week="Sun"    ;;
        esac
        if [[ $DOW_days == "" ]]; then                          # The first match by itself.
            DOW_days=$day_of_week
        else
            DOW_days=$DOW_days", "$day_of_week                  # As successive matches joined together by a comma.
        fi
    done

    case $DOW in                                                # Lets give us days of the week.
        1)    day_of_week="Mon"    ;;
        2)    day_of_week="Tue"    ;;
        3)    day_of_week="Wed"    ;;
        4)    day_of_week="Thu"    ;;
        5)    day_of_week="Fri"    ;;
        6)    day_of_week="Sat"    ;;
        7)    day_of_week="Sun"    ;;
    esac

    IFS=$IFS_RESTORE
    if [[ $Silent != "enable" ]]; then
        echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
    if [[ $Demo == "true" ]] && [[ $1 == "Short" ]]; then
        echo "SHORT TEST SIMULATION" | tee -a /tmp/drive_selftest/drive_test_temp.txt
    elif [[ $Demo == "true" ]] && [[ $1 == "Long" ]]; then
        echo "LONG TEST SIMULATION" | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
    if [[ $Silent != "enable" ]]; then
        echo -n '  '$1' Test Mode:('$Test_Mode') "'$Test_Mode_Title'"' | tee -a /tmp/drive_selftest/drive_test_temp.txt
    
        if [[ $Test_Mode -eq 1 ]]; then
            echo ', Running '$Drives_Test_Period' Option, Sorting by: '$SMART_Testing_Order | tee -a /tmp/drive_selftest/drive_test_temp.txt
        elif [[ $Test_Mode -eq 2 ]]; then
            echo ', Running '$Drives_Test_Period' Option, No Sorting' | tee -a /tmp/drive_selftest/drive_test_temp.txt
        else    
            echo ", $1 Testing will not be executed." | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
    fi
    sort_list=$smartdrives                                      # Lets sort the drive IDs.
    sort_data DriveID
    smartdrives_sorted=$sort_list                               # These are all the drives and sorted.
    Demo_Track=1
    Drive_Count=$(wc -w <<< "$smartdrives_sorted" | xargs)

    if [[ $Test_Mode -eq 1 ]]; then        # Variable Testing
        if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then     # Does DOW match ?, If yes, keep going.
            if [[ $SMART_Testing_Order == "Serial" ]]; then     # Lets sort by Serial number now.
                sort_list=${drives_serial[@]}
                api_drive_serial_number=$sort_list              # The Serial/DriveID are now sorted.
                sort_serial_number                              # Input - api_drive_serial_number, Output - smartdrives_sorted
            fi
            echo " "
            Drive_Count=$(wc -w <<< "$smartdrives_sorted" | xargs)  # Total number of drives.
            if [[ $Silent != "enable" ]]; then
                (echo "    Authorized Test Days: "$DOW_days
                echo "    Total Drives Recognized: "$Drive_Count) | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
        fi        
    fi
    if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then
        drives_to_test=$smartdrives_sorted
    else
        drives_to_test=""
    fi
    
    if [[ $Test_Mode -eq 2 ]]; then        # All Testing
        Demo_loop=0
        loop_counter=0
        Drive_List=""
        while [ $Demo_loop -lt $Drive_Count ]; do
            Drive_List_Temp=$(echo $smartdrives_sorted | cut -d ' ' -f ${Demo_Track} | xargs)
            if [[ $Drive_List != *"${Drive_List_Temp}"* ]]; then
                if [[ $Demo_loop -eq 0 ]]; then
                    Drive_List=$Drive_List_Temp                 # First Pass
                else
                    if [[ $loop_counter -eq $Drive_List_Length ]]; then
                        Drive_List=$Drive_List",\n "$Drive_List_Temp
                        loop_counter=0
                    else
                        (( loop_counter ++ ))
                        Drive_List=$Drive_List", "$Drive_List_Temp     # Successive Passes
                    fi
                fi
            fi
            if [[ $Demo_Track -eq $Drive_Count ]]; then break; fi
            (( Demo_Track ++ ))
            (( Demo_loop ++ ))
        done
        if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then
            drives_to_test=$smartdrives_sorted
        else
            drives_to_test=""
        fi
    fi    
   
    if [[ $Test_Mode -eq 3 ]]; then        # No Testing
        drives_to_test=""
    fi
    
    drives_tested_demo=""            # Needed to clear this variable for the second pass.  CHECK TO INITIALIZE ALL USED VARIABLES AT THE BEGINNING OF THE SCRIPT/FUNCTION CALL
   
    if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then                        # Is today a valid test day?
        if [[ $Test_Mode -eq 1 ]]; then

            Days_Authorized_in_Week=$(echo "$Drives_Tested_Days_of_the_Week" | tr ',' ' ' | wc -w | xargs )     # This holds numbers of the days 1,2,3...
            Days_Authorized_in_Month=$(( 4 * Days_Authorized_in_Week ))  #  4 weeks * 2 days a week = 8 days to test.
 
            # shellcheck disable=SC1073
            # shellcheck disable=SC1072
            # shellcheck disable=SC1009
            if [[ $(( Drives_to_Test_Per_Day * 10 )) -lt $((( Drive_Count * 10 ) / Days_Authorized_in_${Drives_Test_Period} )) ]]; then
                    if [[ $Silent != "enable" ]]; then
                    (   echo " "
                        echo "      DANGER Will Robinson, you have $Drive_Count drives and "$(( Days_Authorized_in_${Drives_Test_Period} ))" authorized days to test."
                        echo "      ROBOT will make adjustments, please wait.... Geez that was fast!"
                        echo "      Maybe you need more drives, Waka Waka! ROBOT made a funny."
                    ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi

                Drives_to_Test_Per_Day=$((( Drive_Count * 10 ) / Days_Authorized_in_${Drives_Test_Period} ))   #  28/6 = 5.xxx = 6
                if [[ ${Drives_to_Test_Per_Day: -1} != "0" ]]; then
                    Drives_to_Test_Per_Day=$(((Drive_Count / Days_Authorized_in_${Drives_Test_Period}) + 1))
                else
                    Drives_to_Test_Per_Day=$((Drive_Count / Days_Authorized_in_${Drives_Test_Period}))
                fi
                    if [[ $Silent != "enable" ]]; then
                    (   echo "      Recalculation Complete, the new value is $Drives_to_Test_Per_Day drive(s) spread across"
                        echo "      the "$(( Days_Authorized_in_${Drives_Test_Period} ))" authorized day(s)."
                        echo " "
                    ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
            fi

            ### Setup variables:
            First_DOM=1                  # Set First_DOM to the first day of the month.
            Temp_drives_tested=0         # Initial value, meaning no drives to test.
            DOW_temp=$DOW                # Start with current DOW
            valid_today=0
            test_it=0                    # If set to other than 0, testing is needed.
            drives_already_tested=0      # Total number of drives previously scheduled tested.  The next number is the drive to be tested if test_it != 0.

            if [[ $Drives_Test_Period == "Month" ]]; then            # THIS IS FOR MONTHLY
                list_monthly_output
            else                # THIS IS FOR THE WEEKLY
               list_weekly_output       # Call routine
            fi

        fi
    fi

# TESTING
    if [[ $1 == "Short" ]]; then selftest_drives_short=$drives_to_test; fi
    if [[ $selftest_drives_short == "all" ]]; then
        selftest_drives_short=$smartdrives
        if [[ $Silent != "enable" ]]; then
            echo "ALL DRIVES - SHORT" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
    fi
    if [[ $1 == "Long" ]]; then selftest_drives_long=$drives_to_test; fi
    if [[ $selftest_drives_long == "all" ]]; then
        selftest_drives_long=$smartdrives
        if [[ $Silent != "enable" ]]; then
            echo "ALL DRIVES - LONG" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
    fi
    # Call SMART Test routine.  Pass $1=Short/Long
    if [[ $Demo != "true" ]] && [[ $Ready_to_Test == "true" ]]; then    # Ready_to_Test means the Short and Long drive schedules are complete and actual testing may start.

# We need to not start the smart testing until after we process both Short and Long drive lists to test.
        if [[ $Short_Drives_Tested_Days_of_the_Week == *"$DOW"*    ]] || [[ $Long_Drives_Tested_Days_of_the_Week == *"$DOW"*    ]]; then        # If Long tests are not authorized for this day, do not run remove_duplicate_tests.
            remove_duplicate_tests
        fi
    else
        # We have not processed the Long tests yet.
        Ready_to_Test="true"        # This is good for the second pass now.
    fi

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "        "$end_time_display":  EXIT smartctl_selftest"
    echo -n "        Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    
    }

# CALLED FROM ONE LOCATION
list_monthly_output () {
	if [[ $Debug_Steps == "true" ]]; then echo "list_monthly_output" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi

# This will generate the MONTHLY screen output for the drives tested.
#
# Global Variables: Demo, DOW, softver, Drive_List_Length, Drive_Count, drives_to_test
# Local Variables: drives_to_list, total_drives_tested_per_day, sum_drives_test, DOW_temp, day_of_month, loop_counter, array_location, valid_today, first_DOW, test_it
# Local Variables: today_weekday, debian_day_of_month, pretext, gap_characters, pretext_length, drive_list_length_counter, drives_to_list_x, drives_already_tested
#

    (echo "            "$start_time_display":  START list_monthly_output") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    DOW_temp=$DOW                                    # Use a temporary variable to add/subtract with.
    drives_to_list=""                                # Listing a grouping of drive ids.
    total_drives_tested_per_day=0                    # Might be able to use a fixed number vice a variable.
    sum_drives_test=0                                # Total of drives tested?
    day_of_month=1                                   # Set the first of the month.
    loop_counter=0                                   # Just a counter.
    array_location=1                                 # Presetting the variable 
    drives_tested_demo=""
    echo " "
    while [ $(( 10#$day_of_month )) -le 28 ]; do                                  # 1. Start a loop from 1 to 28 to represent the 28 days of any given month.
        valid_today=0                                                   # Reset for current day check.
        if [[ $softver != "Linux" ]]; then                              # FreeBSD or Debian?
            first_DOW=$(date -v${day_of_month#0}d +%u)                    # What is the day of the week for the set date?
            today_weekday=$(date -v${day_of_month#0}d +%A)                # What is the 
        else
            debian_day_of_month="$(printf "%02d" ${day_of_month#0})"
            first_DOW=$(date -d "$(date +%Y%m${debian_day_of_month})" +%u)
            today_weekday=$(date -d "$(date +%Y%m${debian_day_of_month})" +%A)
        fi
        pretext=$today_weekday" "$(printf "%02d" ${day_of_month#0})" "$Full_Month_Name"\nDrive IDs: "
        gap_characters="----------"
        if [[ $Drives_Tested_Days_of_the_Week == *"$first_DOW"* ]]; then                                # 2. Check if today is an authorized day.
            valid_today=1                                                                               #    Mark this a authorized.
            total_drives_tested_per_day=$(( total_drives_tested_per_day + Drives_to_Test_Per_Day ))                            
            sum_drives_test=0
            loop_counter=0                         # Set the start count of the loop to define how many drives per line
            drive_list_length_counter=0            # Set the first or successive lines count
            drives_to_list=""
            previous_drives_tested_count=0         # Keep a running count of all the drives tested.
                        
            while [ $sum_drives_test -lt $Drives_to_Test_Per_Day ]; do
                drives_to_list_x=$(echo $smartdrives_sorted | cut -d' ' -f${array_location} | xargs)            # Grab next array variable (drive ID)
                if [[ $drives_to_list_x == "" ]]; then break; fi                                                # Jump out of while loop if no more drives to list
                    if [[ $drive_list_length_counter -lt $Drive_List_Length ]]; then                            # grab the first ten
                    if [[ $drives_to_list == "" ]]; then
                        drives_to_list=$drives_to_list_x
                    else
                        (( drive_list_length_counter ++ ))                            # Increment the loop counter
                        if [[ $Demo == "true" ]]; then                                # For display only
                            drives_to_list=$drives_to_list", "$drives_to_list_x
                        else
                            drives_to_list=$drives_to_list" "$drives_to_list_x
                        fi
                    fi
                else
                    drive_list_length_counter=0                                                  # Reset loop counter2 to 0 that count how many drives are in a line
                    drives_to_list=$drives_to_list"\n"$gap_characters" "$drives_to_list_x        # Now we add a new line, the gap spacing, and new drive ID
                fi
            (( sum_drives_test ++ ))
            (( array_location ++ ))
            (( previous_drives_tested_count ++ ))
            done
            if [[ $Demo == "true" ]]; then        # WHY IS THIS ONLY FOR DEMO? IT WILL LIST ALL THE DAYS OF THE DRIVES IF DISABLED.  LEAVE IN PLACE !
                if [[ $drives_to_list == "" ]]; then drives_to_list=" Nothing To Test This Day"; fi
                echo -e $pretext$drives_to_list | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi

            if [[ $(( 10#$day_of_month )) -lt $(( 10#$today_day )) ]]; then
                drives_tested_demo=$drives_tested_demo" "$drives_to_list
            fi

            if [[ $Demo != "true" ]] && [[ $(( 10#$day_of_month )) -eq $(( 10#$today_day )) ]]; then break; fi        # THIS SHOULD EXIT WHEN WE HIT TODAY
        fi
        (( day_of_month ++ ))
    done

    if [[ $Demo == "true" ]]; then return; fi
    if [[ ! $drives_already_tested -ge $Drive_Count ]]; then                                      # We match and have to test
        test_it=1
        if [[ $Silent != "enable" ]]; then
            echo "    Drive(s) previously scheduled to be tested: "$drives_tested_demo | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo -e "    "$(wc -w <<< "$drives_to_list" | xargs)" Drive(s) testing today: "$drives_to_list | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        drives_to_test=$drives_to_list
    else
        if [[ $Silent != "enable" ]]; then
            if [[ $valid_today -eq 1 ]]; then echo "    All Scheduled Drives Complete" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
        fi
    fi
    echo " "

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT list_monthly_output"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }

# CALLED FROM ONE LOCATION
list_weekly_output () {
	if [[ $Debug_Steps == "true" ]]; then echo "list_weekly_output" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# This will generate the WEEKLY screen output for the drives tested.
#
# Global Variables: Demo, Drive_Count, Drives_Tested_Days_of_the_Week, smartdrives_sorted, 
# Local Variables: First_DOM, drives_already_tested, valid_today, drives_already_tested, test_it, drives, DOW_temp, drives_to_test, drives_tested_demo?
#

    (echo "            "$start_time_display":  START list_weekly_output") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    ### Setup variables:
    First_DOM=1        # Set First_DOM to the first day of the month.
    Temp_drives_tested=0    # Initial value, meaning no drives to test.
    DOW_temp=$DOW    # Start with current DOW
    valid_today=0
    test_it=0                # If set to other than 0, testing is needed.
    drives_already_tested=0            # Total number of drives previously scheduled tested.  The next number is the drive to be tested if test_it != 0.
    if [[ $Debug == "true" ]]; then
        echo "Debug - Drive Names="$Drives_name | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drive Count="$Drive_Count | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drives Already Tested="$drives_already_tested | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drives To Test="$drives_to_test | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi

    while [ $First_DOM -le 7 ]; do
        valid_today=0
        if [[ $First_DOM -lt $DOW ]]; then                        # Is it less than today, then allow evaluation for previous matches.
            if [[  $Drives_Tested_Days_of_the_Week == *"$First_DOM"* ]]; then
                valid_today=1
                if [[ $drives_already_tested -lt $Drive_Count ]]; then
                    drives_already_tested=$(( drives_already_tested + Drives_to_Test_Per_Day ))                      # Increment sum_drives_test+per_day
                    if [[ $drives_already_tested -gt $Drive_Count ]]; then drives_already_tested=$Drive_Count; fi    # This adjusts to the remainder at the end of the drive list
                fi
            fi
        fi
        First_DOM=$(( First_DOM + 1 ))    # Increment to next day of the week
    done
    First_DOM=$(( First_DOM - 1 ))    # Decrement day of week evaluation to offset above addition before exit.
    if [[  $Drives_Tested_Days_of_the_Week == *"$First_DOM"* ]]; then valid_today=1; fi

    if [[ ! $drives_already_tested -ge $Drive_Count ]]; then                        # We match and have to test
        test_it=1
    else
        if [[ $Silent != "enable" ]]; then
            if [[ $valid_today -eq 1 ]]; then echo "All Scheduled Drives Complete" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
        fi
    fi 
    Temp_drives_tested=$drives_already_tested
    drives_to_test=""
    drives_tested_demo=""

    if [[ $test_it -eq 1 ]]; then
        DOW_temp=0
        if [[ $Temp_drives_tested -lt $Drive_Count ]]; then                         # $Temp_drives_tested=$x1  Temp_drives_tested=Drive Count
            for drives in $smartdrives_sorted; do                                   # Lets peel off the tested drives.
                # Loop $DOW_temp times
                DOW_temp=$(( DOW_temp + 1 ))                                        # Add 1 to the drive count: represents ?
                if [[ $DOW_temp -gt $Temp_drives_tested ]] && [[ $DOW_temp -lt $(( Temp_drives_tested + Drives_to_Test_Per_Day + 1 )) ]]; then   # DOW_temp -gt Drive Count && DOW_temp -lt (( Drive Count + Drives Per Day + 1))
                    drives_to_test=$drives_to_test" "$drives
                else
                    if ! [[ $DOW_temp -gt $Temp_drives_tested ]]; then
                        if [[ $drives_tested_demo == "" ]]; then
                            drives_tested_demo=$drives
                        else
                            drives_tested_demo=$drives_tested_demo", "$drives
                        fi
                    fi
                fi
            done
        fi
    fi

    if [[ $drives_to_test != "" ]]; then
        drives_to_test=$(echo "$drives_to_test" | xargs)
    fi

    if [[ $Test_Mode -eq 2 ]]; then
        if [[ $Silent != "enable" ]]; then
            (echo "All $(wc -w <<< "$smartdrives" | xargs) drives will be tested each time the script it run."
            echo " ") | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        return
    fi

    Drive_List=""
    Demo_Track=1            # Keeping track on where we are in the drive day list (Mon, Tue)
    IFS=","

    for Demo_Authorized_Days in $Drives_Tested_Days_of_the_Week; do             # Loop through the authorized days

        case $Demo_Authorized_Days in                                           # Lets give us authorized days of the week.
            1)    day_of_week="Monday"    ;;
            2)    day_of_week="Tuesday"    ;;
            3)    day_of_week="Wednesday"    ;;
            4)    day_of_week="Thursday"    ;;
            5)    day_of_week="Friday"    ;;
            6)    day_of_week="Saturday"    ;;
            7)    day_of_week="Sunday"    ;;
        esac
        IFS=$IFS_RESTORE
        if [[ $Demo == "true" ]]; then
            (echo " "; echo $day_of_week":"
            ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi

        # FOR WEEKLY RESULTS
        Demo_loop=0
        while [ $Demo_loop -lt $Drives_to_Test_Per_Day ]; do        # We are on more than 3 drives per day
            Drive_List_Temp=$(echo $smartdrives_sorted | cut -d ' ' -f ${Demo_Track} | xargs)
            if [[ $Drive_List != *"${Drive_List_Temp}"* ]]; then
                if [[ $Demo_loop -eq 0 ]]; then
                    Drive_List=$Drive_List_Temp                                 # First Pass
                else
                    if [[ $loop_counter -eq $Drive_List_Length ]]; then
                        Drive_List=$Drive_List",\n "$Drive_List_Temp
                        loop_counter=0
                    else
                        (( loop_counter ++ ))
                        Drive_List=$Drive_List", "$Drive_List_Temp              # Successive Passes
                    fi
                fi
            fi
            if [[ $Demo_Track -gt $Drive_Count ]]; then    break; fi            # Drive_List=""; fi
            (( Demo_Track ++ ))
            (( Demo_loop ++ ))
        done
        if [[ $Demo == "true" ]]; then
            if [[ $Drive_List == "" ]]; then Drive_List="No Remaining Drives"; fi
            echo -e " "$Drive_List | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
        Drive_List=""
    done
    echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
    IFS=$IFS_RESTORE
    if [[ $Demo != "true" ]]; then
    (    if [[ $drives_tested_demo == "" ]]; then
            if [[ $Silent != "enable" ]]; then
                echo "    Drive(s) previously scheduled to be tested: None"
            fi
        else
            if [[ $Silent != "enable" ]]; then
                echo "    Drive(s) previously scheduled to be tested: "$drives_tested_demo
            fi
        fi
        if [[ $drives_to_test == "" ]]; then
            if [[ $Silent != "enable" ]]; then
                echo "    Drives scheduled for testing today: None"
            fi
        else
            if [[ $Silent != "enable" ]]; then
                echo "    Drive(s) scheduled for testing today: "$drives_to_test
            fi
        fi
        echo " ") | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
        
    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT list_weekly_output"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }


##### GET DRIVE SERIAL NUMBERS VIA SMARTCTL TO SEE IF THIS IS FASTER OR NOT.  ALSO KEEP IS AS A BACKUP ROUTINE.
# STILL NEED TO BE CHANGED FROM API TO SMARTCTL.

# CALLED FROM ONE LOCATION
sort_serial_number () {
	if [[ $Debug_Steps == "true" ]]; then echo "sort_serial_number" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# This routine performs three things:
#  1. Sorts the drive serial numbers.
#  2. Places the drive ids ($smartdrives_sorted) in the same order as the sorted serial numbers.
#  3. NVMe drive names are properly formatted.
#
# Global Variables: api_drive_serial_number, smartdrives_sorted
# Local Variables: api_x, api_y, api_drive_name, api_drive_name_test, api_drive_serial_order, Serial_Length, 
#
# Input - api_drive_serial_number, Output - smartdrives_sorted

    (echo "            "$start_time_display":  START sort_serial_number") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    
    api_x=0
    api_y=0
    api_drive_name=""
    if [[ $Silent != "enable" ]]; then
        (echo " "
        echo -n "    Sorting Drive Test Order ") | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
    for api_drive_serial_order in $api_drive_serial_number; do
        while [[ "$(echo $Drive_Disk_Query  | jq -r '.['$api_y'].name')" != "null" ]]; do    # Loop through all of the drives comparing S/N Order to drive
            api_drive_serial_test=$(echo $Drive_Disk_Query  | jq -r '.['$api_y'].serial')
            if [[ $Silent != "enable" ]]; then
                echo -n "." | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
            Serial_Length=$(wc -c <<< "$api_drive_serial_test")                              # Too short of a S/N (3 characters or less) = Not Valid Drive
            if [[ $Serial_Length -gt 3 ]]; then
                if [[ $api_drive_serial_order == "$api_drive_serial_test" ]]; then
                    api_drive_name_test=$(echo $Drive_Disk_Query  | jq -r '.['$api_y'].name')
                    if [[ $softver != "Linux" ]]; then
                        api_drive_name=$api_drive_name" "$api_drive_name_test" "
                    else
                        if [[ $api_drive_name_test == *"nvme"* ]]; then
                            api_drive_name=$api_drive_name" "$(echo "nvme"$(echo $api_drive_name_test | sed -r 's#^nvme##' | cut -d 'n' -f 1)" ")
                        else
                            api_drive_name="$api_drive_name $api_drive_name_test "
                        fi
                    fi
                    break
                fi
            fi
            ((api_y ++))
        done
        api_y=0
        ((api_x ++))
    done
    if [[ $Silent != "enable" ]]; then
        echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi
    smartdrives_sorted=$(echo "$api_drive_name" | xargs |  sed 's/nvd/nvme/g' )

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT sort_serial_number"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    
    }


########## RUN NVMe SELFTEST ##########
# CALLED FROM ONE LOCATION
nvm_selftest () {
	if [[ $Debug_Steps == "true" ]]; then echo "nvm_selftest" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# $1 is Long or Short
#
# Global Variables: $1, softver, Wait_For_SMART_Short_Test, Wait_For_SMART_Long_Test, drive
# Local Variables: check_nvme_selftest, smart_selftest
#

    (echo "                    "$start_time_display":  START nvm_selftest") >> /tmp/drive_selftest/drive_test_timer_temp.txt
    # This check should not be required as this function is only called if nvme commands are required.
    # I may need to change this to only check smartmontools if it is version 7.4, regardless of if it is not completely compatible until version 7.5.
    if ! [[ $programver3 -lt 24 ]] || [[ $programver3 -eq 13 && $programver4 -eq 3 ]]; then            # Check if we are using TrueNAS which supports nvme testing, after version 24.04 ?
        # Use smartctl
        echo "Version 13.3 (CORE) or 24 (SCALE) or greater."
        if [[ $1 == "Long" ]]; then
            smartctl -t long /dev/$drive
        else
            smartctl -t short /dev/$drive
        fi
    else
        NVMe_Override_Enabled="true"
        echo "Using direct nvme commands to test nvme drives." | tee -a /tmp/drive_selftest/drive_test_temp.txt
        # FIRST KICK OFF EACH TEST
        if [ $softver != "Linux" ]; then
            # FreeBSD Commands
            check_nvme_selftest=$(nvmecontrol identify "$drive" | grep -i "self-test")
            shopt -s nocasematch  # Make test not case sensitive
            if [[ $check_nvme_selftest != *"Not"* ]]; then
                if [[ $Silent != "enable" ]]; then
                    if [[ $1 == "Long" ]]; then
                        echo "Running $1 Self-test for $drive" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    else
                        echo "Running $1 Self-test for $drive" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                fi
                if [[ "$1" != "Long" ]]; then    #Default run Short self-test.
                    smart_selftest="1"
                else
                    smart_selftest="2"
                fi
                nvmecontrol selftest -c $smart_selftest "$drive"
            else
                echo "$drive does not support Self-test" | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
            shopt -u nocasematch
        else
            # Debian Commands
            check_nvme_selftest=$(nvme id-ctrl /dev/"$drive" -H | grep -i "self-test")
            if [[ $check_nvme_selftest != *"Not"* ]]; then
                if [[ $Silent != "enable" ]]; then
                    if [[ $1 == "Long" ]]; then
                        echo "Running $1 Self-test for $drive in background " | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    else
                        echo "Running $1 Self-test for $drive" | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                fi
                if [[ "$1" != "Long" ]]; then
                    smart_selftest="1"
                else
                    smart_selftest="2"
                fi
                nvme device-self-test /dev/"$drive" -s $smart_selftest
            else
                echo "$drive does not support Self-test" | tee -a /tmp/drive_selftest/drive_test_temp.txt
            fi
        fi
    fi
    
    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "                    "$end_time_display":  EXIT nvm_selftest"
    echo -n "                    Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt    

    }


########## GET DRIVE LISTINGS
# CALLED FROM ONE LOCATION
get_API_Drives () {
	if [[ $Debug_Steps == "true" ]]; then echo "get_API_Drives" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# Replaces all the drive listing procedures.
# Input = Nothing
# Output = List of each drive TrueNAS recognizes along with (within an array; Drive Name, Model, Serial Number, Interface Type) and the full Drive Query output.
#
# Global Variables: Debug, Drive_Disk_Query, smartdrives, drives_name[@], drives_serial[@], drives_subsystem[@], drives_model[@]
# Local Variables: index, increment
#

    (echo "    "$start_time_display":  START get_API_Drives") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    # Setup local variables
    index=0            # INDEX IS THE REPORTED BACK DRIVES
    increment=0        # INCREMENT IS THE ACCESS TO THE FULL ARRAY, INCLUDING VIRTUAL AND CD DRIVES
    skip_drives_count=0

    if [[ $Debug == "true" ]]; then    echo "Debug - Function 'get_API_Drives'" | tee -a /tmp/drive_selftest/drive_test_temp.txt; echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
        if [[ $Test_ONLY_NVMe_Drives == "enable" ]]; then
            echo "Testing ONLY NVMe Drives" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        fi
	if [[ "$softver" == "Linux" ]] && [[ "$ID" == "ubuntu" ]]; then
		# For Ubuntu, use lsblk to get disk info in JSON format
		Drive_Disk_Query=$(lsblk -J -o NAME,SERIAL,MODEL,TYPE,TRAN | jq '.blockdevices | map(select(.type == "disk"))')
	else
		# For TrueNAS, use midclt call
		Drive_Disk_Query=$(midclt call disk.query)
	fi

    # 1. Get all API data in a variable, one call. -- Can we find API that says SMART Self-test is supported or not?  May need to use smartctl for one thing.
    #    `supports_smart:null`, maybe check if null and if so or `no`, use smartctl.
    # 2. Get Drive data into an array

    drives_name=$(echo $Drive_Disk_Query | jq '.[].name' | tr -d '"')            # get all the drive names
 
    for i in $drives_name; do
        drives_model[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.model')
        drives_name[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.name')
        drives_serial[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.serial' | tr -d ' ')        # "td -d ' '" removes any white space from the serial number

    # WE NEED TO WEED OUT ALL BUT NVD/NVME DRIVES IF NVME TEST ONLY OPTION SET
        if [[ $Test_ONLY_NVMe_Drives == "enable" ]]; then
            # WE NEED TO LET PASS ONLY NVD/NVME HERE
            if [[ ${drives_name[$index]} == "nvme"* ]] || [[ ${drives_name[$index]} == "nvd"* ]]; then
                if [[ $Debug == "true" ]]; then
                    echo "continue "$i | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
            else
                if [[ $Debug == "true" ]]; then
                    echo "Virtual "$i | tee -a /tmp/drive_selftest/drive_test_temp.txt
                fi
                drives_model[$index]="Virtual"            # Change all non NVD/NVME drives to Virtual, Crappy Hack But it Works?
            fi
        fi

    # WE NEED TO WEED OUT VIRTUAL AND CD DRIVES AND IGNORE LIST DRIVES
        if [[ ${drives_model[$index]} == *"Virtual"* ]] || [[ ${drives_name[$index]} == "cd"* ]] || [[ $Ignore_Drives_List =~ ${drives_serial[$index]} ]]; then
            (( skip_drives_count ++ ))
            if [[ $Debug == "true" ]] || [[ $Demo == "true" ]] || [[ $timer_flag -eq 1 ]] ; then
                if [[ $Ignore_Drives_List =~ ${drives_serial[$index]} ]]; then
                    if [[ $Silent != "enable" ]]; then
                        echo "Skip Ignored Drive(s): "${drives_name[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                    skip_drives_ignore=$skip_drives_ignore", "${drives_name[$index]}"("${drives_serial[$index]}")"
                else
                    if [[ $Silent != "enable" ]]; then
                        echo "Skip Virtual Drive(s): "${drives_name[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
                    fi
                    skip_drives_virtual=", "${drives_name[$index]}
                fi
            fi
            (( increment ++ ))
            continue
        fi

        if echo ${drives_name[$index]} | grep -q -i "nvd"; then
            drives_name[index]="$(echo ${drives_name[index]} | sed 's/nvd/nvme/g')"
        elif echo ${drives_name[$index]} | grep -q -i "nvme"; then
            drives_name[index]="$(echo "nvme"$(echo ${drives_name[$index]} | sed -r 's#^nvme##' | cut -d 'n' -f 1))"
        fi

        drives_subsystem[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.subsystem')
        (( index ++ ))
        (( increment ++ ))
    done

    # If the last drive at the end jumps out and is a virtual or cd drive, remove it.
    if [[ ${drives_model[$index]} == *"Virtual"* ]] || [[ ${drives_name[$index]} == "cd"* ]] || [[ $Ignore_Drives_List =~ ${drives_serial[$index]} ]]; then drives_name[index]=""; drives_serial[index]=""; fi

    drives_count=$(echo ${drives_name[@]} | wc -w)

    smartdrives=${drives_name[@]}
    if [[ $Debug == "true" ]]; then
        index=0
        for i in ${drives_name[@]}; do
            echo -n "Debug - Drive ID="${drives_name[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo -n ", Drive S/N="${drives_serial[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo -n ", Drive Model="${drives_model[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo ", Drive Subsystem="${drives_subsystem[$index]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
            (( index ++ ))
        done
        echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Total Drives="$drives_count | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drive Names="${drives_name[@]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Drives Serial Numbers="${drives_serial[@]} | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo " " | tee -a /tmp/drive_selftest/drive_test_temp.txt
        echo "Debug - Leaving function 'get_API_Drives'" | tee -a /tmp/drive_selftest/drive_test_temp.txt
    fi

    skip_drives_ignore="Ignored: "${skip_drives_ignore:1}
    skip_drives_virtual="Virtual: "${skip_drives_virtual:1}
    
    (echo "    Good Drive Count: "$drives_count
    if [[ $skip_drives_ignore != "" || $skip_drives_virtual != "" ]]; then echo "    Drives Removed: "$skip_drives_count" : "$skip_drives_virtual", "$skip_drives_ignore; fi

    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    echo "    "$end_time_display":  EXIT get_API_Drives"
    echo -n "    Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt
        
    }

########## SORT ROUTINE ##########

sort_data () {
	if [[ $Debug_Steps == "true" ]]; then echo "sort_data" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
# Global Variables: sort_list
# Local Variables: i

    (echo "            "$start_time_display":  START sort_data '$1'") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    if [ $softver != "Linux" ]; then
    sort_list=$(for i in $sort_list; do
        echo "$i"
        done | sort -V)
    else
        sort_list_short=$(for i in $sort_list; do
            echo "$i"
        done | awk 'length<4' | sort -V)
        sort_list_long=$(for i in $sort_list; do
            echo "$i"
        done | awk 'length>3' | sort -V)
        sort_list=$sort_list_short" "$sort_list_long
        sort_list="$(echo "$sort_list" | tr -s " ")"
    fi
    
    if [[ $softver != "Linux" ]]; then
        end_time_display=$(date '+%H:%M:%S')
    else
        elapsed_time $start_time_display
    fi
    
    (echo "            "$end_time_display":  EXIT sort_data"
    echo -n "            Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
        if [[ $end_tenths != "" ]]; then
            echo ".$end_tenths seconds elapsed."
        else
            echo " seconds elapsed."
        fi
        echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

    }


    delete_log_files () {
		if [[ $Debug_Steps == "true" ]]; then echo "delete_log_files" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    # This function will detect and delete all the log file created by this script.
    
    if ls drive_selftest_demo_??.txt 1> /dev/null 2>&1; then echo "Removing Demo Log Files"; rm drive_selftest_demo_??.txt; else echo "No demo log files to remove."; fi
    if ls drive_selftest_??.txt 1> /dev/null 2>&1; then echo "Removing Log Files"; rm drive_selftest_??.txt; else echo "No log files to remove."; fi

    }
    
    
    elapsed_time () {
    # Pass the starting time value.  Only for Linux.
        end_time_display=$(date +"%H:%M:%S.%2N")
        time_diff=$(($(date -d "$end_time_display" '+%s%2N') - $(date -d "$1" '+%s%2N')))
        rev_time=$(echo $time_diff | rev)
        end_tenths=$(echo ${rev_time:0:2} | rev)
        end_time=$(echo ${rev_time:2} | rev)
        SECONDS=$end_time
    }


# CALLED FROM TWO LOCATIONS    
help_text () {
	if [[ $Debug_Steps == "true" ]]; then echo "help_text" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    clear
    echo "SMART Drive Self-test Script: "$Version" "$Version_Date
    echo "Standalone or Companion to Multi-Report 3.1 and later."
    echo " "
    echo "For Standalone Operation (not using multi_report_config.txt file),"
    echo "edit lines (around line 90) '######### USER SETTINGS #########' as desired."
    echo " "
    echo "There are six significant groups of variables: Automatic Update, Short tests, Long tests,"
    echo "SCRUB/RESILVER, Ignore Drives, and Reports."
    echo " "
    echo "Automatic Updates will allow the drive_selftest.sh file to be updated should it be out of date."
    echo " "
    echo "This script can use the multi_report_config.txt file when combined with Multi-Report."
    echo "You must configure these settings in Multi-Report, otherwise the values at the top"
    echo "of the script will be used."
    echo " "
    echo "Short and Long tests are configured as follows:"
    echo " "
    echo "  Test_Mode: 1 = Use Short(or Long) Drives_to_Test_Per_Day value"
    echo "             2 = All Drives Tested (Ignores other options except when active)"
    echo "             3 = No Drives Tested"
    echo " "
    echo "  Time_Delay_Between_Drives: Tests will have a XX second delay between the"
    echo "  drives starting testing."
    echo " "
    echo "  Short_Drives_Test_Delay: Time period in seconds to wait for SHORT tests to complete."
    echo "  Default is 130 seconds for use with Multi-Report, if not then set to 1 second."
    echo " "
    echo "BELOW OPTIONS ARE USED ONLY WITH Test Mode 1"
    echo "--------------------------------------------"
    echo " "
    echo '  SMART_Testing_Order: Select "DriveID" or "Serial" sorting order.'
    echo " "
    echo "  Drives_to_Test_Per_Day: How many drives to run each day minimum."
    echo "  The script will auto-correct if you choose too small of a value."
    echo " "
    echo '  Drives_Test_Period: Options are "Week" (Mon-Sun) or "Month" (days 1 - 28)'
    echo " "
    echo "  Drives_Tested_Days_of_the_Week: Days of the week allowed to run:"
    echo '  1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun  Default = "1,2,3,4,5,6,7"'
    echo " "
    echo "Press Any Key to Continue"
    read -s -n 1 key_input
    echo "--------------------------------------------------------------------------"
    echo " "
    echo "NORMAL OPERATION DOES NOT REQUIRE ANY COMMAND LINE SWITCHES"
    echo " "
    echo "Command Line Switches:"
    echo "NOTE! The demo mode uses the 'Drives_Tested_Days_of_the_Week' value to"
    echo "calculate how many drives are to be run on which days of the week."
    echo "If the demo results are not the desired effect, adjust the values."
    echo " "
    echo "    '-timer' --- Generates a file which tracks how many seconds are utilized"
    echo "                 for each routine within the script.  Used for development."
    echo " "
    echo "    '-demo' '[short|long]' '[1|2|3]' '[week|month]' '[driveid|serial]'"
    echo "        Lists full drive testing schedule."
    echo "        Use short or long options to focus on one list."
    echo "        Override Settings will not use the script set values."
    echo "            Test Mode using '1','2', or '3'."
    echo "            Testing Period 'week' or 'month'."
    echo " "
    echo "    '-clearlog' --- Delete all the drive_selftest log files."
    echo " "
    echo "    '-debug'    --- Runs the script in Debug Mode"
    echo " "
    echo "Example: drive_selftest -demo short 1 week serial"
    echo " Means: Simulate Short SMART Test, Test Mode 1 to spread across a Week"
    echo " and using the days of the week set in the script setup."
    echo " "
    echo "Example: drive_selftest -demo short"
    echo " Means: Simulate a Short SMART Test using the current configured settings"
    echo " "
    echo "This will provide a listing of how your drives would be tested for"
    echo "a short test in Test Mode 1, providing you the dates they would be tested."
    echo " "
    echo "To read the Troubleshooting Help pages, Press 'Y'"
    echo "Press any other key to exit"
    read -s -n 1 key_input
    if [[ $key_input == "y" ]] || [[ $key_input == "Y" ]]; then troubleshooting_help; fi
    exit 0
	
    }

# CALLED FROM ONE LOCATION    
troubleshooting_help () {
	if [[ $Debug_Steps == "true" ]]; then echo "troubleshooting_help" | tee -a /tmp/drive_selftest/drive_test_temp.txt; fi
    clear
    echo "TROUBLESHOOTING HELP                           Script Version: "$Version" "$Version_Date
    echo "You are running on "$programver
    echo " "
    echo "This section will attempt to help you define and solve any error messages"
    echo "in which you may encounter."
    echo " "
    echo "First: What is a problem message?"
    echo " 1. If you see an error message about exit code that is other than zero (0)."
    echo " 2. If you notice drives are being tested in an improper sequence."
    echo " 3. Any script failure messages."
    echo " "
    echo "Second: What is not a problem message?"
    echo " 1. Any message by the ROBOT.  These are informational letting you know"
    echo "    that you entered an unsustainable variable and ROBOT made an"
    echo "    adjustment to ensure all drives are testing in the configured time frame."
    echo " 2. 'Skipping drive' means the drive was already in test."
    echo " 3. Days being skipped in '-demo' mode.  First check your Authorized Days"
    echo "    to run the test, odds are you are missing the week days not included."
    echo " "
    echo " "
    echo "Press Any Key to Continue"
    read -s -n 1 key_input
    echo "--------------------------------------------------------------------------"
    echo " "
    echo "If you are virtualizing a drive, this script removes virtual drives."
    echo "You will need to pass through the controller or run bare metal."
    echo "Even real drives passed through as RDM (ESXi) will be seen as Virtual."
    echo " "
    echo "If you feel the script is taking too long, then use the '-timer' switch"
    echo "to generate a file with timing information, located in the log directory"
    echo "with all the other logs.  Joe needs that if you think there is a problem."
    echo " "
    echo "For any other failures, contact Joe at joeschmuck2023@hotmail.com with"
    echo "the following details: A copy of the log data file(s).  If you feel a few"
    echo "earlier log data files would help, send those as well, and any other"
    echo "information you feel is relevant.  While there is a such thing as too much"
    echo "data, I'd rather have more than less."
    echo " "
    echo "--- Be patient as I will answer as soon as I see the email, I am not glued"
    echo "to my computer and have a life.  I may ask you to perform a few commands"
    echo "to help troubleshoot the issue."
    echo " "
    echo "Five Waka Waka Jokes: https://www.youtube.com/watch?v=rDpUAqQPnzM"
    echo "If you are bored"
        
    }


######################### PROGRAM STARTS HERE ##########################
#

### Use multi_report_config.txt or not?
# If the file does not exist, script values will be used and no error message will be generated.
# Either setting the Use_multi_report_config_values="enable" (at top of script), or switch will use the Multi-Report file, if it exists.
# First line finds out if this script was called by Multi-Report.

### DELETE ANY LEFTOVER TEMPORARY FILES IF THEY EXIST, THEY SHOULDN'T.
if test -e "/tmp/drive_selftest"; then rm -R "/tmp/drive_selftest"; fi
sleep .2
mkdir "/tmp/drive_selftest"		# Create temporary directory for this iteration of the script.

#if test -e "/tmp/drive_selftest/drive_test_timer_temp.txt"; then rm "/tmp/drive_selftest/drive_test_timer_temp.txt"; fi
#if test -e "/tmp/drive_selftest/drive_test_temp.txt"; then rm "/tmp/drive_selftest/drive_test_temp.txt"; fi

echo "Joe's SMART Drive Self-test Script - Run: "$today_day" "$Full_Month_Name" "$(date +%r) | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
echo "Script Version: "$Version" "$Version_Date", "$programver | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt

if test -e "$Config_File_Name" || [[ $1 == "-use_external_file" ]]; then
    if [[ $Use_multi_report_config_values == "enable" ]]; then
        if test -e "$Config_File_Name"; then
            . "$Config_File_Name"
            echo 'Using "'$Config_File_Name'" values..."' | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
        else
            echo 'Using "script" values...' | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
        fi
    fi
fi

if [[ $1 == "-dump" ]] || [[ $2 == "-dump" ]] || [[ $1 == "-demo" ]]; then Silent="disable"; Debug="true"; fi    # This is duplicated before and after the config file is read to ensure we remain in "debug" mode.

if [[ $Enable_Logging == "enable" ]]; then
    if ! test -e "$LOG_DIR"; then
        echo "'"$LOG_DIR"' does not exist, attempting to create it..." | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
        mkdir $LOG_DIR
        if test -e "$LOG_DIR"; then
            echo "Success" | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
        else
            echo "Failed to create '"$LOG_DIR"', using script default directory of "$SCRIPT_DIR | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
            LOG_DIR=$SCRIPT_DIR
        fi
    fi
    if [[ $Silent != "enable" ]]; then
        echo " "
        echo "Logging Enabled" | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
    fi
fi

if [[ $Silent == "enable" ]]; then
    (echo " "
    echo "----> Silent Enabled - Minimal Data Will Be Reported, Plus Any Error Messages <----"
    echo "----> You may experience prolonged silence, be patient <----"
    echo " ") | tee -a /tmp/drive_selftest/drive_test_temp.txt /tmp/drive_selftest/drive_test_timer_temp.txt
fi

if [[ $2 == "debug" ]]; then Silent="disable"; Debug="true"; fi

if [[ $Check_For_Updates == "enable" ]]; then
    checkforupdate
fi

if [[ $Automatic_Selftest_Update == "enable" ]] && [[ $UpdateDriveAvailable == "true" ]]; then checkforupdate; fi

if [[ $1 == "-update" ]]; then
    update_Drive_script
    sleep 1
    exit 0
fi

SECONDS=0            # Lets start the timer
if [[ $softver != "Linux" ]]; then start_time_display=$(date '+%H:%M:%S'); else start_time_display=$(date +"%H:%M:%S.%2N"); fi

(echo "This log file is used to track the execution time for each routine and identify any location to optimize if possible."; echo " "
echo $start_time_display":  Program Start"; echo " ") >> /tmp/drive_selftest/drive_test_timer_temp.txt

#### SETUP SCRIPT TO ACKNOWLEDGE ANY ORDER OF SWITCHES.

#  OPTIONS ARE '-demo' 'short' 'long' week' 'month' '1' '2' '3' BUT NOT TWO OF THE SAME GROUP - CASE INSENSITIVE ###
counter_loop=0
short_cli=0
long_cli=0
week_cli=0
month_cli=0
x1_cli=0
x2_cli=0
x3_cli=0
x_cli=0
timer_flag=0
drive_selftest_dump="false"

shopt -s nocasematch            # Make it case-insensitive

    if [[ $1 == "-use_external_file" ]]; then
        echo "Using External Configuration File"
        if [[ $2 == "-dump" ]]; then
            drive_selftest_dump="true"
            echo "Saving Dump Data"
        fi
    elif [[ $1 == "-dump" ]]; then
        drive_selftest_dump="true"
        echo "Saving Dump Data"
    elif [[ $1 == "-demo" ]]; then
        Demo="true"
    elif [[ $1 == "-clearlog" ]]; then
        delete_log_files
        exit 0
    elif [[ $1 == "-help" ]]; then
        help_text
        echo " "
        exit 0
    elif [[ $1 == "-timer" ]] || [[ $2 == "-timer" ]]; then
        timer_flag=1
    elif [[ $1 == "-debug" ]] || [[ $2 == "-debug" ]] || [[ $3 == "-debug" ]] || [[ $4 == "-debug" ]] ; then
        Debug="true"
    elif [[ $1 != "" ]]; then
        echo "Command Line Options is invalid."
        echo "You may use '-help' for further information"
        echo " "
        exit 1
    fi

if [[ $Demo == "true" ]]; then
    counter_loop=0
    while [ $counter_loop -lt 20 ]; do                # Check for any order of the CLI switches ONLY if -demo is present.
        if [[ $1 == "short" ]]; then short_cli=1; fi    
        if [[ $1 == "long" ]]; then long_cli=1; fi    
        if [[ $1 == "week" ]]; then week_cli=1; fi
        if [[ $1 == "month" ]]; then month_cli=1; fi
        if [[ $1 == "DriveID" ]]; then DriveID_cli=1; fi
        if [[ $1 == "Serial" ]]; then Serial_cli=1; fi
        if [[ $1 == "1" ]]; then x1_cli=1; fi
        if [[ $1 == "2" ]]; then x2_cli=1; fi
        if [[ $1 == "3" ]]; then x3_cli=1; fi
        shift 1        # rotate $1 value
        (( counter_loop ++ ))
    done

    # Not two of the opposite values
    if [[ $week_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Long_Drives_Test_Period="Week"; fi    
    if [[ $week_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Drives_Test_Period="Week"; fi    
    if [[ $month_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Drives_Test_Period="Month"; fi
    if [[ $month_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Drives_Test_Period="Month"; fi
    if [[ $DriveID_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_SMART_Testing_Order="DriveID"; fi
    if [[ $DriveID_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_SMART_Testing_Order="DriveID"; fi
    if [[ $Serial_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_SMART_Testing_Order="Serial"; fi
    if [[ $Serial_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_SMART_Testing_Order="Serial"; fi

    if [[ $short_cli -eq 1 ]]; then Short_Test_Mode=1; Long_Test_Mode=3; fi
    if [[ $long_cli -eq 1 ]]; then Short_Test_Mode=3; Long_Test_Mode=1; fi

    if [[ $x1_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Test_Mode=1; Long_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x2_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Test_Mode=2; Long_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x3_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Test_Mode=3; Long_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x1_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Test_Mode=1; Short_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x2_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Test_Mode=2; Short_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x3_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Test_Mode=3; Short_Test_Mode=3; (( x_cli ++ )); fi

# Error Messages
    if [[ $short_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then echo "You cannot specify both 'short' and 'long' at the same time."; exit 1; fi
    if [[ $week_cli -eq 1 ]] && [[ $month_cli -eq 1 ]]; then echo "You cannot specify both 'week' and 'month' at the same time."; exit 1; fi
    if [[ $(( x1_cli + x2_cli + x3_cli )) -gt 1 ]]; then echo "You cannot specify more than one test mode (1, 2, or 3) on the CLI."; exit 1; fi
    if [[ $DriveID_cli -eq 1 ]] && [[ $Serial_cli -eq 1 ]]; then echo "You cannot specify both 'DriveID; and 'Serial' at the same time."; exit 1; fi
    if [[ $(( mon_cli + tue_cli + wed_cli + thu_cli + fri_cli + sat_cli + sun_cli )) -gt 1 ]]; then echo "You cannot specify multiple days of the week (Mon - Sun)"; exit 1; fi
fi

if [[ $1 == "-demo" ]]; then
    Demo="true"
    echo "Demo Mode: Below is the simulated testing schedule based on current settings."
    echo " "
    (echo "Demo Mode: Below is the simulated testing schedule based on current settings."
    echo " ") >> /tmp/drive_selftest/drive_test_temp.txt
fi

#if [[ $Demo == "true" ]] && [[ $short_cli -eq 1 ]]; then Long_Test_Mode=3; fi
#if [[ $Demo == "true" ]] && [[ $long_cli -eq 1 ]]; then Short_Test_Mode=3; fi
if ! [[ $timer_flag -eq 1 ]]; then 
    if [[ $1 != "" ]] && [[ $1 != "-demo" ]] && [[ $1 != "-debug" ]] && [[ $1 != "-use_external_file" ]] && [[ $1 != "-dump" ]]; then help_text; fi
    if [[ $2 != "short" ]] && [[ $2 != "long" ]] && [[ $2 != "" ]] && [[ $2 != "-dump" ]]; then help_text; fi
fi
shopt -u nocasematch

(( Drive_List_Length -- ))            # Adjust for offset
get_API_Drives                        # Grab all the drive data at one single time
SCRUB_In_Progress="false"
if [[ $SCRUB_RESILVER_OVERRIDE != "enable" ]]; then  # Override scrub and resilver, allow SMART Long tests to run regardless.
	check_scrub                           # Is a SCRUB going on?  This function will set the test mode to "0" if no tests are to be run.
fi

if [[ $Long_Test_Mode -ne 0 ]]; then
    smartctl_selftest Short           # Run Short HDD/SSD SMART Tests
fi

if [[ $Short_Test_Mode -ne 0 ]]; then
    smartdrives_sorted=""             # Reset the variable
    smartctl_selftest Long            # Run Long HDD/SSD SMART Tests
fi

# Convert Authorized Days to Text String just so we can add it to the Multi-Report output.
Short_DOW_days=""
IFS=","
for day_of_week_test in $Short_Drives_Tested_Days_of_the_Week; do
    case $day_of_week_test in                               # Lets give us days of the week.
        1)    day_of_week="Mon"    ;;
        2)    day_of_week="Tue"    ;;
        3)    day_of_week="Wed"    ;;
        4)    day_of_week="Thu"    ;;
        5)    day_of_week="Fri"    ;;
        6)    day_of_week="Sat"    ;;
        7)    day_of_week="Sun"    ;;
    esac
    if [[ $Short_DOW_days == "" ]]; then                          # The first match by itself.
        Short_DOW_days=$day_of_week
    else
        Short_DOW_days=$Short_DOW_days", "$day_of_week                  # Ass successive matches joined together by a comma.
    fi
done

Long_DOW_days=""
for day_of_week_test in $Long_Drives_Tested_Days_of_the_Week; do
    case $day_of_week_test in                               # Lets give us days of the week.
        1)    day_of_week="Mon"    ;;
        2)    day_of_week="Tue"    ;;
        3)    day_of_week="Wed"    ;;
        4)    day_of_week="Thu"    ;;
        5)    day_of_week="Fri"    ;;
        6)    day_of_week="Sat"    ;;
        7)    day_of_week="Sun"    ;;
    esac
    if [[ $Long_DOW_days == "" ]]; then                          # The first match by itself.
        Long_DOW_days=$day_of_week
    else
        Long_DOW_days=$Long_DOW_days", "$day_of_week                  # Ass successive matches joined together by a comma.
    fi
done
    
# These two lines should never result in None
if [[ $Short_DOW_days == "" ]]; then Short_DOW_days="None"; fi
if [[ $Long_DOW_days == "" ]]; then Long_DOW_days="None"; fi
    
IFS=$IFS_RESTORE

if [[ $Short_Drives_Testing == "" ]]; then Short_Drives_Testing="none today"; fi
if [[ $Long_Drives_Testing == "" ]]; then Long_Drives_Testing="none today"; fi

(echo "<b>   a) Short Test Authorized Test Days (</b>"$Short_DOW_days"<b>) (</b>~$Drives_to_Test_Per_Day Drive(s) per day<b>)</b>"
 echo "      Drives Testing: ("$Short_Drives_Testing") - Test Mode "$Short_Test_Mode
 echo "<b>   b) Long Test Authorized Test Days (</b>"$Long_DOW_days"<b>) (</b>~$Drives_to_Test_Per_Day Drive(s) per day<b>)</b>"
 echo "      Drives Testing: ("$Long_Drives_Testing") - Test Mode "$Long_Test_Mode
 if [[ $SCRUB_In_Progress == "true" ]]; then
    echo "<b>   c) A "$Function" is in progress with "$Function_Time_Left_Whole1"."$Function_Time_Left_Fraction" Hours remaining.</b>"
 else
     echo "<b>   c) A SCRUB or RESILVER is NOT in progress.</b>"
 fi

if [[ $NVMe_Override_Enabled == "true" ]]; then
    echo "<b>   d) NVMe S.M.A.R.T. Testing using 'nvme' commands vice 'smartctl'</b>"
 fi) > /tmp/smartdrive_selftest_text.txt

# CALCULATE THE SCRIPT DURATION
if [[ $softver != "Linux" ]]; then
    end_time_display=$(date '+%H:%M:%S')
else
    elapsed_time $start_time_display
fi

# PRINT THE SCRIPT DURATION
if [[ $Silent != "enable" ]]; then
    (echo " "
    echo $end_time_display":  Drive-Selftest Wrapping things up..."
    echo -n "Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
    if [[ $end_tenths != "" ]]; then
        echo ".$end_tenths seconds elapsed."
    else
        echo " seconds elapsed."
    fi
    echo " ") | tee -a /tmp/drive_selftest/drive_test_temp.txt
else
    (echo " "
    echo $end_time_display":  Drive-Selftest Wrapping things up..."
    echo -n "Elapsed Time: $((SECONDS / 60)) minutes and $((SECONDS % 60))"
    if [[ $end_tenths != "" ]]; then
        echo ".$end_tenths seconds elapsed."
    else
        echo " seconds elapsed."
    fi
    echo " ") >> /tmp/drive_selftest/drive_test_temp.txt
fi

# TIME TO TELL EVERYONE THE DURATION OF THE WAIT
if [[ $Silent != "enable" ]]; then
    (
    if [[ $No_Tests == "false" ]]; then
        if [[ $Short_Drives_Test_Delay -lt 6 ]]; then
            echo "Short $Short_Drives_Test_Delay Second Pause..."
        else
            echo "Waiting $Short_Drives_Test_Delay Second Delay, Please Standby..."
        fi
    fi
    ) | tee -a /tmp/drive_selftest/drive_test_temp.txt
else
    (
    if [[ $No_Tests == "false" ]]; then
        if [[ $Short_Drives_Test_Delay -lt 6 ]]; then
            echo "Your $Short_Drives_Test_Delay Second Delay..."
        else
            echo "Your $Short_Drives_Test_Delay Second Delay, Please Standby..."
        fi
    fi
    ) >> /tmp/drive_selftest/drive_test_temp.txt
fi

# IF LOGGING ENABLED, WRITE THE THREE FILES
if [[ $Enable_Logging == "enable" ]]; then
    if [[ $Demo == "true" ]]; then
        echo " "
        echo "Saving Log (file name: $LOG_DIR/drive_selftest_demo_${today_day#0}.txt)" | tee -a /tmp/drive_selftest/drive_test_temp.txt
        cat /tmp/drive_selftest/drive_test_temp.txt > $LOG_DIR/drive_selftest_demo_${today_day#0}.txt
    else
        if [[ $Silent != "enable" ]]; then
            echo "Saving Log (file name: $LOG_DIR/drive_selftest_${today_day}.txt)" | tee -a /tmp/drive_selftest/drive_test_temp.txt
            echo "Exiting Joe's SMART Drive Self-test Script" >> /tmp/drive_selftest/drive_test_temp.txt
            cat /tmp/drive_selftest/drive_test_temp.txt > $LOG_DIR/drive_selftest_${today_day#0}.txt
        else
            echo "Saving Log (file name: $LOG_DIR/drive_test_${today_day}.txt)" >> /tmp/drive_selftest/drive_test_temp.txt
            echo "Exiting Joe's SMART Drive Self-test Script" >> /tmp/drive_selftest/drive_test_temp.txt
            cat /tmp/drive_selftest/drive_test_temp.txt > $LOG_DIR/drive_selftest_${today_day#0}.txt
        fi
    fi
    if [[ $timer_flag -eq 1 ]]; then
        echo "Exiting Joe's SMART Drive Self-test Script" >> /tmp/drive_selftest/drive_test_timer_temp.txt
        cat /tmp/drive_selftest/drive_test_timer_temp.txt > $LOG_DIR/drive_selftest_timer_${today_day#0}.txt
    fi

#    if [[ $drive_selftest_dump != "true" ]]; then        # Leave the files behind for Multi-Report to collect.
#        rm /tmp/drive_selftest/drive_test_timer_temp.txt > /dev/null 2<&1
#        rm /tmp/drive_selftest/drive_test_temp.txt > /dev/null 2<&1
#    fi
fi

# Leave "/tmp/smartdrive_selftest_text.txt" for Multi-Report

# Delete everything else
if test -e "/tmp/drive_selftest"; then rm -R "/tmp/drive_selftest"; fi
if test -e "/tmp/Multi-Report/drive_selftest.txt"; then rm /tmp/Multi-Report/drive_selftest.txt; fi

if [[ $No_Tests == "true" ]]; then
    if [[ $Demo == "true" ]]; then
        echo "SIMULATION: "$Short_Drives_Test_Delay" second timer skipped."
    fi
else
    sleep $Short_Drives_Test_Delay            # Sleep XXX seconds to wait for Short tests to complete before returning to controlling procedure.
fi

echo "Exiting Joe's SMART Drive Self-test Script"

exit 0