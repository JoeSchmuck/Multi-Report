#!/bin/bash

LANG="en_US.UTF-8"
if [[ $TERM == "dumb" ]]; then          # Set a terminal as the script may generate an error message if using 'dumb'.
    export TERM=unknown
fi
##### Version 1.03

SCRIPT_DIR=$( cd -- "$( dirname -- "${BASH_SOURCE[0]}" )" &> /dev/null && pwd )

### FILE NAME SHOULD BE 'drive_selftest.sh' TO INTEGRATE WITH MULTI-REPORT
###
### MULTIPLE DRIVE SMART SELF-TEST SCRIPT (TO EASE YOUR CONFIGURATION NEEDS)
###
### WHAT DOES THIS SCRIPT DO?
###
### THIS SCRIPT WAS ORIGINALLY DESIGNED FOR PEOPLE WHO HAVE A LOT OF DRIVES AND
### DO NOT WANT TO SCHEDULE EACH DRIVE INDIVIDUALLY FOR SMART TESTING.
### ADDITIONALLY THIS CAN BE USED WITH MULTI-REPORT 3.1 OR LATER TO RUN SMART TESTS
### AND UTILIZE THE MULTI-REPORT CONFIGURATION FILE IF DESIRED.
###
### THIS SCRIPT WILL SPREAD OUT THE SMART SHORT AND LONG/EXTENDED TESTING IN THREE
### POSSIBLE WAYS, INCLUDING THE OPTION TO NOT TEST AT ALL:
###  1. SPREAD ACROSS A WEEK (ON SPECIFIED DAYS OF THE WEEK)
###  2. SPREAD ACROSS A MONTH (ON SPECIFIED DAYS OF THE WEEK)
###  3. ALL DRIVES (ON SPECIFIED DAYS OF THE WEEK)
###  4. OR NO DRIVES AT ALL
### SPECIFIED DAYS OF THE WEEK ARE: 1=MON, 2=TUE, 3=WED, 4=THU, 5=FRI, 6=SAT, 7=SUN.
###
### THESE ARE BROKEN DOWN INTO SHORT TESTS AND LONG TESTS.
### THE DRIVES CAN BE TESTED IN DRIVE NAME (ID) ORDER (ADA0, ADA1, OR SDA, SDB) OR
### SORTED BY SERIAL NUMBER (A POOR MANS CRAPPY METHOD TO SIMULATE RANDOMIZATION OF DRIVES TO REDUCE DRIVES
### BEING TESTED IN THE SAME DRIVE CAGE TO REDUCE CURRENT AND HEAT, AND IT MAY NOT REALLY WORK OUT)
###
### THE DEFAULT SETTINGS ARE:
###    1. DAILY SHORT TESTS ON EACH DRIVE (TEST MODE 2)
###       -SORTED BY DRIVE NAME/ID, ALL DRIVES TESTED EVERY DAY, RUNS 7 DAYS A WEEK
###    2. MONTHLY LONG TESTS ON EACH DRIVE (TEST MODE 1, MONTHLY)
###       -SORTED BY SERIAL NUMBER, ONE DRIVE A DAY, ONE TEST PER MONTH, RUNS 7 DAYS A WEEK
###    3. LOGGING ENABLED
###
### READ THE CONFIGURATION SECTION BELOW AND MAKE CHANGES AS DESIRED.
###
### A LOG FILE BY DEFAULT IS CREATED IN THE SCRIPT DIRECTORY, ONE FOR EACH DAY
### OF THE MONTH.  IT WILL OVERWRITE ONCE A NEW MONTH STARTS.
###
### IF YOU ALREADY HAVE SMART TESTING FOR A DAILY SMART SHORT TEST THEN YOU CAN SET
### TEST MODE 3 FOR SHORT TESTS TO MITIGATE DUPLICATE TESTING.
###
### USE [-help] FOR ADDITIONAL INFORMATION

# Change Log
#

# Version 1.03 (26 January 2025)
#
# - Added Test NVMe Drives Only option (by request).
# - Improved the Update feature.
# - Streamlined the CRON JOB output a bit.
#

# Version 1.02 (16 January 2025)
#
# 27 December - Addressed invalid drives for SMART testing.
# 10 January  - Finished no sleep if no tests.
#
# Initial Release Version 1.0 (10 January 2025)
#



# Future Improvements
#  1. Implement an Update Function (already started, not operational)
#  2. Add trap function for errors
#  3. Detect if a SCRUB is in progress as it virtually stops SMART testing, and a LONG test should be skipped, but how and to ensure we still test that drive?
#     Exit code of "0" is good, "1" is scrub in progress.  Need to find a way to figure out how to detect it is running, likely the API.
#     And make a variable to abort Long testing if a SCRUB is in progress.  Or maybe report a scrub is in progress and it may take some time to complete.  Yea, I like that.
#     Use midclt call pool.query | jq | grep -i "scanning"
#     scan:function:state and percentage and total_secs_left.  We can see how long it takes a specific drive how long to run a SMART Long test, maybe even just
#     ignore a Long test if it is Weekly.  Still needs a switch I think.  Just a hard wired one.  How do I relate the disk to the pool being scrubbed, tricky?
#     Variable 'Ignore_Long_Test_During_Scrub_Seconds' is set for a 5 hour limit for a scrub test remaining time.
#


######################## USER SETTINGS ########################

###### NEW SCRIPT TO TEST LOTS OF DRIVES ######
###                                         ###
###          THESE ARE FUNCTIONAL           ###
###         MAKE YOUR CHANGES HERE          ###
###          THESE ARE OVERRIDEN            ###
###      BY MULTI_REPORT_CONFIG.TXT         ###
###                                         ###
###############################################

### EXTERNAL CONFIGURATION FILE
Config_File_Name=$SCRIPT_DIR"/multi_report_config.txt"
Use_multi_report_config_values="true"		# A "true" value here will use the $Config_File_Name file values to override the values defined below.
											# This allows the values to be retained between versions.  A "false" will utilize the values below.

###### SCRIPT UPDATES
Automatic_Selftest_Update="false"	# WARNING !!!  This option will automatically update the Drive_Selftest script if a newer version exists on GitHub with no user interaction. Default = "false"

###### HDD/SSD/NVMe SMART Testing
Test_ONLY_NVMe_Drives="false"				# This option when set to "true" will only test NVMe drives, HDD/SSD will not be tested. Default = "false"

### SHORT SETTINGS
Short_Test_Mode=2                           # 1 = Use Short_Drives_to_Test_Per_Day value, 2 = All Drives Tested (Ignores other options), 3 = No Drives Tested.
Short_Time_Delay_Between_Drives=1           # Tests will have a XX second delay between the drives starting testing. If drives are always spinning, this can be "0".
Short_SMART_Testing_Order="DriveID"         # Test order is for Test Mode 1 ONLY, select "Serial" or "DriveID" for sort order.  Default = "Serial"
Short_Drives_to_Test_Per_Day=1              # For Test_Mode 1) How many drives to run each day minimum?
Short_Drives_Test_Period="Week"             # "Week" (7 days) or "Month" (28 days)
Short_Drives_Tested_Days_of_the_Week="1,2,3,4,5,6,7"    # Days of the week to run, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun.  # This takes over for number of days variable.
Short_Drives_Test_Delay=1					# How long to delay when running Short tests, before exiting to controlling procedure.  Default is 130 second should allow.
											# Short tests to complete before continuing.  If using without Mulit-Report, set this value to 1.

### LONG SETTINGS
Long_Test_Mode=1                            # 1 = Use Long_Drives_to_Test_Per_Day value, 2 = All Drives Tested (Ignores other options), 3 = No Drives Tested.
Long_Time_Delay_Between_Drives=1            # Tests will have a XX second delay between the drives starting the next test.
Long_SMART_Testing_Order="Serial"           # Test order is either "Serial" or "DriveID".  Default = 'Serial'
Long_Drives_to_Test_Per_Day=1               # For Test_Mode 1) How many drives to run each day minimum?
Long_Drives_Test_Period="Week"             # "Week" (7 days) or "Month" (28 days)
Long_Drives_Tested_Days_of_the_Week="1,2,3,4,5,6,7"     # Days of the week to run, 1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun. # This takes over for number of days variable.


### IGNORE DRIVES LIST
# IF YOU HAVE A DRIVE THAT YOU DO NOT WANT THIS SCRIPT TO TOUCH (RUN ANY TESTS ON), THEN INCLUDE THE DRIVE SERIAL NUMBER
# IN THE LIST.  IF THE SERIAL NUMBER MATCHES THEN THE DRIVE IS REMOVED FROM TESTING. BELOW IS AN EXAMPLE.
# Example:  Ignore_Drives_List="RQTY4D78E,JJ6XTZ,OU812,ZR13JRL"
Ignore_Drives_List=""

### REPORT
Drive_List_Length=10                        # This is how many drive IDs to list per line.  Default is 10.
Enable_Logging="true"                       # This will create a text file named "drive_test_xx.txt". Run -clearlog
LOG_DIR=$SCRIPT_DIR"/DS_Logs"   			# The default log directory is the script directory.
Silent="false"								# When "true" only error messages will be output to the stdout.

#######################################
#######################################
###                                 ###
###  STOP EDITING THE SCRIPT HERE   ###
###     DO NOT CHANGE ANYTHING      ###
###        BELOW THIS LINE          ###
###                                 ###
#######################################
#######################################

###### DEBUG SECTION ######
# DEBUG is to be used to display extra operational data for troubleshooting the script.
# I do not recommend people play with anything here.

Debug="false"            # Default = "false"
simulated_drives=0       # Set to '0' to use actual drives, or to any number to use simulated drives (the Serial option will not work)

###### Auto-generated Parameters
softver=$(uname -s)
Ignore_Long_Test_During_Scrub_Seconds=18000	# When a value other than '0' zero, this will not run a SMART Long test on a drive during
											#  a SCRUB if there is more than 5 Hours (18,000 seconds) remaining on the Scrub.

if [[ $softver != "Linux" ]]; then
  if [[ "$(cat /etc/version | grep "FreeNAS")" ]]; then
    programver="FreeNAS "$(cat /etc/version | cut -d " " -f1 | sed 's/FreeNAS-//')
    programver3="$(cat /etc/version | cut -d " " -f1 | sed 's/FreeNAS-//' | cut -d "." -f1)"
	programver4="$(cat /etc/version | cut -d "." -f2 | cut -c1)"
  else
    programver="TrueNAS Core "$(cat /etc/version | cut -d " " -f1 | sed 's/TrueNAS-//')
    programver3="$(cat /etc/version | cut -d " " -f1 | sed 's/TrueNAS-//' | cut -d "." -f1)"
	programver4="$(cat /etc/version | cut -d "." -f2 | cut -c1)"
  fi
else
    programver="TrueNAS Scale "$(cat /etc/version)
    programver3="$(cat /etc/version | cut -d "." -f1)"
    programver4=6 # Using symbolic value so script works as written, just for SCALE.
fi
programver3=$(( programver3 + 0 ))		# Make Base 10
programver4=$(( programver4 + 0 ))
Program_Name="drive_selftest.sh"
Version="1.03"							# Current version of the script
Version_Date="(26 January 2025)"

# GLOBAL VARIABLES - MUST BE DEFINED EARLY BEFORE FUNCTION TO BE GLOBAL
Drive_Disk_Query=""				# Valid
smartdrives=""					# Valid
selftest_drives=""				# Valid
drives_name=""					# Valid - Part of the Drive Array
drives_serial=""				# Valid - Part of the Drive Array
drives_subsystem=""				# Valid - Part of the Drive Array
driveConnectionType="auto"		# Valid - Part of the Drive Array
Demo="false"					# Valid
IFS_RESTORE=$IFS				# Valid
CRAP="DRATS"					# Valid
selftest_drives_short=""        # Valid
selftest_drives_long=""         # Valid
Ready_to_Test="false"           # Valid
start_time_display=""
end_time_display=""
end_tenths=""
NVMe_Override_Enabled=""
Short_Drives_Testing=""
Long_Drives_Testing=""
No_Tests="true"

if [[ $softver != "Linux" ]]; then
    DOW=$(date '+%u')                          # Todays Day of the Week, 1=Mon, 7=Sun
    Full_Month_Name=$(date '+%B')              # Full name of current month
else
    DOW=$(date +%u)                            # Todays Day of the Week, 1=Mon, 7=Sun
    Full_Month_Name=$(date +%B)                # Full name of current month
fi
today_day=$(date +%d)

# Get Smartmontools version number 
smart_ver=$(smartctl | grep "7." | cut -d " " -f 2)

# Get all drive(s) interface data
smartctlscan=$(smartctl --scan-open)


##########################
##########################
###                    ###
###  DEFINE FUNCTIONS  ###
###                    ###
##########################
##########################

checkforupdate () {
	echo "Checking for Updates"
	if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi

	if [[ "$(curl -is https://github.com | head -n 1)" ]]; then
		(
			cd /tmp
			if ! test -e "Multi-Report"; then
				mkdir Multi-Report
			fi
			cd Multi-Report
			curl -LJOs https://raw.githubusercontent.com/JoeSchmuck/Multi-Report/refs/heads/main/drive_selftest.txt			
		)	
		if test -e "/tmp/Multi-Report/drive_selftest.txt"; then
			GitDriveVersion=$(cat "/tmp/Multi-Report/drive_selftest.txt" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)
			GitDriveMajorVersionNumber="$(echo $GitDriveVersion | cut -d '.' -f1)"
			GitDriveMinorVersionNumber="$(echo $GitDriveVersion | cut -d '.' -f2)"
			convert_to_decimal $GitDriveMajorVersionNumber
			GitDriveMajorVersionNumber=$Return_Value
			convert_to_decimal $GitDriveMinorVersionNumber
			GitDriveMinorVersionNumber=$Return_Value
			if test -e $SCRIPT_DIR"/drive_selftest.sh"; then
				VersionDriveFilename="$(cat $SCRIPT_DIR"/drive_selftest.sh" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)"
				MajorDriveVersionFilename="$(echo $VersionDriveFilename | cut -d '.' -f1)"
				MinorDriveVersionFilename="$(echo $VersionDriveFilename | cut -d '.' -f2)"
				convert_to_decimal $MajorDriveVersionFilename
				MajorDriveVersionFilenamer=$Return_Value
				convert_to_decimal $MinorDriveVersionFilename
				MinorDriveVersionFilename=$Return_Value
			else
				VersionDriveFilename="Nothing Is Here"
			fi
			Drive_Updated="AVAILABLE: V"$VersionDriveFilename
			echo -n "    Drive_Selftest - Installed: "$VersionDriveFilename", GitHub: "$GitDriveVersion
			if [[ $GitDriveMajorVersionNumber -gt $MajorDriveVersionFilename ]] && [[ $VersionDriveFilename != "" ]]; then
				echo " - Major Update"
				UpdateDriveAvailable="true"
				rm /tmp/Multi-Report/drive_selftest.txt
			elif [[ $GitDriveMajorVersionNumber -eq $MajorDriveVersionFilename ]] && [[ $GitDriveMinorVersionNumber -gt $MinorDriveVersionFilename ]]; then
				UpdateDriveAvailable="true"
				echo " - Minor Update"
				rm /tmp/Multi-Report/drive_selftest.txt
			else
				echo " - No Update"
			fi		
			if [[ $Automatic_Selftest_Update == "true" ]] && [[ $UpdateDriveAvailable == "true" ]]; then
				echo "      Automatic Update Enabled"
				update_Drive_script
			fi					
		else
			echo "No GitHub Version File Available"
		fi

	fi

	if [[ $UpdateDriveAvailable == "true" ]]; then
		echo "Update is Available -- Use the '-update' switch to force an update."
#	else
#		echo "NO Updates Available"
	fi

	}

	update_Drive_script () {
	echo "Update Script Routine"
#
# ENSURE WE DELETE /TMP/MULTI-REPORT DIRECTORY WHEN EITHER WE END THE SCRIPT OR START THE SCRIPT.  MAYBE IN THE UPDATE?
#
	echo "Removing Old Script Source if it exists"
	if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi
	if test -e "/tmp/multi_report_update.txt"; then rm "/tmp/multi_report_update.txt"; fi
	echo "Downloading new script files"
	if [[ "$(curl -is https://github.com | head -n 1)" ]]; then
		# Go git the file
		( mkdir /tmp/Multi-Report
		cd /tmp/Multi-Report
		curl -LJOs https://raw.githubusercontent.com/JoeSchmuck/Multi-Report/refs/heads/main/drive_selftest.txt
		curl -LJOs https://raw.githubusercontent.com/JoeSchmuck/Multi-Report/refs/heads/main/Drive_Selftest_User_Guide.pdf
		)
		GitDriveVersion=$(cat "/tmp/Multi-Report/drive_selftest.txt" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)
		VersionDriveFilename=$(cat $SCRIPT_DIR"/drive_selftest.sh" | grep "##### Version" | cut -d 'n' -f2 | tr -d ' ' | head -1)
		echo " "
		echo "      - Drive_Selftest current version is: "$VersionDriveFilename
		echo "      - The new version is: "$GitDriveVersion
		echo " "

		if [[ $Automatic_Selftest_Update != "true" ]]; then
			echo "Enter 'y' to commit or any other key to abort."
			read Keyboard_yn
		else
			echo "Automatic Update is Enabled..."
			Keyboard_yn="y"
		fi
		if [[ $Keyboard_yn == "y" ]] || [[ $Keyboard_yn == "Y" ]]; then
			echo "Updating Script..."

			# Copy the new multi_report.sh file and set permissions
			cp /tmp/Multi-Report/drive_selftest.txt $SCRIPT_DIR"/drive_selftest.sh"
			chmod 755 $SCRIPT_DIR"/drive_selftest.sh" > /dev/null 2<&1

			# Copy the User Guide
			echo "1"
			sleep .5
			cp "/tmp/Multi-Report/Drive_Selftest_User_Guide.pdf" $SCRIPT_DIR"/."
			echo " "
			echo "Your script has been updated and a copy of the User Guide and changelog is in your directory."
			sleep 1
				
			### THIS IS NOT COMPLETE AND IS INTENTIONED TO UPDATE THE DRIVE SELF-TEST SCRIPT.
			# Copy the drive_selftest.sh script.  When it runs, if it sees a newer version, it will automatically update itself.
			#    cp "/tmp/Multi-Report/drive_selftest.up" $SCRIPT_DIR"/drive_selftest.sh"	# Temporary to get the script on systems.
		
			# Cleanup Leftover Files
			if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi
			if test -e "/tmp/multi_report_update.txt"; then	rm "/tmp/multi_report_update.txt"; fi
		else
			echo "Aborted"
			if test -e "/tmp/Multi-Report"; then rm -R "/tmp/Multi-Report"; fi
			exit 0
		fi
	else
		echo "GitHub is Not Available"
	fi
	if [[ $Automatic_Selftest_Update != "true" ]]; then 
		echo "Exiting..."
		exit 0
	fi

	}

convert_to_decimal () {
if [[ $Debug_Steps == "true" ]]; then echo "convert_to_decimal"; fi
	if [[ "$1" == "" ]]; then return; fi
	Converting_Value=${1#0}
	Converting_Value="${Converting_Value//,}"
	Return_Value=$Converting_Value
	if [[ $1 == "0" ]]; then Return_Value=0; fi

	}

remove_duplicate_tests () {
# THIS WILL COMPARE BOTH SHORT AND LONG TESTS AND REMOVE DUPLICATE SHORT TESTS FROM THE TESTING LIST.
# NEXT TIME LETS FIGURE OUT THE LONG TESTS FIRST, THEN FIGURE OUT THE SHORT TESTS AND IF ONE IS LISTED IN THE LONG TESTS LIST, REMOVE IT.

# Global Variables: selftest_drives_short, selftest_drives_long

# Local Variables: s_drives, short_modified_drives
#echo -n "1"
	(echo "            "$start_time_display":  START remove_duplicate_tests"; echo " ") >> /tmp/drive_test_timer_temp.txt

	for s_drives in $selftest_drives_short ; do 					# Loop through all the Long drives to test
		# Lets remove any matches to the short drive list.
		if [[ $selftest_drives_long == *"$s_drives"* ]]; then		# If the Short drive is listed in the Long drives list, Do Not add to a new drive list
			if [[ $reduced_drives_display == "" ]]; then			# We are creating a list of drives being removed for display only purposes.
				reduced_drives_display=$s_drives							# We are formatting the display to look nice in this IF statement.
			else
				reduced_drives_display=$reduced_drives_display" "$s_drives
			fi
		else														# ELSE we create a new list of Short drives to test, if any.
			if [[ $short_modified_drives == "" ]]; then short_modified_drives=$s_drives; else short_modified_drives=$short_modified_drives" "$s_drives; fi
		fi
	done
	if [[ $s_drives != "" ]]; then
		if [[ $(wc -c <<< "$reduced_drives_display" | xargs) -gt 2 ]]; then
			if [[ $Silent != "true" ]]; then
				(echo '    Drive(s): "'$reduced_drives_display'" were removed from the Short testing list'
				echo '    It/They are already scheduled for the Long test, no need to duplicate efforts'
				echo " " ) | tee -a /tmp/drive_test_temp.txt
			fi
		fi
	fi
	selftest_drives_short=$short_modified_drives
	selftest_drives=$selftest_drives_short
	if ! [[ $selftest_drives == "" ]]; then
		if [[ $Silent != "true" ]]; then
			echo "RUNNING SHORT TEST: "$selftest_drives | tee -a /tmp/drive_test_temp.txt
		fi
		run_smart_test Short
		Short_Drives_Testing=$selftest_drives
	else
		if [[ $Silent != "true" ]]; then
			(echo " "
			echo "NO SHORT TESTS TO RUN"$selftest_drives ) | tee -a /tmp/drive_test_temp.txt
		fi
	fi
	selftest_drives=$selftest_drives_long
	echo " "
	if [[ $(wc -c <<< "$selftest_drives" | xargs) -gt 2 ]]; then
		if [[ $Silent != "true" ]]; then
			echo "RUNNING LONG TEST:" | tee -a /tmp/drive_test_temp.txt
		fi
		echo "            RUNNING LONG TEST:" >> /tmp/drive_test_timer_temp.txt
		run_smart_test Long
		Long_Drives_Testing=$selftest_drives
	else
		if [[ $Silent != "true" ]]; then
			echo "NO LONG TESTS TO RUN" | tee -a /tmp/drive_test_temp.txt
		fi
		(echo "            NO LONG TESTS TO RUN"; echo " ") >> /tmp/drive_test_timer_temp.txt
	fi

	if [[ $softver != "Linux" ]]; then
		end_time_display=$(date '+%H:%M:%S')
	else
		elapsed_time $start_time_display
	fi
	(echo "            "$end_time_display":  EXIT remove_duplicate_tests"
	echo -n "            Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
		if [[ $end_tenths != "" ]]; then
			echo ".$end_tenths seconds elapsed."
		else
			echo " seconds elapsed."
		fi
		echo " ") >> /tmp/drive_test_timer_temp.txt

    }


# CALLED FROM ONE LOCATION
run_smart_test () {

# This will check if a SMART test is currently running and if yes, display the progress.
# If not SMART test is running then execute the test.
#
# Required variables: $1=Test Type (Short/Long)
# Global Variables: Drive_Disk_Query, smart_ver, selftest_drives, Demo, Time_Delay_Between_Drives, Debug, drive, 
#
# Local Variables: drive, API_BUS, smart_test_ok, test_it, driveConnectionType, api_s
#
# Calls nvm_selftest
#echo -n "2"
	(echo "                "$start_time_display":  START run_smart_test"; echo " ") >> /tmp/drive_test_timer_temp.txt

    test_running=0
    for drive in $selftest_drives; do

        api_s=0
        until [[ "$(echo $Drive_Disk_Query | jq -r '.['$api_s'].name')" == "null" ]] || [[ "$(echo $Drive_Disk_Query | jq -r '.['$api_s'].name')" == *"$drive"* ]]; do (( api_s ++)); done
        API_BUS=$(echo $Drive_Disk_Query | jq -r '.['$api_s'].subsystem')

### ADDED ### New Routine to select interface type
		driveConnectionType=$(echo "$smartctlscan" | grep -i "$drive" | awk '{printf $3}')

### REMOVED ### if [[ $API_BUS == "scsi" ]]; then driveConnectionType="sat,auto"; else driveConnectionType="auto"; fi        # Select Drive interface Type

        if [[ $Debug == "true" ]]; then echo " "; fi
        if [[ $Debug == "true" ]]; then echo "    Debug - Drive ID=$drive, Interface Type=$driveConnectionType, API BUS="$API_BUS; fi

		if [[ $programver3 -lt 24 ]] && [[ $drive == *"nvm"* ]] && [[ $programver4 -lt 3 ]]; then 	# If less than (24 or 13.3) and nvme drive.

            nvm_selftest $1 $drive
			No_Tests="false"
        else                                        # If smartmontool is 7.4 or greater, Time to try and run a SMART test using smartmontools for nvme.
            if [[ $1 == "Short" ]]; then
                smart_test_ok="$(smartctl -d "${driveConnectionType}" -t short /dev/$drive)" > /dev/null 2<&1
            else
                smart_test_ok="$(smartctl -d "${driveConnectionType}" -t long /dev/$drive)" > /dev/null 2<&1
            fi
			smartresult=$?
            if echo $smart_test_ok | grep -i "has begun" > /dev/null 2<&1; then
				if [[ $Silent != "true" ]]; then
					echo "    Drive: $drive in $1 Test" | tee -a /tmp/drive_test_temp.txt
				fi
				if [[ $timer_flag -eq 1 ]]; then echo "                    Drive: $drive in $1 Test"; fi >> /tmp/drive_test_timer_temp.txt
                test_running=1    # Looks like the testing is in progress.
				No_Tests="false"
            else
				if [[ $timer_flag -eq 1 ]]; then echo "                    An error occurred for Drive: $drive in $1 Test."; fi >> /tmp/drive_test_timer_temp.txt
                	if [[ $CRAP == "DRATS" ]]; then CRAP="DARN"; else CRAP="DRATS"; fi
					echo "    Drive: $drive failed to start $1 Test" | tee -a /tmp/drive_test_temp.txt
					echo -n "    "$CRAP'!!! - "'$drive'"' | tee -a /tmp/drive_test_temp.txt
				if echo $smart_test_ok | grep -i -e "remaining" -e "completed" > /dev/null 2<&1; then
                (   echo -n " is still running a test: "
                    echo $smart_test_ok | grep -o -e '(..% remaining)' -e '(..% completed)'
                    echo '    Skipping drive "'$drive'"') | tee -a /tmp/drive_test_temp.txt
                else
                (   echo " did not accept the smartctl command."
					echo " "
					echo "    SMARTCTL Return Value = "$smartresult
					echo " "
                    echo "    Here is the return message:"
                    echo $smart_test_ok
                    echo " ") | tee -a /tmp/drive_test_temp.txt
                fi
            fi
            test_it=1
        fi

        if [[ $Demo != "true" ]]; then
            sleep $Time_Delay_Between_Drives        # Wait DELAY seconds before running another drive.
        fi
    done

    if [[ $test_it -eq 1 ]]; then
        if [[ $1 == "Long" ]]; then
			sleep 1   # Wait 1 second before executing any Long tests.
            if [[ $selftest_drives != "" ]]; then
                if [[ $Silent != "true" ]]; then
					(echo " "
					echo "ALL TESTS COMPLETED OR RUNNING IN BACKGROUND") | tee -a /tmp/drive_test_temp.txt
				fi
            fi
        fi
    fi
#    echo " " | tee -a /tmp/drive_test_temp.txt

	if [[ $softver != "Linux" ]]; then
		end_time_display=$(date '+%H:%M:%S')
	else
		elapsed_time $start_time_display
	fi
	
	(echo "                "$end_time_display":  EXIT run_smart_test"
	echo -n "                Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
		if [[ $end_tenths != "" ]]; then
			echo ".$end_tenths seconds elapsed."
		else
			echo " seconds elapsed."
		fi
		echo " ") >> /tmp/drive_test_timer_temp.txt

    }


# CALLED FROM TWO LOCATIONS
smartctl_selftest () {
	# THIS WILL DIRECT COLLECTING THE DRIVE DATA BASED ON $1 (Short|Long) value.  And it will determine the drives to test each day.

    # Uses smartmontools to run the tests.

    # Global Variables: $1="Short/Long", Demo, smartdrives_sorted, 
    # Short_Test_Mode, Short_SMART_Testing_Order, Short_Drives_to_Test_Per_Day, Short_Drives_Test_Period, Short_Drives_Tested_Days_of_the_Week, Short_Time_Delay_Between_Drives
    # Long_Test_Mode, Long_SMART_Testing_Order, Long_Drives_to_Test_Per_Day, Long_Drives_Test_Period, Long_Drives_Tested_Days_of_the_Week, Long_Time_Delay_Between_Drives    

    # Local Variables: counter_simulated_drives, day_of_week, DOW_days, drives_to_test
#echo -n "3"
	(echo "        "$start_time_display":  START smartctl_selftest '$1'"; echo " ") >> /tmp/drive_test_timer_temp.txt

    api_drive_serial_number=""
    if [[ $Demo == "true" ]]; then
        counter_simulated_drives=0
        smartdrives_sorted=""
        if [[ $simulated_drives -gt 0 ]]; then
            while [ $counter_simulated_drives -lt $simulated_drives ]; do
                smartdrives_sorted=$smartdrives_sorted" ada"$counter_simulated_drives
                (( counter_simulated_drives ++ ))
            done
            smartdrives=$smartdrives_sorted
        fi
    fi

    if [[ $1 == "" ]]; then echo "No SMART Test is defined, Error."; break ; fi        # Exit if no test is selected.

    if [[ $1 == "Short" ]]; then                                # Use Short variables
        Test_Mode=$Short_Test_Mode
        SMART_Testing_Order=$Short_SMART_Testing_Order
        Drives_to_Test_Per_Day=$Short_Drives_to_Test_Per_Day
        Drives_Test_Period=$Short_Drives_Test_Period
        Drives_Tested_Days_of_the_Week=$Short_Drives_Tested_Days_of_the_Week
        Time_Delay_Between_Drives=$Short_Time_Delay_Between_Drives
    else                                                        # Else use Long variables
        Test_Mode=$Long_Test_Mode
        SMART_Testing_Order=$Long_SMART_Testing_Order
        Drives_to_Test_Per_Day=$Long_Drives_to_Test_Per_Day
        Drives_Test_Period=$Long_Drives_Test_Period
        Drives_Tested_Days_of_the_Week=$Long_Drives_Tested_Days_of_the_Week
        Time_Delay_Between_Drives=$Long_Time_Delay_Between_Drives
    fi

    case $Test_Mode in                                          # Lets give us a title for the report.
        1)    Test_Mode_Title="${1} SMART Test on ${Drives_to_Test_Per_Day} Drive(s) Per Day"    ;;
        2)    Test_Mode_Title="${1} SMART Test All Drives"                ;;
        3)    Test_Mode_Title="No SMART Testing Selected"                ;;
    esac
    DOW_days=""
    IFS=","
    for day_of_week_test in $Drives_Tested_Days_of_the_Week; do
        case $day_of_week_test in                               # Lets give us days of the week.
            1)    day_of_week="Mon"    ;;
            2)    day_of_week="Tue"    ;;
            3)    day_of_week="Wed"    ;;
            4)    day_of_week="Thu"    ;;
            5)    day_of_week="Fri"    ;;
            6)    day_of_week="Sat"    ;;
            7)    day_of_week="Sun"    ;;
        esac
        if [[ $DOW_days == "" ]]; then                          # The first match by itself.
            DOW_days=$day_of_week
        else
            DOW_days=$DOW_days", "$day_of_week                  # Ass successive matches joined together by a comma.
        fi
    done

    case $DOW in                                                # Lets give us days of the week.
        1)    day_of_week="Mon"    ;;
        2)    day_of_week="Tue"    ;;
        3)    day_of_week="Wed"    ;;
        4)    day_of_week="Thu"    ;;
        5)    day_of_week="Fri"    ;;
        6)    day_of_week="Sat"    ;;
        7)    day_of_week="Sun"    ;;
    esac
    current_DOW=$day_of_week                                    # Today
    IFS=$IFS_RESTORE
	if [[ $Silent != "true" ]]; then
		echo " " | tee -a /tmp/drive_test_temp.txt
	fi
    if [[ $Demo == "true" ]] && [[ $1 == "Short" ]]; then
        echo "SHORT TEST SIMULATION" | tee -a /tmp/drive_test_temp.txt
    elif [[ $Demo == "true" ]] && [[ $1 == "Long" ]]; then
        echo "LONG TEST SIMULATION" | tee -a /tmp/drive_test_temp.txt
    fi
	if [[ $Silent != "true" ]]; then
		echo -n '  '$1' Test Mode:('$Test_Mode') "'$Test_Mode_Title'"' | tee -a /tmp/drive_test_temp.txt
	
		if [[ $Test_Mode -eq 1 ]]; then
			echo ', Running '$Drives_Test_Period' Option, Sorting by: '$SMART_Testing_Order | tee -a /tmp/drive_test_temp.txt
		elif [[ $Test_Mode -eq 2 ]]; then
			echo ', Running '$Drives_Test_Period' Option, No Sorting' | tee -a /tmp/drive_test_temp.txt
		else	
			echo ", $1 Testing will not be executed." | tee -a /tmp/drive_test_temp.txt
		fi
	fi
    sort_list=$smartdrives                                      # Lets sort the drive IDs.
	sort_data DriveID
    smartdrives_sorted=$sort_list                               # These are all the drives and sorted.
    Demo_Track=1
    Drive_Count=$(wc -w <<< "$smartdrives_sorted" | xargs)

    if [[ $Test_Mode -eq 1 ]]; then		# Variable Testing
       if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then     # Does DOW match ?, If yes, keep going.
            if [[ $SMART_Testing_Order == "Serial" ]]; then     # Lets sort by Serial number now.
                sort_list=${drives_serial[@]}
                api_drive_serial_number=$sort_list              # The Serial/DriveID are now sorted.
                sort_serial_number                              # Input - api_drive_serial_number, Output - smartdrives_sorted
            fi
        else
			if [[ $Silent != "true" ]]; then
				echo "NO DRIVES TO TEST THIS PERIOD" | tee -a /tmp/drive_test_temp.txt
			fi
            return
        fi
#        echo -n "    Drive Testing List:"
#        echo -e "    "$smartdrives_sorted | tee -a /tmp/drive_test_temp.txt	
		
		echo " "
        Drive_Count=$(wc -w <<< "$smartdrives_sorted" | xargs)  # Total number of drives.
        if [[ $Silent != "true" ]]; then
			(echo "    Authorized Test Days: "$DOW_days
			echo "    Total Drives Recognized: "$Drive_Count) | tee -a /tmp/drive_test_temp.txt
		fi
	fi
	
    if [[ $Test_Mode -eq 2 ]]; then		# All Testing
        Demo_loop=0
        loop_counter=0
        Drive_List=""
        while [ $Demo_loop -lt $Drive_Count ]; do
            Drive_List_Temp=$(echo $smartdrives_sorted | cut -d ' ' -f ${Demo_Track} | xargs)
            if [[ $Drive_List != *"${Drive_List_Temp}"* ]]; then
                if [[ $Demo_loop -eq 0 ]]; then
                    Drive_List=$Drive_List_Temp                 # First Pass
                else
                    if [[ $loop_counter -eq $Drive_List_Length ]]; then
                        Drive_List=$Drive_List",\n "$Drive_List_Temp
                        loop_counter=0
                    else
                        (( loop_counter ++ ))
                        Drive_List=$Drive_List", "$Drive_List_Temp     # Successive Passes
                    fi
                fi
            fi
            if [[ $Demo_Track -eq $Drive_Count ]]; then break; fi
            (( Demo_Track ++ ))
            (( Demo_loop ++ ))
        done

 #       echo -n "    Drive Testing List:"
 #       echo -e "    "$Drive_List | tee -a /tmp/drive_test_temp.txt
        drives_to_test=$smartdrives_sorted
	fi	
	
    if [[ $Test_Mode -eq 3 ]]; then		# No Testing
		drives_to_test=""
    fi
	
    drives_tested_demo=""            # Needed to clear this variable for the second pass.  CHECK TO INITIALIZE ALL USED VARIABLES AT THE BEGINNING OF THE SCRIPT/FUNCTION CALL
    
    if [[ $Drives_Tested_Days_of_the_Week == *"$DOW"* ]] || [[ $Demo == "true" ]]; then                        # Is today a valid test day?
        if [[ $Test_Mode -eq 1 ]]; then

            Days_Authorized_in_Week=$(echo "$Drives_Tested_Days_of_the_Week" | tr ',' ' ' | wc -w | xargs )     # This holds numbers of the days 1,2,3...
            Days_Authorized_in_Month=$(( 4 * Days_Authorized_in_Week ))  #  4 weeks * 2 days a week = 8 days to test.
 
            if [[ $(( Drives_to_Test_Per_Day * 10 )) -lt $((( Drive_Count * 10 ) / Days_Authorized_in_${Drives_Test_Period} )) ]]; then
					if [[ $Silent != "true" ]]; then
					(	echo " "
						echo "DANGER Will Robinson, you have $Drive_Count drives and "$(( Days_Authorized_in_${Drives_Test_Period} ))" authorized days to test."
						echo "ROBOT will make adjustments, please wait.... Geez that was fast!"
						echo "Maybe you need more drives, Waka Waka! ROBOT made a funny."
					) | tee -a /tmp/drive_test_temp.txt
					fi

                Drives_to_Test_Per_Day=$((( Drive_Count * 10 ) / Days_Authorized_in_${Drives_Test_Period} ))   #  28/6 = 5.xxx = 6
                if [[ ${Drives_to_Test_Per_Day: -1} != "0" ]]; then
					Drives_to_Test_Per_Day=$(((Drive_Count / Days_Authorized_in_${Drives_Test_Period}) + 1))
				else
					Drives_to_Test_Per_Day=$((Drive_Count / Days_Authorized_in_${Drives_Test_Period}))
				fi
					if [[ $Silent != "true" ]]; then
					(	echo "Recalculation Complete, the new value is $Drives_to_Test_Per_Day drive(s) spread across the "$(( Days_Authorized_in_${Drives_Test_Period} ))" authorized days."
						echo " "
					) | tee -a /tmp/drive_test_temp.txt
					fi
            fi

            ### Setup variables:
            First_DOM=1                  # Set First_DOM to the first day of the month.
            Temp_drives_tested=0         # Initial value, meaning no drives to test.
            Temp2_DOW=$DOW               # Set Temp2_DOW to DOW which makes Temp2_DOW = 4 (Thursday)
            DOW_temp=$DOW                # Start with current DOW
            valid_today=0
            test_it=0                    # If set to other than 0, testing is needed.
            drives_already_tested=0      # Total number of drives previously scheduled tested.  The next number is the drive to be tested if test_it != 0.

            if [[ $Drives_Test_Period == "Month" ]]; then            # THIS IS FOR MONTHLY
                list_monthly_output
            else                # THIS IS FOR THE WEEKLY
                list_weekly_output       # Call routine
            fi
        fi
    fi

# TESTING
    if [[ $1 == "Short" ]]; then selftest_drives_short=$drives_to_test; fi
	if [[ $selftest_drives_short == "all" ]]; then
		selftest_drives_short=$smartdrives
		if [[ $Silent != "true" ]]; then
			echo "ALL DRIVES - SHORT" | tee -a /tmp/drive_test_temp.txt
		fi
	fi
    if [[ $1 == "Long" ]]; then selftest_drives_long=$drives_to_test; fi
	if [[ $selftest_drives_long == "all" ]]; then
		selftest_drives_long=$smartdrives
		if [[ $Silent != "true" ]]; then
			echo "ALL DRIVES - LONG" | tee -a /tmp/drive_test_temp.txt
		fi
	fi

    # Call SMART Test routine.  Pass $1=Short/Long
    if [[ $Demo != "true" ]] && [[ $Ready_to_Test == "true" ]]; then	# Ready_to_Test means the Short and Long drive schedules are complete and actual testing may start.

# We need to not start the smart testing until after we process both Short and Long drive lists to test.
 
		remove_duplicate_tests
	else
		# We have not processed the Long tests yet.
		Ready_to_Test="true"		# This is good for the second pass now.
    fi


	if [[ $softver != "Linux" ]]; then
		end_time_display=$(date '+%H:%M:%S')
	else
		elapsed_time $start_time_display
	fi
	
	(echo "        "$end_time_display":  EXIT smartctl_selftest"
	echo -n "        Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
		if [[ $end_tenths != "" ]]; then
			echo ".$end_tenths seconds elapsed."
		else
			echo " seconds elapsed."
		fi
		echo " ") >> /tmp/drive_test_timer_temp.txt
	
    }

# CALLED FROM ONE LOCATION
list_monthly_output () {

# This will generate the MONTHLY screen output for the drives tested.
#
# Global Variables: Demo, DOW, softver, Drive_List_Length, Drive_Count, drives_to_test
# Local Variables: drives_to_list, total_drives_tested_per_day, sum_drives_test, DOW_temp, day_of_month, loop_counter, array_location, valid_today, first_DOW, test_it
# Local Variables: today_weekday, debian_day_of_month, pretext, gap_characters, pretext_length, drive_list_length_counter, drives_to_list_x, drives_already_tested
#
#echo -n "4"
	(echo "            "$start_time_display":  START list_monthly_output") >> /tmp/drive_test_timer_temp.txt

    DOW_temp=$DOW                                    # Use a temporary variable to add/subtract with.
    drives_to_list=""                                # Listing a grouping of drive ids.
    total_drives_tested_per_day=0                    # Might be able to use a fixed number vice a variable.
    sum_drives_test=0                                # Total of drives tested?
    day_of_month=1                                   # Set the first of the month.
    loop_counter=0                                   # Just a counter.
    array_location=1                                 # Presetting the variable 
    drives_tested_demo=""
    echo " "
    while [ $(( 10#$day_of_month )) -le 28 ]; do                                  # 1. Start a loop from 1 to 28 to represent the 28 days of any given month.
        valid_today=0                                                   # Reset for current day check.
        if [[ $softver != "Linux" ]]; then                              # FreeBSD or Debian?
            first_DOW=$(date -v${day_of_month#0}d +%u)                    # What is the day of the week for the set date?
            today_weekday=$(date -v${day_of_month#0}d +%A)                # What is the 
        else
            debian_day_of_month="$(printf "%02d" ${day_of_month#0})"
            first_DOW=$(date -d "$(date +%Y%m${debian_day_of_month})" +%u)
            today_weekday=$(date -d "$(date +%Y%m${debian_day_of_month})" +%A)
        fi
        pretext=$today_weekday" "$(printf "%02d" ${day_of_month#0})" "$Full_Month_Name"\nDrive IDs: "
        gap_characters="----------"
        if [[ $Drives_Tested_Days_of_the_Week == *"$first_DOW"* ]]; then                                # 2. Check if today is an authorized day.
            valid_today=1                                                                               #    Mark this a authorized.
            total_drives_tested_per_day=$(( total_drives_tested_per_day + Drives_to_Test_Per_Day ))                            
            sum_drives_test=0
            loop_counter=0                         # Set the start count of the loop to define how many drives per line
            drive_list_length_counter=0            # Set the first or successive lines count
            drives_to_list=""
            previous_drives_tested_count=0         # Keep a running count of all the drives tested.
                        
            while [ $sum_drives_test -lt $Drives_to_Test_Per_Day ]; do
                drives_to_list_x=$(echo $smartdrives_sorted | cut -d' ' -f${array_location} | xargs)            # Grab next array variable (drive ID)
                if [[ $drives_to_list_x == "" ]]; then break; fi                                                # Jump out of while loop if no more drives to list
                    if [[ $drive_list_length_counter -lt $Drive_List_Length ]]; then                            # grab the first ten
                    if [[ $drives_to_list == "" ]]; then
                        drives_to_list=$drives_to_list_x
                    else
                        (( drive_list_length_counter ++ ))                            # Increment the loop counter
                        if [[ $Demo == "true" ]]; then                                # For display only
                            drives_to_list=$drives_to_list", "$drives_to_list_x
                        else
                            drives_to_list=$drives_to_list" "$drives_to_list_x
                        fi
                    fi
                else
                    drive_list_length_counter=0                                                  # Reset loop counter2 to 0 that count how many drives are in a line
                    drives_to_list=$drives_to_list"\n"$gap_characters" "$drives_to_list_x        # Now we add a new line, the gap spacing, and new drive ID
                fi
            (( sum_drives_test ++ ))
            (( array_location ++ ))
            (( previous_drives_tested_count ++ ))
            done
            if [[ $Demo == "true" ]]; then        # WHY IS THIS ONLY FOR DEMO? IT WILL LIST ALL THE DAYS OF THE DRIVES IF DISABLED.  LEAVE IN PLACE !
                if [[ $drives_to_list == "" ]]; then drives_to_list=" Nothing To Test This Day"; fi
                echo -e $pretext$drives_to_list | tee -a /tmp/drive_test_temp.txt
            fi
echo $day_of_month" --- "$today_day" --- "$drives_tested_demo
            if [[ $(( 10#$day_of_month )) -lt $(( 10#$today_day )) ]]; then
			echo "k"
#				if ! [[ $drives_tested_demo =~ $drives_to_list ]]; then
                drives_tested_demo=$drives_tested_demo" "$drives_to_list
#				fi
            fi

            if [[ $Demo != "true" ]] && [[ $(( 10#$day_of_month )) -eq $(( 10#$today_day )) ]]; then break; fi        # THIS SHOULD EXIT WHEN WE HIT TODAY
        fi
        (( day_of_month ++ ))
    done

    if [[ $Demo == "true" ]]; then return;fi
    if [[ ! $drives_already_tested -ge $Drive_Count ]]; then                                      # We match and have to test
        test_it=1
		if [[ $Silent != "true" ]]; then
			echo "    Drive(s) previously scheduled to be tested: "$drives_tested_demo | tee -a /tmp/drive_test_temp.txt
			echo -e $(wc -w <<< "$drives_to_list" | xargs)" Drive(s) testing today: "$drives_to_list | tee -a /tmp/drive_test_temp.txt
		fi
        drives_to_test=$drives_to_list
    else
		if [[ $Silent != "true" ]]; then
			if [[ $valid_today -eq 1 ]]; then echo "    All Scheduled Drives Complete" | tee -a /tmp/drive_test_temp.txt; fi
		fi
    fi
    echo " "

	if [[ $softver != "Linux" ]]; then
		end_time_display=$(date '+%H:%M:%S')
	else
		elapsed_time $start_time_display
	fi
	
	(echo "            "$end_time_display":  EXIT list_monthly_output"
	echo -n "            Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
		if [[ $end_tenths != "" ]]; then
			echo ".$end_tenths seconds elapsed."
		else
			echo " seconds elapsed."
		fi
		echo " ") >> /tmp/drive_test_timer_temp.txt

    }

# CALLED FROM ONE LOCATION
list_weekly_output () {

# This will generate the WEEKLY screen output for the drives tested.
#
# Global Variables: Demo, Drive_Count, Drives_Tested_Days_of_the_Week, smartdrives_sorted, 
# Local Variables: First_DOM, drives_already_tested, valid_today, drives_already_tested, test_it, drives, DOW_temp, drives_to_test, drives_tested_demo?
#
#echo -n "5"
	(echo "            "$start_time_display":  START list_weekly_output") >> /tmp/drive_test_timer_temp.txt

    ### Setup variables:
    First_DOM=1        # Set First_DOM to the first day of the month.
    Temp_drives_tested=0    # Initial value, meaning no drives to test.
    DOW_temp=$DOW    # Start with current DOW
    valid_today=0
    test_it=0                # If set to other than 0, testing is needed.
    drives_already_tested=0            # Total number of drives previously scheduled tested.  The next number is the drive to be tested if test_it != 0.
	if [[ $Debug == "true" ]]; then
		echo "Debug - Drive Names="$Drives_name
		echo "Debug - Drive Count="$Drive_Count
		echo "Debug - Drives Already Tested="$drives_already_tested
		echo "Debug - Drives To Test="$drives_to_test
	
	fi

    while [ $First_DOM -le 7 ]; do
        valid_today=0
        if [[ $First_DOM -lt $DOW ]]; then                        # Is it less than today, then allow evaluation for previous matches.
            if [[  $Drives_Tested_Days_of_the_Week == *"$First_DOM"* ]]; then
                valid_today=1
                if [[ $drives_already_tested -lt $Drive_Count ]]; then
                    drives_already_tested=$(( drives_already_tested + Drives_to_Test_Per_Day ))                      # Increment sum_drives_test+per_day
                    if [[ $drives_already_tested -gt $Drive_Count ]]; then drives_already_tested=$Drive_Count; fi    # This adjusts to the remainder at the end of the drive list
                fi
            fi
        fi
        First_DOM=$(( First_DOM + 1 ))    # Increment to next day of the week
    done
    First_DOM=$(( First_DOM - 1 ))    # Decrement day of week evaluation to offset above addition before exit.
    if [[  $Drives_Tested_Days_of_the_Week == *"$First_DOM"* ]]; then valid_today=1; fi

    if [[ ! $drives_already_tested -ge $Drive_Count ]]; then                        # We match and have to test
        test_it=1
    else
		if [[ $Silent != "true" ]]; then
			if [[ $valid_today -eq 1 ]]; then echo "All Scheduled Drives Complete" | tee -a /tmp/drive_test_temp.txt; fi
		fi
    fi 
    Temp_drives_tested=$drives_already_tested
    drives_to_test=""
    drives_tested_demo=""

    if [[ $test_it -eq 1 ]]; then
        DOW_temp=0
        if [[ $Temp_drives_tested -lt $Drive_Count ]]; then                         # $Temp_drives_tested=$x1  Temp_drives_tested=Drive Count
            for drives in $smartdrives_sorted; do                                   # Lets peel off the tested drives.
                # Loop $DOW_temp times
                DOW_temp=$(( DOW_temp + 1 ))                                        # Add 1 to the drive count: represents ?
                if [[ $DOW_temp -gt $Temp_drives_tested ]] && [[ $DOW_temp -lt $(( Temp_drives_tested + Drives_to_Test_Per_Day + 1 )) ]]; then   # DOW_temp -gt Drive Count && DOW_temp -lt (( Drive Count + Drives Per Day + 1))
                    drives_to_test=$drives_to_test" "$drives
                else
                    if ! [[ $DOW_temp -gt $Temp_drives_tested ]]; then
                        if [[ $drives_tested_demo == "" ]]; then
                            drives_tested_demo=$drives
                        else
                            drives_tested_demo=$drives_tested_demo", "$drives
                        fi
                    fi
                fi
            done
        fi
    fi

    if [[ $drives_to_test != "" ]]; then
        drives_to_test=$(echo "$drives_to_test" | xargs)
    fi

    if [[ $Test_Mode -eq 2 ]]; then
		if [[ $Silent != "true" ]]; then
			(echo "All $(wc -w <<< "$smartdrives" | xargs) drives will be tested each time the script it run."
			echo " ") | tee -a /tmp/drive_test_temp.txt
		fi
        return
    fi

    Drive_List=""
    Demo_Track=1            # Keeping track on where we are in the drive day list (Mon, Tue)
    IFS=","

    for Demo_Authorized_Days in $Drives_Tested_Days_of_the_Week; do             # Loop through the authorized days

        case $Demo_Authorized_Days in                                           # Lets give us authorized days of the week.
            1)    day_of_week="Monday"    ;;
            2)    day_of_week="Tuesday"    ;;
            3)    day_of_week="Wednesday"    ;;
            4)    day_of_week="Thursday"    ;;
            5)    day_of_week="Friday"    ;;
            6)    day_of_week="Saturday"    ;;
            7)    day_of_week="Sunday"    ;;
        esac
        IFS=$IFS_RESTORE


        if [[ $Demo == "true" ]]; then
			(echo " "; echo $day_of_week":"
			) | tee -a /tmp/drive_test_temp.txt
		fi

        # FOR WEEKLY RESULTS
        Demo_loop=0
        while [ $Demo_loop -lt $Drives_to_Test_Per_Day ]; do        # We are on more than 3 drives per day
            Drive_List_Temp=$(echo $smartdrives_sorted | cut -d ' ' -f ${Demo_Track} | xargs)
            if [[ $Drive_List != *"${Drive_List_Temp}"* ]]; then
                if [[ $Demo_loop -eq 0 ]]; then
                    Drive_List=$Drive_List_Temp                                 # First Pass
                else
                    if [[ $loop_counter -eq $Drive_List_Length ]]; then
                        Drive_List=$Drive_List",\n "$Drive_List_Temp
                        loop_counter=0
                    else
                        (( loop_counter ++ ))
                        Drive_List=$Drive_List", "$Drive_List_Temp              # Successive Passes
                    fi
                fi
            fi
            if [[ $Demo_Track -gt $Drive_Count ]]; then    break; fi            # Drive_List=""; fi
            (( Demo_Track ++ ))
            (( Demo_loop ++ ))
        done
        if [[ $Demo == "true" ]]; then
            if [[ $Drive_List == "" ]]; then Drive_List="No Remaining Drives"; fi
            echo -e " "$Drive_List | tee -a /tmp/drive_test_temp.txt
        fi
        Drive_List=""
    done
    echo " " | tee -a /tmp/drive_test_temp.txt
    IFS=$IFS_RESTORE
    if [[ $Demo != "true" ]]; then
	(	if [[ $drives_tested_demo == "" ]]; then
			if [[ $Silent != "true" ]]; then
				echo "    Drive(s) previously scheduled to be tested: None"
			fi
		else
			if [[ $Silent != "true" ]]; then
				echo "    Drive(s) previously scheduled to be tested: "$drives_tested_demo
			fi
		fi
		if [[ $drives_to_test == "" ]]; then
			if [[ $Silent != "true" ]]; then
				echo "    Drives scheduled for testing today: None"
			fi
		else
			if [[ $Silent != "true" ]]; then
				echo "    Drive(s) scheduled for testing today: "$drives_to_test
			fi
		fi
		echo " ") | tee -a /tmp/drive_test_temp.txt
    fi
		
	if [[ $softver != "Linux" ]]; then
		end_time_display=$(date '+%H:%M:%S')
	else
		elapsed_time $start_time_display
	fi
	
	(echo "            "$end_time_display":  EXIT list_weekly_output"
	echo -n "            Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
		if [[ $end_tenths != "" ]]; then
			echo ".$end_tenths seconds elapsed."
		else
			echo " seconds elapsed."
		fi
		echo " ") >> /tmp/drive_test_timer_temp.txt

    }


##### GET DRIVE SERIAL NUMBERS VIA SMARTCTL TO SEE IF THIS IS FASTER OR NOT.  ALSO KEEP IS AS A BACKUP ROUTINE.
# STILL NEED TO BE CHANGED FROM API TO SMARTCTL.

# CALLED FROM ONE LOCATION
sort_serial_number () {
# This routine performs three things:
#  1. Sorts the drive serial numbers.
#  2. Places the drive ids ($smartdrives_sorted) in the same order as the sorted serial numbers.
#  3. NVMe drive names are properly formatted.
#
# Global Variables: api_drive_serial_number, smartdrives_sorted
# Local Variables: api_x, api_y, api_drive_name, api_drive_name_test, api_drive_serial_order, Serial_Length, 
#
# Input - api_drive_serial_number, Output - smartdrives_sorted
#echo -n "6"
	(echo "            "$start_time_display":  START sort_serial_number") >> /tmp/drive_test_timer_temp.txt
	
    api_x=0
    api_y=0
    api_drive_name=""
	if [[ $Silent != "true" ]]; then
		(echo " "
		echo -n "    Sorting Drive Test Order ") | tee -a /tmp/drive_test_temp.txt
	fi
    for api_drive_serial_order in $api_drive_serial_number; do
        while [[ "$(echo $Drive_Disk_Query  | jq -r '.['$api_y'].name')" != "null" ]]; do    # Loop through all of the drives comparing S/N Order to drive
            api_drive_serial_test=$(echo $Drive_Disk_Query  | jq -r '.['$api_y'].serial')
            if [[ $Silent != "true" ]]; then
				echo -n "." | tee -a /tmp/drive_test_temp.txt
			fi
            Serial_Length=$(wc -c <<< "$api_drive_serial_test")                              # Too short of a S/N (3 characters or less) = Not Valid Drive
            if [[ $Serial_Length -gt 3 ]]; then
                if [[ $api_drive_serial_order == "$api_drive_serial_test" ]]; then
                    api_drive_name_test=$(echo $Drive_Disk_Query  | jq -r '.['$api_y'].name')
                    if [[ $softver != "Linux" ]]; then
                        api_drive_name=$api_drive_name" "$api_drive_name_test" "
                    else
                        if [[ $api_drive_name_test == *"nvme"* ]]; then
                            api_drive_name=$api_drive_name" "$(echo "nvme"$(echo $api_drive_name_test | sed -r 's#^nvme##' | cut -d 'n' -f 1)" ")
                        else
                            api_drive_name="$api_drive_name $api_drive_name_test "
                        fi
                    fi
                    break
                fi
            fi
            ((api_y ++))
        done
        api_y=0
        ((api_x ++))
    done
	if [[ $Silent != "true" ]]; then
		echo " " | tee -a /tmp/drive_test_temp.txt
	fi
    smartdrives_sorted=$(echo "$api_drive_name" | xargs |  sed 's/nvd/nvme/g' )

	if [[ $softver != "Linux" ]]; then
		end_time_display=$(date '+%H:%M:%S')
	else
		elapsed_time $start_time_display
	fi
	
	(echo "            "$end_time_display":  EXIT sort_serial_number"
	echo -n "            Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
		if [[ $end_tenths != "" ]]; then
			echo ".$end_tenths seconds elapsed."
		else
			echo " seconds elapsed."
		fi
		echo " ") >> /tmp/drive_test_timer_temp.txt
	
    }


########## RUN NVMe SELFTEST ##########
# CALLED FROM ONE LOCATION
nvm_selftest () {

# $1 is Long or Short
#
# Global Variables: $1, softver, Wait_For_SMART_Short_Test, Wait_For_SMART_Long_Test, drive
# Local Variables: check_nvme_selftest, smart_selftest
#
#echo -n "7"
	(echo "                    "$start_time_display":  START nvm_selftest") >> /tmp/drive_test_timer_temp.txt
	# This check should not be required as this function is only called if nvme commands are required.
	# I may need to change this to only check smartmontools if it is version 7.4, regardless of if it is not completely compatible until version 7.5.
	if ! [[ $programver3 -lt 24 ]] || [[ $programver3 -eq 13 && $programver4 -eq 3 ]]; then			# Check if we are using TrueNAS which supports nvme testing, after version 24.04 ?
		# Use smartctl
		echo "Version 13.3 (CORE) or 24 (SCALE) or greater."
		if [[ $1 == "Long" ]]; then
			smartctl -t long /dev/$drive
		else
			smartctl -t short /dev/$drive
		fi
	else
		NVMe_Override_Enabled="true"
		echo "Using direct nvme commands to test nvme drives." | tee -a /tmp/drive_test_temp.txt
		# FIRST KICK OFF EACH TEST
		if [ $softver != "Linux" ]; then
			# FreeBSD Commands
			check_nvme_selftest=$(nvmecontrol identify "$drive" | grep -i "self-test")
			shopt -s nocasematch  # Make test not case sensitive
			if [[ $check_nvme_selftest != *"Not"* ]]; then
				if [[ $Silent != "true" ]]; then
					if [[ $1 == "Long" ]]; then
						echo "Running $1 Self-test for $drive" | tee -a /tmp/drive_test_temp.txt
					else
						echo "Running $1 Self-test for $drive" | tee -a /tmp/drive_test_temp.txt
					fi
				fi
				if [[ "$1" != "Long" ]]; then    #Default run Short self-test.
					smart_selftest="1"
				else
					smart_selftest="2"
				fi
				nvmecontrol selftest -c $smart_selftest "$drive"
			else
				echo "$drive does not support Self-test" | tee -a /tmp/drive_test_temp.txt
			fi
			shopt -u nocasematch
		else
			# Debian Commands
			check_nvme_selftest=$(nvme id-ctrl /dev/"$drive" -H | grep -i "self-test")
			if [[ $check_nvme_selftest != *"Not"* ]]; then
				if [[ $Silent != "true" ]]; then
					if [[ $1 == "Long" ]]; then
						echo "Running $1 Self-test for $drive in background " | tee -a /tmp/drive_test_temp.txt
					else
						echo "Running $1 Self-test for $drive" | tee -a /tmp/drive_test_temp.txt
					fi
				fi
				if [[ "$1" != "Long" ]]; then
					smart_selftest="1"
				else
					smart_selftest="2"
				fi
				nvme device-self-test /dev/"$drive" -s $smart_selftest
			else
				echo "$drive does not support Self-test" | tee -a /tmp/drive_test_temp.txt
			fi
		fi
	fi
	
	if [[ $softver != "Linux" ]]; then
		end_time_display=$(date '+%H:%M:%S')
	else
		elapsed_time $start_time_display
	fi
	
	(echo "                    "$end_time_display":  EXIT nvm_selftest"
	echo -n "                    Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
		if [[ $end_tenths != "" ]]; then
			echo ".$end_tenths seconds elapsed."
		else
			echo " seconds elapsed."
		fi
		echo " ") >> /tmp/drive_test_timer_temp.txt	

    }


########## GET DRIVE LISTINGS
# CALLED FROM ONE LOCATION
get_API_Drives () {
# Replaces all the drive listing procedures.
# Input = Nothing
# Output = List of each drive TrueNAS recognizes along with (within an array; Drive Name, Model, Serial Number, Interface Type) and the full Drive Query output.
#
# Global Variables: Debug, Drive_Disk_Query, smartdrives, drives_name[@], drives_serial[@], drives_subsystem[@], drives_model[@]
# Local Variables: index, increment
#
#echo -n "8"
	(echo "    "$start_time_display":  START get_API_Drives") >> /tmp/drive_test_timer_temp.txt

# Setup local variables
    index=0            # INDEX IS THE REPORTED BACK DRIVES
    increment=0        # INCREMENT IS THE ACCESS TO THE FULL ARRAY, INCLUDING VIRTUAL AND CD DRIVES
	skip_drives_count=0

    if [[ $Debug == "true" ]]; then    echo "Debug - Function 'get_API_Drives'"; echo " "; fi
		if [[ $Test_ONLY_NVMe_Drives == "true" ]]; then
			echo "Testing ONLY NVMe Drives" | tee -a /tmp/drive_test_temp.txt
		fi
    Drive_Disk_Query=$(midclt call disk.query)

    # 1. Get all API data in a variable, one call. -- Can we find API that says SMART Self-test is supported or not?  May need to use smartctl for one thing.
	#    `supports_smart:null`, maybe check if null and if so or `no`, use smartctl.
    # 2. Get Drive data into an array

    drives_name=$(echo $Drive_Disk_Query | jq '.[].name' | tr -d '"')            # get all the drive names
 
    for i in $drives_name; do
        drives_model[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.model')
        drives_name[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.name')
        drives_serial[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.serial' | tr -d ' ')		# "td -d ' '" removes any white space from the serial number

	# WE NEED TO WEED OUT ALL BUT NVD/NVME DRIVES IF NVME TEST ONLY OPTION SET
		if [[ $Test_ONLY_NVMe_Drives == "true" ]]; then
			# WE NEED TO LET PASS ONLY NVD/NVME HERE
			if [[ ${drives_name[$index]} == "nvme"* ]] || [[ ${drives_name[$index]} == "nvd"* ]]; then
				if [[ $Debug == "true" ]]; then
					echo "continue "$i
				fi
			else
				if [[ $Debug == "true" ]]; then
					echo "Virtual "$i
				fi
				drives_model[$index]="Virtual"			# Change all non NVD/NVME drives to Virtual, Crappy Hack But it Works?
			fi
		fi


    # WE NEED TO WEED OUT VIRTUAL AND CD DRIVES AND IGNORE LIST DRIVES
        if [[ ${drives_model[$index]} == *"Virtual"* ]] || [[ ${drives_name[$index]} == "cd"* ]] || [[ $Ignore_Drives_List =~ ${drives_serial[$index]} ]]; then
			(( skip_drives_count ++ ))
            if [[ $Debug == "true" ]] || [[ $Demo == "true" ]] || [[ $timer_flag -eq 1 ]] ; then
				if [[ $Ignore_Drives_List =~ ${drives_serial[$index]} ]]; then
					if [[ $Silent != "true" ]]; then
						echo "Skip Ignored Drive(s): "${drives_name[$index]} | tee -a /tmp/drive_test_temp.txt
					fi
					skip_drives_ignore=$skip_drives_ignore", "${drives_name[$index]}"("${drives_serial[$index]}")"
				else
					if [[ $Silent != "true" ]]; then
						echo "Skip Virtual Drive(s): "${drives_name[$index]} | tee -a /tmp/drive_test_temp.txt
					fi
					skip_drives_virtual=", "${drives_name[$index]}
				fi
			fi
            (( increment ++ ))
            continue
		fi

        if echo ${drives_name[$index]} | grep -q -i "nvd"; then
            drives_name[index]="$(echo ${drives_name[index]} | sed 's/nvd/nvme/g')"
        elif echo ${drives_name[$index]} | grep -q -i "nvme"; then
            drives_name[index]="$(echo "nvme"$(echo ${drives_name[$index]} | sed -r 's#^nvme##' | cut -d 'n' -f 1))"
        fi

        drives_subsystem[index]=$(echo $Drive_Disk_Query | jq -Mre '.'[$increment]'.subsystem')
        (( index ++ ))
        (( increment ++ ))
    done
	

    # If the last drive at the end jumps out and is a virtual or cd drive, remove it.
	if [[ ${drives_model[$index]} == *"Virtual"* ]] || [[ ${drives_name[$index]} == "cd"* ]] || [[ $Ignore_Drives_List =~ ${drives_serial[$index]} ]]; then drives_name[index]=""; drives_serial[index]=""; fi

    drives_count=$(echo ${drives_name[@]} | wc -w)

    smartdrives=${drives_name[@]}
    if [[ $Debug == "true" ]]; then
        index=0
        for i in ${drives_name[@]}; do
            echo -n "Debug - Drive ID="${drives_name[$index]}
            echo -n ", Drive S/N="${drives_serial[$index]}
            echo -n ", Drive Model="${drives_model[$index]}
            echo ", Drive Subsystem="${drives_subsystem[$index]}
            (( index ++ ))
        done
        echo " "
        echo "Debug - Total Drives="$drives_count
        echo "Debug - Drive Names="${drives_name[@]}
        echo "Debug - Drives Serial Numbers="${drives_serial[@]}
        echo " "
        echo "Debug - Leaving function 'get_API_Drives'"
    fi

	skip_drives_ignore="Ignored: "${skip_drives_ignore:1}
	skip_drives_virtual="Virtual: "${skip_drives_virtual:1}
	
	(echo "    Good Drive Count: "$drives_count
	if [[ $skip_drives_ignore != "" || $skip_drives_virtual != "" ]]; then echo "    Drives Removed: "$skip_drives_count" : "$skip_drives_virtual", "$skip_drives_ignore; fi

	if [[ $softver != "Linux" ]]; then
		end_time_display=$(date '+%H:%M:%S')
	else
		elapsed_time $start_time_display
	fi
	
	echo "    "$end_time_display":  EXIT get_API_Drives"
	echo -n "    Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
		if [[ $end_tenths != "" ]]; then
			echo ".$end_tenths seconds elapsed."
		else
			echo " seconds elapsed."
		fi
		echo " ") >> /tmp/drive_test_timer_temp.txt
		
echo 

    }

########## SORT ROUTINE ##########

sort_data () {
# Global Variables: sort_list
# Local Variables: i
#echo -n "8"
	(echo "            "$start_time_display":  START sort_data '$1'") >> /tmp/drive_test_timer_temp.txt

	if [ $softver != "Linux" ]; then
    sort_list=$(for i in $sort_list; do
        echo "$i"
		done | sort -V)
	else
		sort_list_short=$(for i in $sort_list; do
			echo "$i"
		done | awk 'length<4' | sort -V)
		sort_list_long=$(for i in $sort_list; do
			echo "$i"
		done | awk 'length>3' | sort -V)
		sort_list=$sort_list_short" "$sort_list_long
		sort_list="$(echo "$sort_list" | tr -s " ")"
	fi
	
	if [[ $softver != "Linux" ]]; then
		end_time_display=$(date '+%H:%M:%S')
	else
		elapsed_time $start_time_display
	fi
	
	(echo "            "$end_time_display":  EXIT sort_data"
	echo -n "            Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
		if [[ $end_tenths != "" ]]; then
			echo ".$end_tenths seconds elapsed."
		else
			echo " seconds elapsed."
		fi
		echo " ") >> /tmp/drive_test_timer_temp.txt

	}


	delete_log_files () {
	# This function will detect and delete all the log file created by this script.
	
    if ls drive_selftest_demo_??.txt 1> /dev/null 2>&1; then echo "Removing Demo Log Files"; rm drive_selftest_demo_??.txt; else echo "No demo log files to remove."; fi
	if ls drive_selftest_??.txt 1> /dev/null 2>&1; then echo "Removing Log Files"; rm drive_selftest_??.txt; else echo "No log files to remove."; fi

	}
	
	
	elapsed_time () {
	# Pass the starting time value.  Only for Linux.
		end_time_display=$(date +"%H:%M:%S.%2N")
		time_diff=$(($(date -d "$end_time_display" '+%s%2N') - $(date -d "$1" '+%s%2N')))
		rev_time=$(echo $time_diff | rev)
		end_tenths=$(echo ${rev_time:0:2} | rev)
		end_time=$(echo ${rev_time:2} | rev)
		SECONDS=$end_time
	}


# CALLED FROM TWO LOCATIONS    
help_text () {
    clear
    echo "SMART Drive Self-test Script: "$Version" "$Version_Date
	echo "Companion to Multi-Report 3.1 and later."
    echo " "
    echo "Edit lines (around line number 70) '######### USER SETTINGS #########' as desired."
    echo " "
    echo "There are five groups of variables: Automatic Update, Short tests, Long tests,"
	echo "Ignore Drives, and Reports."
	echo " "
    echo "Automatic Updates will allow the drive_selftest.sh file to be updated should it be out of date."
	echo " "
	echo "This script can use the multi_report_config.txt file when combined with Multi-Report."
	echo "You must configure these settings in Multi-Report, otherwise the values at the top"
	echo "of the script will be used."
	echo " "
	echo "Short and Long tests are configured as follows:"
	echo " "
	echo "  Test_Mode: 1 = Use Short(or Long) Drives_to_Test_Per_Day value"
    echo "             2 = All Drives Tested (Ignores other options except when active)"
    echo "             3 = No Drives Tested"
    echo " "
    echo "  Time_Delay_Between_Drives: Tests will have a XX second delay between the"
    echo "  drives starting testing."
	echo " "
	echo "  Short_Drives_Test_Delay: Time period in seconds to wait for SHORT tests to complete."
	echo "  Default is 130 seconds for use with Multi-Report, if not then set to 1 second."
    echo " "
    echo "BELOW OPTIONS ARE USED ONLY WITH Test Mode 1"
    echo "--------------------------------------------"
    echo " "
    echo '  SMART_Testing_Order: Select "DriveID" or "Serial" sorting order.'
    echo " "
    echo "  Drives_to_Test_Per_Day: How many drives to run each day minimum."
    echo "  The script will auto-correct if you choose too small of a value."
    echo " "
    echo '  Drives_Test_Period: Options are "Week" (Mon-Sun) or "Month" (days 1 - 28)'
    echo " "
    echo "  Drives_Tested_Days_of_the_Week: Days of the week allowed to run:"
    echo '  1=Mon, 2=Tue, 3=Wed, 4=Thu, 5=Fri, 6=Sat, 7=Sun  Default = "1,2,3,4,5,6,7"'
    echo " "
	echo "Press Any Key to Continue"
	read -s -n 1 key_input
    echo "--------------------------------------------------------------------------"
	echo " "
	echo "NORMAL OPERATION DOES NOT REQUIRE ANY COMMAND LINE SWITCHES"
	echo " "
	echo "Command Line Switches:"
    echo "NOTE! The demo mode uses the 'Drives_Tested_Days_of_the_Week' value to"
    echo "calculate how many drives are to be run on which days of the week."
	echo "If the demo results are not the desired effect, adjust the values."
    echo " "
	echo "    '-timer' --- Generates a file which tracks how many seconds are utilized"
	echo "                 for each routine within the script.  Used for development."
	echo " "
    echo "    '-demo' '[short|long]' '[1|2|3]' '[week|month]' '[driveid|serial]'"
    echo "        Lists full drive testing schedule."
    echo "        Use short or long options to focus on one list."
    echo "        Override Settings will not use the script set values."
    echo "            Test Mode using '1','2', or '3'."
    echo "            Testing Period 'week' or 'month'."
    echo " "
    echo "    '-clearlog' --- Delete all the drive_selftest log files."
    echo " "
	echo "    '-debug'    --- Runs the script in Debug Mode"
	echo " "
    echo "Example: drive_selftest -demo short 1 week serial"
    echo " Means: Simulate Short SMART Test, Test Mode 1 to spread across a Week"
	echo " and using the days of the week set in the script setup."
    echo " "
    echo "Example: drive_selftest -demo short"
    echo " Means: Simulate a Short SMART Test using the current configured settings"
    echo " "
    echo "This will provide a listing of how your drives would be tested for"
    echo "a short test in Test Mode 1, providing you the dates they would be tested."
    echo " "
	echo "Do you want to read a detailed explanation? (Y/N)"
    read -s -n 1 key_input
    if [[ $key_input == "y" ]] || [[ $key_input == "Y" ]]; then detailed_explanation; fi
    echo "Do you want to read Troubleshooting Help? (Y/N)"
    read -s -n 1 key_input
    if [[ $key_input == "y" ]] || [[ $key_input == "Y" ]]; then troubleshooting_help; fi

    exit 0
    }

#CALLED FROM ONE LOCATION
detailed_explanation () {
    clear
    echo "Detailed Explanation of the script.                 Version: "$Version" "$Version_Date
    echo " "
    echo "WHAT DOES THIS SCRIPT DO?"
    echo " "
    echo "This script was designed for people with a large amount of drives"
    echo "and do not want to schedule each drive individually for SMART testing."
	echo "The script also augments Multi-Report 3.1 SMART testing."
    echo " "
    echo "The script will spread out the SMART SHORT and LONG/EXTENDED tests"
    echo "in three possible ways, or the option to not test at all:"
    echo "  1. Spread across a week (on specified days of the week)"
    echo "  2. Spread across a month (on specified days of the week)"
    echo "  3. All drives (on specified days of the week)"
    echo "  4. Or no drives at all."
    echo " "
    echo "  Specified days of the week are: 1=MON, 2=TUE, 3=WED, 4=THU, 5=FRI,"
    echo "  6=SAT, 7=SUN."
    echo " "
	echo "Lets break this down into the individual variables you should be setting."
	echo " "
	echo "At the top of the script is the user settings area and here are the variables:"
	echo " "
	echo "Press Any Key to Continue"
	read -s -n 1 key_input
    echo "--------------------------------------------------------------------------"
	echo " "
	echo "SHORT SETTINGS"
	echo "NOTE: If a long test is scheduled to be conducted, the short test for that drive will"
	echo "not be performed if it would have been scheduled for the same day."
	echo " "
	echo "Short_Test_Mode=[1|2|3]"
	echo "This setting has three options:"
	echo "    A VALUE OF '3' WILL DISABLE SHORT TESTING COMPLETELY"
	echo "    A VALUE OF '2' WILL SHORT TEST ALL DRIVES"
	echo "    A VALUE OF '1' WILL SHORT TEST THE DRIVES BASED ON THE SETTINGS BELOW"
	echo " "
	echo "Short_Time_Delay_Between_Drives=[1..XX]"
	echo "This setting introduces a delay between the commencement of each successive drive test."
	echo " "
	echo 'Short_SMART_Testing_Order="[DriveID|Serial]"'
	echo "This setting will sort the drives by driveid (ada0, ada1, ada2 or sda, sdb, sdc) or"
	echo "by serial number.  The purpose of serial number is a poor mans attempt to randomize"
	echo "the drives being tested, mainly for long tests, in an effort to mitigate a group of"
	echo "drives in the same bay (NEXT TO EACH OTHER) being tested at the same time in order"
	echo "to reduce heat build up and to reduce current draw from multiple drive cages."
	echo " "
	echo "Short_Drives_to_Test_Per_Day=[1..XX]"
	echo "This setting allows you to select how many drives will be tested per day."
	echo "If you select too low of a value, the robot will recalculate the minimum value"
	echo "in order to finish testing all the drives in the given testing period."
	echo " "
	echo "Press Any Key to Continue"
	read -s -n 1 key_input
    echo "--------------------------------------------------------------------------"
	echo " "
	echo 'Short_Drives_Test_Period="[Week|Month]"'
	echo "This setting is the given time in which all drives must be tested within."
	echo "The values are Week OR Month."
	echo " "
	echo 'Short_Drives_Tested_Days_of_the_Week="[1,2,3,4,5,6,7]"'
	echo "This setting allows you to choose the days of the week that testing is allowed."
	echo "1=MONDAY, 2=TUESDAY, 3=WEDNESDAY, 4=THURSDAY, 5=FRIDAY, 6=SATURDAY, 7=SUNDAY"
	echo "Each value is comma separated.  This value is also used by the robot."
	echo " "
	echo "Short_Drives_Test_Delay=[1..XX]"
	echo "This value is available should you desire to let all SHORT tests complete"
	echo "before moving forward.  This is helpful if you have a script running after"
	echo "this script and need the SHORT tests completed.  However realize that"
	echo "Short and Long tests are never run on the same drive any given day by design."
	echo "The default value is 1 second."
	echo " "
	echo "The long test value descriptions are identical to the short test values, just"
	echo "for the long tests."
	echo " "
	echo 'Ignore_Drives_List="[any serial number]"'
	echo "This setting allows the user to remove specific or multiple drives from testing."
	echo "The value is comma delimited and you may desire for a drive to not be tested."
	echo " "
	echo "Press Any Key to Continue"
	read -s -n 1 key_input
    echo "--------------------------------------------------------------------------"
	echo " "
	echo "REPORT SECTION"
	echo "Drive_List_Length=[1..XX]"
	echo "This setting lists how many drives to list per line of the text output."
	echo " "
	echo 'Enable_Logging="[true|false]"'
	echo "This setting will enable writing a log file."
	echo "	"
	echo "LOG_DIR=[$LOG_DIR] (NOTE: SCRIPT_DIR WILL SHOW THE DIRECTORY YOU ARE RUNNING FROM.)"
	echo "This setting by default will write the log files to the script directory."
	echo "You may change this value to any valid directory."
	echo " "

    }

# CALLED FROM ONE LOCATION    
troubleshooting_help () {
    clear
    echo "TROUBLESHOOTING HELP                           Script Version: "$Version" "$Version_Date
    echo "You are running on "$programver
    echo " "
    echo "This section will attempt to help you define and solve any error messages"
    echo "in which you may encounter."
    echo " "
    echo "First: What is a problem message?"
    echo " 1. Anything that has the words 'DRATS' or 'DARN' is a minor problem."
    echo " 2. If you notice drives are being tested in an improper sequence."
    echo " 3. Any script failure messages."
    echo " "
    echo "Second: What is not a problem message?"
    echo " 1. Any message by the ROBOT.  These are informational letting you know"
    echo "    that you entered an unsustainable variable and ROBOT made an"
    echo "    adjustment to ensure all drives are testing in the configured time frame."
    echo " 2. 'Skipping drive' means the drive was already in test."
    echo " 3. Days being skipped in '-demo' mode.  First check your Authorized Days"
    echo "    to run the test, odds are you are missing the week days not included."
    echo " "
    echo "For a 'DRATS' or 'DARN' message, this means that the drive is already in test,"
    echo "and therefore was not expected to be in test.  Reasonable possibilities are:"
    echo " 1. You are running the script while a SMART test is already in progress."
    echo "Hum, that is all I got."
	echo " "
	echo "Press Any Key to Continue"
	read -s -n 1 key_input
    echo "--------------------------------------------------------------------------"
	echo " "
	echo "If you are virtualizing a drive, this script removes virtual drives."
	echo "You will need to pass through the controller or run bare metal."
	echo "Even real drives passed through as RDM (ESXi) will be seen as Virtual."
    echo " "
	echo "If you feel the script is taking too long, then use the '-timer' switch"
	echo "to generate a new file with timing information.  Joe needs that."
	echo " "
    echo "For any other failures, contact Joe at joeschmuck2023@hotmail.com with"
    echo "the following details: A copy of the log data file(s).  If you feel a few"
    echo "earlier log data files would help, send those as well. And any other"
    echo "information you feel is relevant."
    echo " "
    echo "--- Be patient as I will answer as soon as I see the email, I am not glued"
    echo "to my computer and have a life.  I may ask you to perform a few commands"
    echo "to help troubleshoot the issue."
    echo " "
	echo "Five Waka Waka Jokes: https://www.youtube.com/watch?v=rDpUAqQPnzM"
	
    }


######################### PROGRAM STARTS HERE ##########################
#

### Use multi_report_config.txt or not?
# If the file does not exist, script values will be used and no error message will be generated.
# Either setting the Use_multi_report_config_values="true" (at top of script), or switch will use the Multi-Report file, if it exists.
# First line finds out if this script was called by Multi-Report.

#echo "Shell Level:"$SHLVL

# Abort "this" Check for update if being run from another shell.
if [[ $SHLVL -eq 1 ]]; then
	checkforupdate
fi

if test -e "$Config_File_Name" || [[ $1 == "-use_external_file" ]]; then
	if [[ $Use_multi_report_config_values == "true" ]]; then
		if test -e "$Config_File_Name"; then
			. "$Config_File_Name"
		else
			echo "Using script values..."
		fi
	fi
fi

if [[ $Automatic_Selftest_Update == "true" ]] && [[ $UpdateDriveAvailable == "true" ]]; then checkforupdate; fi
if [[ $1 == "-update" ]]; then
	checkforupdate
	sleep 1
	exit 0
fi

### DELETE ANY LEFTOVER TEMPORARY FILES IF THEY EXIST
rm "/tmp/drive_test_timer_temp.txt" > /dev/null 2<&1
rm "/tmp/drive_test_temp.txt" > /dev/null 2<&1

(echo "Joe's SMART Drive Self-test Script - Run: "$today_day" "$Full_Month_Name" "$(date +%r)
echo "Script Version: "$Version" "$Version_Date", "$programver
if [[ $Enable_Logging == "true" ]]; then
	if ! test -e "$LOG_DIR"; then
		echo "'"$LOG_DIR"' does not exist, attempting to create it..."
		mkdir $LOG_DIR
		if test -e "$LOG_DIR"; then
			echo "Success"
		else
			echo "Failed to create '"$LOG_DIR"', using script default directory of "$SCRIPT_DIR
			LOG_DIR=$SCRIPT_DIR
		fi
	fi
	if [[ $Silent != "true" ]]; then
		echo " "
		echo "Logging Enabled"
	fi
#	echo " "
fi
if [[ $Silent == "true" ]]; then
	echo "Silent Enabled - Only Errors Will Be Reported"
fi ) | tee /tmp/drive_test_temp.txt /tmp/drive_test_timer_temp.txt
SECONDS=0			# Lets start the timer
if [[ $softver != "Linux" ]]; then start_time_display=$(date '+%H:%M:%S'); else start_time_display=$(date +"%H:%M:%S.%2N"); fi
(echo "This log file is used to track the execution time for each routine and identify any location to optimize if possible."; echo " "
echo $start_time_display":  Program Start"; echo " ") >> /tmp/drive_test_timer_temp.txt

#### SETUP SCRIPT TO ACKNOWLEDGE ANY ORDER OF SWITCHES.

#  OPTIONS ARE '-demo' 'short' 'long' week' 'month' '1' '2' '3' BUT NOT TWO OF THE SAME GROUP - CASE INSENSITIVE ###
counter_loop=0
short_cli=0
long_cli=0
week_cli=0
month_cli=0
x1_cli=0
x2_cli=0
x3_cli=0
x_cli=0
timer_flag=0
drive_selftest_dump="false"

shopt -s nocasematch			# Make it case-insensitive

	if [[ $1 == "-use_external_file" ]]; then
		echo "Using External Configuration File"
		if [[ $2 == "-dump" ]]; then
			drive_selftest_dump="true"
			echo "Saving Dump Data"
		fi
	elif [[ $1 == "-dump" ]]; then
		drive_selftest_dump="true"
		echo "Saving Dump Data"
	elif [[ $1 == "-demo" ]]; then
		Demo="true"
	elif [[ $1 == "-clearlog" ]]; then
		delete_log_files
		exit 0
	elif [[ $1 == "-help" ]]; then
		help_text
		echo " "
		exit 0
	elif [[ $1 == "-timer" ]] || [[ $2 == "-timer" ]]; then
		timer_flag=1
	elif [[ $1 == "-debug" ]] || [[ $2 == "-debug" ]] || [[ $3 == "-debug" ]] || [[ $4 == "-debug" ]] ; then
		Debug="true"
	elif [[ $1 != "" ]]; then
		echo "Command Line Options is invalid."
		echo "You may use '-help' for further information"
		echo " "
		exit 1
	fi

if [[ $Demo == "true" ]]; then
    counter_loop=0
    while [ $counter_loop -lt 20 ]; do                # Check for any order of the CLI switches ONLY if -demo is present.
        if [[ $1 == "short" ]]; then short_cli=1; fi    
        if [[ $1 == "long" ]]; then long_cli=1; fi    
        if [[ $1 == "week" ]]; then week_cli=1; fi
        if [[ $1 == "month" ]]; then month_cli=1; fi
        if [[ $1 == "DriveID" ]]; then DriveID_cli=1; fi
        if [[ $1 == "Serial" ]]; then Serial_cli=1; fi
        if [[ $1 == "1" ]]; then x1_cli=1; fi
        if [[ $1 == "2" ]]; then x2_cli=1; fi
        if [[ $1 == "3" ]]; then x3_cli=1; fi
        shift 1        # rotate $1 value
        (( counter_loop ++ ))
    done

    # Not two of the opposite values
    if [[ $week_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Long_Drives_Test_Period="Week"; fi    
    if [[ $week_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Drives_Test_Period="Week"; fi    
    if [[ $month_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Drives_Test_Period="Month"; fi
    if [[ $month_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Drives_Test_Period="Month"; fi
    if [[ $DriveID_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_SMART_Testing_Order="DriveID"; fi
    if [[ $DriveID_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_SMART_Testing_Order="DriveID"; fi
    if [[ $Serial_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_SMART_Testing_Order="Serial"; fi
    if [[ $Serial_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_SMART_Testing_Order="Serial"; fi

    if [[ $short_cli -eq 1 ]]; then Short_Test_Mode=1; Long_Test_Mode=3; fi
    if [[ $long_cli -eq 1 ]]; then Short_Test_Mode=3; Long_Test_Mode=1; fi

    if [[ $x1_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Test_Mode=1; Long_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x2_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Test_Mode=2; Long_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x3_cli -eq 1 ]] && [[ $short_cli -eq 1 ]]; then Short_Test_Mode=3; Long_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x1_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Test_Mode=1; Short_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x2_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Test_Mode=2; Short_Test_Mode=3; (( x_cli ++ )); fi
    if [[ $x3_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then Long_Test_Mode=3; Short_Test_Mode=3; (( x_cli ++ )); fi

# Error Messages
    if [[ $short_cli -eq 1 ]] && [[ $long_cli -eq 1 ]]; then echo "You cannot specify both 'short' and 'long' at the same time."; exit 1; fi
    if [[ $week_cli -eq 1 ]] && [[ $month_cli -eq 1 ]]; then echo "You cannot specify both 'week' and 'month' at the same time."; exit 1; fi
    if [[ $(( x1_cli + x2_cli + x3_cli )) -gt 1 ]]; then echo "You cannot specify more than one test mode (1, 2, or 3) on the CLI."; exit 1; fi
    if [[ $DriveID_cli -eq 1 ]] && [[ $Serial_cli -eq 1 ]]; then echo "You cannot specify both 'DriveID; and 'Serial' at the same time."; exit 1; fi
    if [[ $(( mon_cli + tue_cli + wed_cli + thu_cli + fri_cli + sat_cli + sun_cli )) -gt 1 ]]; then echo "You cannot specify multiple days of the week (Mon - Sun)"; exit 1; fi
fi

if [[ $1 == "-demo" ]]; then
    Demo="true"
    echo "Demo Mode: Below is the simulated testing schedule based on current settings."
    echo " "
    (    echo "Demo Mode: Below is the simulated testing schedule based on current settings."
    echo " ") >> /tmp/drive_test_temp.txt
fi

if [[ $Demo == "true" ]] && [[ $short_cli -eq 1 ]]; then Long_Test_Mode=3; fi
if [[ $Demo == "true" ]] && [[ $long_cli -eq 1 ]]; then Short_Test_Mode=3; fi
if ! [[ $timer_flag -eq 1 ]]; then 
    if [[ $1 != "" ]] && [[ $1 != "-demo" ]] && [[ $1 != "-debug" ]] && [[ $1 != "-use_external_file" ]] && [[ $1 != "-dump" ]]; then help_text; fi
    if [[ $2 != "short" ]] && [[ $2 != "long" ]] && [[ $2 != "" ]] && [[ $2 != "-dump" ]]; then help_text; fi
fi
shopt -u nocasematch

(( Drive_List_Length -- ))            # Adjust for offset
get_API_Drives                        # Grab all the drive data at one single time

if [[ $Long_Test_Mode -ne 0 ]]; then
    smartctl_selftest Short           # Run Short HDD/SSD SMART Tests
fi
if [[ $Short_Test_Mode -ne 0 ]]; then
    smartdrives_sorted=""             # Reset the variable
    smartctl_selftest Long            # Run Long HDD/SSD SMART Tests
fi

# Convert Authorized Days to Text String just so we can add it to the Multi-Report output.
Short_DOW_days=""
IFS=","
for day_of_week_test in $Short_Drives_Tested_Days_of_the_Week; do
    case $day_of_week_test in                               # Lets give us days of the week.
        1)    day_of_week="Mon"    ;;
        2)    day_of_week="Tue"    ;;
        3)    day_of_week="Wed"    ;;
        4)    day_of_week="Thu"    ;;
        5)    day_of_week="Fri"    ;;
        6)    day_of_week="Sat"    ;;
        7)    day_of_week="Sun"    ;;
    esac
    if [[ $Short_DOW_days == "" ]]; then                          # The first match by itself.
        Short_DOW_days=$day_of_week
    else
        Short_DOW_days=$Short_DOW_days", "$day_of_week                  # Ass successive matches joined together by a comma.
    fi
done

Long_DOW_days=""
for day_of_week_test in $Long_Drives_Tested_Days_of_the_Week; do
    case $day_of_week_test in                               # Lets give us days of the week.
        1)    day_of_week="Mon"    ;;
        2)    day_of_week="Tue"    ;;
        3)    day_of_week="Wed"    ;;
        4)    day_of_week="Thu"    ;;
        5)    day_of_week="Fri"    ;;
        6)    day_of_week="Sat"    ;;
        7)    day_of_week="Sun"    ;;
    esac
    if [[ $Long_DOW_days == "" ]]; then                          # The first match by itself.
        Long_DOW_days=$day_of_week
    else
        Long_DOW_days=$Long_DOW_days", "$day_of_week                  # Ass successive matches joined together by a comma.
    fi
done
	
# These two lines should never result in None
if [[ $Short_DOW_days == "" ]]; then Short_DOW_days="None"; fi
if [[ $Long_DOW_days == "" ]]; then Long_DOW_days="None"; fi
	
IFS=$IFS_RESTORE

if [[ $Short_Drives_Testing == "" ]]; then Short_Drives_Testing="none"; fi
if [[ $Long_Drives_Testing == "" ]]; then Long_Drives_Testing="none"; fi

(echo "<b>   a) Short Test Authorized Test Days (</b>"$Short_DOW_days"<b>) (</b>~$Drives_to_Test_Per_Day Drive(s) per day<b>)</b>"
 echo "      ("$Short_Drives_Testing")"
 echo "<b>   b) Long Test Authorized Test Days (</b>"$Long_DOW_days"<b>) (</b>~$Drives_to_Test_Per_Day Drive(s) per day<b>)</b>"
 echo "      ("$Long_Drives_Testing")" ) > /tmp/smartdrive_selftest_text.txt

(if [[ $NVMe_Override_Enabled == "true" ]]; then
	echo "<b>5) NVMe S.M.A.R.T. Testing using 'nvme' commands vice 'smartctl'</b><br><br>"
 else
	echo "<br><br>"
 fi) >> /tmp/smartdrive_selftest_text.txt

# CALCULATE THE SCRIPT DURATION
if [[ $softver != "Linux" ]]; then
	end_time_display=$(date '+%H:%M:%S')
else
	elapsed_time $start_time_display
fi

# PRINT THE SCRIPT DURATION
(echo " "
echo $end_time_display":  Drive-Selftest Wrapping things up..."
 echo -n "Elapsed Time: Program $((SECONDS / 60)) minutes and $((SECONDS % 60))"
if [[ $end_tenths != "" ]]; then
	echo ".$end_tenths seconds elapsed."
else
	echo " seconds elapsed."
fi
echo " ") | tee -a /tmp/drive_test_temp.txt

# TIME TO TELL EVERYONE THE DURATION OF THE WAIT
(
if [[ $No_Tests == "false" ]]; then
	if [[ $Short_Drives_Test_Delay -lt 6 ]]; then
		echo "Your $Short_Drives_Test_Delay Second Delay..."
	else
		echo "Your $Short_Drives_Test_Delay Second Delay, Please Standby..."
	fi
fi
) | tee -a /tmp/drive_test_temp.txt

# IF LOGGING ENABLBED, WRITE THE THREE FILES
if [[ $Enable_Logging == "true" ]]; then
    if [[ $Demo == "true" ]]; then
		echo " "
        echo "Saving Log (file name: $LOG_DIR/drive_test_demo_${today_day#0}.txt)" | tee -a /tmp/drive_test_temp.txt
        cat /tmp/drive_test_temp.txt > $LOG_DIR/drive_selftest_demo_${today_day#0}.txt
    else
        echo "Saving Log (file name: $LOG_DIR/drive_test_${today_day}.txt)" | tee -a /tmp/drive_test_temp.txt
		echo "Exiting Joe's SMART Drive Self-test Script" >> /tmp/drive_test_temp.txt
        cat /tmp/drive_test_temp.txt > $LOG_DIR/drive_selftest_${today_day#0}.txt
    fi
	if [[ $timer_flag -eq 1 ]]; then
		echo "Exiting Joe's SMART Drive Self-test Script" >> /tmp/drive_test_timer_temp.txt
		cat /tmp/drive_test_timer_temp.txt > $LOG_DIR/drive_selftest_timer_${today_day#0}.txt
	fi

	if [[ $drive_selftest_dump != "true" ]]; then		# Leave the files behind for Multi-Report to collect.
		rm /tmp/drive_test_timer_temp.txt > /dev/null 2<&1
		rm /tmp/drive_test_temp.txt > /dev/null 2<&1
	fi
fi

# Leave "/tmp/smartdrive_selftest_text.txt" for Multi-Report

if [[ $No_Tests == "true" ]]; then
	if [[ $Demo == "true" ]]; then
		echo "SIMULATION: "$Short_Drives_Test_Delay" second timer skipped."
	fi
else
	sleep $Short_Drives_Test_Delay			# Sleep XXX seconds to wait for Short tests to complete before returning to controlling procedure.
fi

echo "Exiting Joe's SMART Drive Self-test Script"

exit 0